<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="../../style.css">
        <link rel="stylesheet" type="text/css" href="../../paren-soup-light.css">
    </head>
    <body>
        <span id="app"><div data-reactroot="" data-reactid="1" data-react-checksum="-1148669901"><div style="left:0;" class="vars" data-reactid="2"><!-- react-empty: 3 --><div data-reactid="4"><div data-reactid="5"><h2 data-reactid="6">(get-delta-time game)</h2></div><div class="section doc" data-reactid="7">Returns the time since the last frame was rendered, in milliseconds.</div></div><div class="footer" data-reactid="8"><!-- react-text: 9 -->Generated by <!-- /react-text --><a href="https://github.com/oakes/Dynadoc" target="_blank" data-reactid="10">Dynadoc</a></div></div></div></span>
        <script type="text/edn" id="initial-state">{:ns-meta nil, :var-sym get-delta-time, :type :cljs, :nses [{:var-syms [cljs cljs-version main-files assert-cljs-edn!], :type :clj, :sym adzerk.boot-cljs} {:var-syms [compiled analyzed], :type :clj, :sym adzerk.boot-cljs.js-deps} {:var-syms [main non-standard-defaults compiler-options modules set-option source-map], :type :clj, :sym adzerk.boot-cljs.middleware} {:var-syms [last-cause find-original-path path->js path get-name merge-cause-ex-data path->ns deserialize-object last-cause-message find-relative-path serialize-object], :type :clj, :sym adzerk.boot-cljs.util} {:var-syms [connect handle patch-goog-base! resolve-url], :type :cljs, :sym adzerk.boot-reload.client} {:var-syms [alive? send-message! ws-conn], :type :cljs, :sym adzerk.boot-reload.connection} {:var-syms [->css cljs-logo construct-hud-node current-container display exception-node gen-id insert-container! logo-node mk-node open-file reloaded-node remove-container! style transition-duration warning-node warnings-node], :type :cljs, :sym adzerk.boot-reload.display} {:var-syms [has-dom? load-files reload], :type :cljs, :sym adzerk.boot-reload.reload} {:var-syms [IWebSocket open? websocket-connection], :type :cljs, :sym adzerk.boot-reload.websocket} {:var-syms [game main-screen state], :type :cljs, :sym basic-game.client} {:var-syms [handler -main], :type :clj, :sym basic-game.server} {:var-syms [clifn defclifn], :type :clj, :sym boot.cli} {:var-syms [tmppath tmptime output-dirs replace-task! sync! reset-fileset fileset-changed post-env! fileset-namespaces get-env with-pre-wrap not-by-path *warnings* deftask tmp-dir patch! user-dirs tmpget cleanup rm input-files fileset-reduce not-by-meta output-files bootignore add-cached-source with-post-wrap merge-env! tmpdir mv by-meta init! output-fileset get-checkouts gpg-decrypt by-name not-by-ext add-cached-asset tmp-get input-fileset new-fileset commit! not-by-re configure-repositories! by-ext mv-asset by-re *app-version* boot user-files set-env! task-options! file-filter temp-dir! mv-resource add-resource load-data-readers! tmp-path template json-parse reset-build! pre-env! fileset-diff new-build-at rebuild! ls *boot-script* watch-dirs add-source last-file-change fileset-removed cp *boot-opts* add-asset launch-nrepl yaml-generate yaml-parse empty-dir! add-cached-resource get-sys-env not-by-name set-sys-env! mv-source cache-dir! json-generate git-files touch fileset-added disable-task! tmp-dir! tmpfile with-pass-thru input-dirs tmp-file by-path tmp-time *boot-version* add-meta], :type :clj, :sym boot.core} {:var-syms [windows? sync! delete-empty-subdirs! guard hard-link delete-file path srcdir->outdir parent? tmpdir clean! copy-with-lastmod patch parent parent-seq copy-files *hard-link* name *include* move *exclude* *ignore* *sync-delete* file-seq relative-to lockfile file-seq-nofollow file? walk-file-tree patch-cp? empty-dir! watcher! split-path print-ex exists? sym-link dir? delete-all match-filter? tmpfile time-diff tmpfile-permissions copy-atomically keep-filters? tree-for], :type :clj, :sym boot.file} {:var-syms [windows? tree-diff map->FileSystemTree read-only skip-subtree link! merge-trees mkignores patch! mkvisitor ->FileSystemTree IToPath touch! path->segs ->path tmp-attrs open-opts continue mkparents! link-opts copy! tree-patch copy-opts write! mkjarfs delete! mktree], :type :clj, :sym boot.filesystem} {:var-syms [patch patch-result], :type :clj, :sym boot.filesystem.patch} {:var-syms [syntax-quote-fn unquote-splicing? quote-fn unquote? *resolve* resolve-symbol template syntax-quote defquote template-fn], :type :clj, :sym boot.from.backtick} {:var-syms [cli parse-opts summarize compile-option-specs], :type :clj, :sym boot.from.clojure.tools.cli} {:var-syms [sha-256 sha Digestible sha-1 md5 sha-384 -digest md2 sha-512 digest sha1 sha-224 algorithms *buffer-size*], :type :clj, :sym boot.from.digest} {:var-syms [cyan-bg magenta red-font bold-yellow-bg-font bold-green bold-yellow bold-red-bg bold-white-bg bold-cyan italic cyan-font strip-ansi bold-green-bg-font bold-red-bg-font visual-length black bold-black-bg bold bold-yellow-bg white-font bold-white bold-red red-bg cyan-bg-font bold-cyan-bg magenta-bg-font yellow-bg black-font yellow-bg-font white yellow bold-black-bg-font bold-green-bg bold-font inverse reset-font green-bg-font inverse-font white-bg-font green cyan black-bg-font green-font bold-magenta bold-red-font blue-bg-font bold-magenta-bg-font bold-cyan-font bold-white-bg-font blue-bg green-bg bold-blue-bg italic-font csi black-bg blue-font magenta-font yellow-font red-bg-font bold-yellow-font white-bg bold-cyan-bg-font magenta-bg bold-magenta-bg sgr bold-magenta-font red blue bold-black-font bold-blue-font bold-white-font bold-black bold-blue-bg-font bold-green-font bold-blue], :type :clj, :sym boot.from.io.aviso.ansi} {:var-syms [max-value-length format-columns write-rows max-length], :type :clj, :sym boot.from.io.aviso.columns} {:var-syms [*traditional* *fonts* format-exception *default-frame-filter* write-exception* *default-frame-rules* exception-dispatch demangle expand-stack-trace write-exception parse-exception analyze-exception], :type :clj, :sym boot.from.io.aviso.exception} {:var-syms [pretty-print format-exception pretty-print-stack-trace copy uncaught-exception-handler install-pretty-exceptions paste pretty-repl-caught pretty-pst], :type :clj, :sym boot.from.io.aviso.repl} {:var-syms [StringWriter flush-writer write into-string write-string writeln writef eol], :type :clj, :sym boot.from.io.aviso.writer} {:var-syms [feed-from flush exit-code done feed-from-string stream-to-string proc stream-to destroy read-line stream-to-out], :type :clj, :sym boot.from.me.raynes.conch} {:var-syms [format-cell table *style* table-str], :type :clj, :sym boot.from.table.core} {:var-syms [auto-resize-widths outer-border-length get-widths get-initial-widths ensure-valid-width *width* inner-border-length], :type :clj, :sym boot.from.table.width} {:var-syms [tag branch-current ls-tags clean? dirty? status last-commit describe ls-files make-gitignore-matcher], :type :clj, :sym boot.git} {:var-syms [gpg sign gpg-program signing-args sign-jar decrypt], :type :clj, :sym boot.gpg} {:var-syms [update-zip! spit-jar! jarentry spit-zip! dupe? update-jar!], :type :clj, :sym boot.jar} {:var-syms [normalize no-incoming choose topo-sort], :type :clj, :sym boot.kahnsort} {:var-syms [cli-opts parse-bootignore -main shebang? pr-boot-form emit], :type :clj, :sym boot.main} {:var-syms [prn-conflicts dep-conflicts safe-read-string compare-version resolved-versions sortable-version], :type :clj, :sym boot.pedantic} {:var-syms [sealed-classloader-fns with-worker apply-global-exclusions require-in copy-url classloader-resources resolve-release-versions resources pom-xml concat-merger jars-dep-graph eval-in* full-id with-eval-in worker-pod jar-entries* pom-xml-map dependency-pom-properties pod-pool pom-properties data resolve-dependency-jar dependency-pom-properties-map add-dependencies first-wins-merger standard-jar-exclusions destroy-pod canonical-id coord->map with-call-worker send! pom-properties-map canonical-coord unpack-jar this-pod make-pod extend-addable-classloader outdated with-eval-worker resolve-dependencies make-pod-cp pod-id non-caching-url-input-stream into-merger add-shutdown-hook! eval-fn-call pod-name with-invoke-in modifiable-classloader? with-call-in add-dependencies-in jar-entries seal-app-classloader jar-entries-memoized* call-in* classloader-hierarchy copy-resource resolve-nontransitive-dependencies default-dependencies eval-in-callee set-worker-pod! env set-this-pod! caller-namespace add-classpath set-data! with-invoke-worker dependency-loaded? apply-exclusions copy-dependency-jar-entries set-pod-id! map->coord standard-jar-mergers resource-last-modified resolve-dependency-jars jars-in-dep-order with-pod get-classpath pods get-pods eval-in-caller extract-ids set-pods! add-dependencies-worker shutdown-hooks lifecycle-pool], :type :clj, :sym boot.pod} {:var-syms [*default-dependencies* *default-middleware* launch-nrepl], :type :clj, :sym boot.repl} {:var-syms [sift-action read-pass print-fileset], :type :clj, :sym boot.task-helpers} {:var-syms [notify-method boot-logo get-themefiles audible-notify! visual-notify!], :type :clj, :sym boot.task-helpers.notify} {:var-syms [target notify help speak pom sift show web install push jar checkout javac with-cp war add-repo aot zip watch repl wait uber], :type :clj, :sym boot.task.built-in} {:var-syms [->TmpDir ->TmpFileSet add add-tmp map->TmpFileSet removed rm diff path add-cached ITmpFileSet mv hash dir bdir commit! added *hard-link* file time map->TmpDir CACHE_VERSION map->TmpFile state ITmpFile ls cp tmpfileset? ->TmpFile tmpfile? fileset-patch restrict-dirs id changed], :type :clj, :sym boot.tmpdir} {:var-syms [->TmpRegistry -mk! mkdir! mk! mark-delete-me! -get munged-file -init! get init! clean-delete-me! dir-id registry map->TmpRegistry unmk! make-file! tmp-file? -unmk! delete! ITmpRegistry -tmpfile?], :type :clj, :sym boot.tmpregistry} {:var-syms [jar-exclusions deploy local run build-cljs build], :type :clj, :sym boot.user} {:var-syms [sh with-let dbug *verbosity* without-exiting exit-error with-err-str guard dotoseq extends-protocol with-rethrow with-semaphore dosh colorize?-system-default jarname do-while-let exit-ok dep-as-map bind-syms warn path->ns let-assert-keys read-string-all pp-str with-semaphore-noblock *sh-dir* with-resolve dbug* print-tree auto-flush *colorize?* fail print-ex map-as-dep pp* while-let warn-deprecated index-of info extract-ids], :type :clj, :sym boot.util} {:var-syms [->clj *to-pod* *from-pod* *for-eval*], :type :clj, :sym boot.xform} {:var-syms [type? get-namespace error-message elide-reader-meta missing-rename? resolve-invokeable-ns analyze-let with-core-macros var-meta desugar-ns-specs js-tag? analyze-map NUMERIC_SET analyze-record analyze-seq* constants-ns-sym resolve-alias *cljs-dep-set* resolve-var write-analysis-cache disallowing-ns* process-rewrite-form js-star-seg dep-has-global-exports? register-specs gen-user-ns *passes* has-extern?* get-expander-ns message parse-invoke *cljs-warning-handlers* disallowing-recur analyze-seq*-wrap confirm-bindings has-extern? foreign-dep? missing-rename-macro? missing-uses missing-use? with-warning-handlers es5-allowed analyze used? node-module-dep? parse-type gets check-rename-macros-inferring-missing *allow-ns* transit-write-opts forms-seq* infer-invoke *cljs-static-fns* array-types *check-alias-dupes* macro-ns-name *reload-macros* resolve-existing-var required? NOT_NATIVE *unchecked-arrays* IGNORE_SYM parse-invoke* *checked-arrays* aliasable-clj-ns? loaded-js-ns? analyze-vector transit-read-opts namespaces elide-analyzer-meta analyze-let-body get-col basic-validate-ns-spec *cljs-warnings* alias->type analyzed? analyze-deps array-type? dotted-symbol? *cljs-macros-is-classpath* locate-src ns-side-effects *allow-redef* analyze-fn-method-body infer-type parse-import-spec clj-ns->cljs-ns constant-value? dump-specs *fn-invoke-direct* use->require inferred-use-macros read-analysis-cache analyze-symbol confirm-var-exists analyze-keyword SENTINEL analyze-let-bindings munge-global-export *loop-lets* js-tag js-reserved *load-tests* requires-analysis? check-use-macros-inferring-missing load-core macroexpand-1* check-use-macros get-expander analyze-js-star build-dot-form js-star-interp *recur-frames* analyze-fn-methods-pass2* macroexpand-1 analyze-file resolve-macro-var analyze-let-binding-init infer-tag canonicalize-import-specs analyze-form-seq analyze-let-body* analyze-js-star* inferred-rename-macros parse-ns-error-msg missing-use-macro? analyzed resolve-symbol all-warn missing-renames resolve* *cljs-macros-path* load-mutex confirm-var-exist-warning unchecked-arrays? analyze-dot analyze-do-statements get-line analyze-do-statements* analyze-seq find-def-clash get-expander* no-warn allowing-redef fn-name-var munge-node-lib *load-macros* excluded? empty-env public-name? default-warning-handler resolve-ns-alias intern-macros BOOLEAN_OR_SEQ *macro-infer* gen-constant-id BOOLEAN_SYM cache-file macro-autoload-ns? get-tag implicit-nses valid-proto parse-ns normalize-js-tag analyze-list warning implicit-import? missing-use-macros rewrite-cljs-aliases analyze* -cljs-macros-loaded check-uses find-matching-method invoke-arg-type-validators *cljs-file* *file-defs* infer-if *verbose* analyze-js-value ns->module-type source-info wrapping-errors transit analyze-fn-method-param analyze-set numeric-type? ast? checked-arrays elide-env js-module-exists?* parse-require-spec analyze-wrap-meta ANY_SYM get-js-tag parse forms-seq *analyze-deps* analyze-let-bindings* analysis-error? replace-env-pass parse-ns-excludes analyze-fn-methods-pass2 core-name? get-let-tag specials resolve-macro-ns-alias check-invoke-arg-types confirm-ns default-namespaces *unchecked-if* canonicalize-specs confirm-var-exists-throw js-module-exists? analyze-form with-core-macros-file var-ast add-consts error invokeable-ns? *cljs-ns*], :type :clj, :sym cljs.analyzer} {:var-syms [*allow-ns* *allow-redef* *analyze-deps* *check-alias-dupes* *checked-arrays* *cljs-dep-set* *cljs-file* *cljs-macros-is-classpath* *cljs-macros-path* *cljs-ns* *cljs-static-fns* *cljs-warning-handlers* *cljs-warnings* *file-defs* *fn-invoke-direct* *load-macros* *load-tests* *loop-lets* *macro-infer* *passes* *recur-frames* *reload-macros* *verbose* -cljs-macros-loaded ANY_SYM BOOLEAN_OR_SEQ BOOLEAN_SYM CLJS_CORE_MACROS_SYM CLJS_CORE_SYM CLJ_NIL_SYM DOT_SYM IGNORE_SYM JS_STAR_SYM NEW_SYM NOT_NATIVE NUMBER_SYM NUMERIC_SET SENTINEL STRING_SYM add-consts alias->type analysis-error? analyze analyze* analyze-deps analyze-do-statements analyze-do-statements* analyze-dot analyze-fn-method-body analyze-fn-method-param analyze-fn-methods-pass2 analyze-fn-methods-pass2* analyze-form analyze-form-seq analyze-js-star analyze-js-star* analyze-js-value analyze-keyword analyze-let analyze-let-binding-init analyze-let-bindings analyze-let-bindings* analyze-let-body analyze-let-body* analyze-list analyze-map analyze-record analyze-seq analyze-seq* analyze-seq*-wrap analyze-set analyze-symbol analyze-vector analyze-wrap-meta analyzed analyzed? array-type? array-types ast? basic-validate-ns-spec build-dot-form canonicalize-import-specs canonicalize-specs check-invoke-arg-types check-rename-macros-inferring-missing check-use-macros check-use-macros-inferring-missing check-uses checked-arrays clj-ns->cljs-ns cljs-map? cljs-seq? cljs-set? cljs-vector? confirm-bindings confirm-ns confirm-var-exist-warning confirm-var-exists confirm-var-exists-throw constant-value? constants-ns-sym core-name? default-namespaces default-warning-handler dep-has-global-exports? desugar-ns-specs dotted-symbol? dump-specs elide-analyzer-meta elide-env elide-reader-meta empty-env error error-message es5-allowed excluded? find-def-clash find-matching-method fn-name-var foreign-dep? gen-constant-id get-col get-expander get-expander* get-expander-ns get-js-tag get-let-tag get-line get-macroexpand-check-var get-namespace get-tag gets has-extern? has-extern?* implicit-import? implicit-nses infer-if infer-invoke infer-tag infer-type inferred-rename-macros inferred-use-macros intern-macros invoke-arg-type-validators invokeable-ns? js-module-exists? js-module-exists?* js-reserved js-star-interp js-star-seg js-tag js-tag? loaded-js-ns? macro-autoload-ns? macro-ns-name macroexpand-1 macroexpand-1* message missing-rename-macro? missing-rename? missing-renames missing-use-macro? missing-use-macros missing-use? missing-uses munge-global-export munge-node-lib munge-path namespaces node-module-dep? normalize-js-tag ns->module-type ns->relpath numeric-type? parse parse-import-spec parse-invoke parse-invoke* parse-ns-error-msg parse-ns-excludes parse-require-spec parse-type public-name? register-specs replace-env-pass required? resolve* resolve-alias resolve-existing-var resolve-invokeable-ns resolve-macro-ns-alias resolve-macro-var resolve-ns-alias resolve-symbol resolve-var source-info specials topo-sort type? unchecked-arrays? use->require used? valid-proto var-ast var-meta warning], :type :cljs, :sym cljs.analyzer} {:var-syms [with-state find-ns remove-ns ns-publics get-options in-cljs-user analyze warning-enabled? ns-resolve empty-state analyze-file no-warn empty-env default-warning-handler parse-ns ns-interns all-ns forms-seq resolve get-js-index], :type :clj, :sym cljs.analyzer.api} {:var-syms [with-core-macros disallowing-ns* disallowing-recur with-warning-handlers no-warn allowing-redef wrapping-errors with-core-macros-file], :type :clj, :sym cljs.analyzer.macros} {:var-syms [allowing-redef disallowing-ns* disallowing-recur no-warn with-core-macros with-core-macros-file with-warning-handlers wrapping-errors], :type :cljs, :sym cljs.analyzer.macros} {:var-syms [get-node-deps compile install-node-deps! add-implicit-options add-dependencies ns->location target-file-for-cljs-ns compiler-opts? mark-cljs-ns-for-recompile! node-inputs src-file->target-file source-on-disk ns->source src-file->goog-require inputs build cljs-dependents-for-macro-namespaces goog-dep-string watch parse-js-ns output-unoptimized], :type :clj, :sym cljs.build.api} {:var-syms [output-directory -compile add-goog-base cljs-dependencies map->javascript-file ensure-cljs-base-module optimize-modules convert-js-modules path-from-jarfile compute-upstream-npm-deps aot-cache-core get-data-readers ISourceMap shim-process? get-closure-sources compile check-output-to check-output-wrapper add-dependency-sources get-compiled-cljs absolute-parent expand-libs known-opts compile-dir add-implicit-options preprocess-js add-dependencies -paths get-data-readers* warning-types path-relative-to check-preloads ensure-module-opts check-unprovided target-file-for-cljs-ns maybe-install-node-deps! -source-url Inputs add-header rel-output-path mark-cljs-ns-for-recompile! name-chars compile-sources output-one-file load-externs find-cljs-dependencies Compilable javascript-name random-char to-charset add-preloads parallel-compile-sources add-externs-sources preamble-from-paths javascript-file jar-file-to-disk process-js-modules node-module-deps ->JavaScriptFile make-convert-js-module-options check-npm-deps compiled-file node-inputs add-converted-source output-deps-file make-preamble check-source-map deps-file index-node-modules-dir js-dependencies src-file->target-file check-output-dir compile-file lang-key->lang-mode js-transforms load-data-readers! cljs-source-for-namespace write-js? source-on-disk write-javascript preloads random-string foreign-source? string->charset compile-from-jar add-js-sources -find-sources compile-loader add-dep-string js-source-file in-same-dir? source-for-namespace node-file-seq->libs-spec check-cache-analysis-format src-file->goog-require -source-map check-node-target get-upstream-deps* build handle-js-modules cljs-dependents-for-macro-namespaces check-source-map-path get-js-root get-source-files lib-rel-path map->JavaScriptFile index-node-modules build-provides build-modules find-jar-sources watch output-main-file output-modules same-or-subdirectory-of? report-failure make-closure-compiler add-source-map-link parse-js-ns check-level compile-form-seq compile-task output-unoptimized absolute-path? emit-optimized-source-map read-js add-wrapper make-options set-options get-upstream-deps foreign-deps-str optimize], :type :clj, :sym cljs.closure} {:var-syms [emit-constants-table-to-file protocol-prefix emit-arguments-to-array compile-file* distinct-keys? munge compile-root get-define valid-define-value? find-source emit-cached-core emits-keyword emit-inferred-externs-to-file *lexical-renames* emit-let with-core-cljs find-root-sources cljs-reserved-file-names base-types resolve-type emit-variadic-fn-method js-reserved *recompiled* rename-to-js requires-compilation? emits emit-constant emit-constants-table get-first-ns-segment emit-fn-params munge-reserved emit-source fn-self-name load-libs compile-file macro-ns? munge-param-return find-ns-starts-with emit* checking-types? cljs-files-in emit-fn-method emit-comment hash-scope emit-apply-to emits-symbol falsey-constant? *source-map-data* mapped-types resolve-types cached-core *inputs* emit-str compiled-by-string truthy-constant? emitln url-path emit safe-test? emit-externs emit-source-map distinct-constants? emit-wrap shadow-depth], :type :clj, :sym cljs.compiler} {:var-syms [*inputs* *lexical-renames* *recompiled* *source-map-data* base-types checking-types? cljs-reserved-file-names distinct-constants? distinct-keys? emit emit* emit-apply-to emit-arguments-to-array emit-comment emit-constant emit-constants-table emit-externs emit-fn-method emit-fn-params emit-let emit-str emit-variadic-fn-method emitln emits emits-keyword emits-symbol falsey-constant? find-ns-starts-with fn-self-name get-define get-first-ns-segment hash-scope js-reserved load-libs mapped-types munge munge-param-return munge-reserved protocol-prefix resolve-type resolve-types safe-test? shadow-depth truthy-constant? valid-define-value?], :type :cljs, :sym cljs.compiler} {:var-syms [emit-wrap], :type :clj, :sym cljs.compiler.macros} {:var-syms [emit-wrap], :type :cljs, :sym cljs.compiler.macros} {:var-syms [unsafe-bit-and macroexpand unchecked-remainder-int when-first cond->> bit-set import-macros while satisfies? unchecked-subtract-int ns-unmap import bit-shift-right aget specify vswap! caching-hash bit-shift-left coercive-not dec unchecked-get ns-publics < this-as .. delay some? unchecked-negate simple-benchmark unchecked-inc-int unchecked-set js-str bit-shift-right-zero-fill implements? goog-define pos? specify! if-not alength bit-xor doseq unsigned-bit-shift-right neg? unchecked-float undefined? deftype mask when-let divide coercive-boolean <= if-some * min lazy-seq js-delete truth_ js-debugger let -> coercive-not= doto areduce double bit-and-not unchecked-add-int fn short unchecked-double fast-path-protocols string? js-arguments unchecked-multiply-int as-> when-not when int > keyword? use-macros unchecked-multiply gen-apply-to some->> unchecked-dec defn float js-in es6-iterable amap use declare fast-path-protocol-partitions-count - hash-set or extend-type macroexpand-1 bit-test defmethod time zero? require unchecked-dec-int memfn js-obj nil? extend-protocol cond-> dotimes bit-and reify instance? load-file* defonce unchecked-add identical? unchecked-divide-int defn- defprotocol unchecked-subtract assert true? array letfn / bitpos bit-or vector >= loop bit-flip js-mod with-out-str condp cond some-> ns-interns for binding array-map unchecked-byte ns-imports defmacro unchecked-short inc with-redefs bit-clear locking list + aset destructure defmulti str coercive-= hash-map gen-apply-to-simple if-let false? case exists? bit-not byte max == lazy-cat comment copy-arguments unsafe-cast resolve defrecord make-array unchecked-negate-int unchecked-inc and number? js-comment symbol? when-some unchecked-char require-macros ->> js-inline-comment dt->et refer-clojure], :type :clj, :sym cljs.core} {:var-syms [* *1 *2 *3 *assert* *clojurescript-version* *command-line-args* *e *flush-on-newline* *loaded-libs* *main-cli-fn* *ns* *out* *print-dup* *print-err-fn* *print-fn* *print-fn-bodies* *print-length* *print-level* *print-meta* *print-namespace-maps* *print-newline* *print-readably* *target* *unchecked-arrays* *unchecked-if* *warn-on-infer* + - -> ->> ->ArrayChunk ->ArrayIter ->ArrayList ->ArrayNode ->ArrayNodeIterator ->ArrayNodeSeq ->Atom ->BitmapIndexedNode ->BlackNode ->Box ->ChunkBuffer ->ChunkedCons ->ChunkedSeq ->Cons ->Delay ->ES6EntriesIterator ->ES6Iterator ->ES6IteratorSeq ->ES6SetEntriesIterator ->Eduction ->Empty ->EmptyList ->HashCollisionNode ->HashMapIter ->HashSetIter ->IndexedSeq ->IndexedSeqIterator ->KeySeq ->Keyword ->LazySeq ->List ->Many ->MapEntry ->MetaFn ->MultiFn ->MultiIterator ->Namespace ->NeverEquiv ->NodeIterator ->NodeSeq ->ObjMap ->PersistentArrayMap ->PersistentArrayMapIterator ->PersistentArrayMapSeq ->PersistentHashMap ->PersistentHashSet ->PersistentQueue ->PersistentQueueIter ->PersistentQueueSeq ->PersistentTreeMap ->PersistentTreeMapSeq ->PersistentTreeSet ->PersistentVector ->RSeq ->Range ->RangeIterator ->RangedIterator ->RecordIter ->RedNode ->Reduced ->SeqIter ->Single ->StringBufferWriter ->StringIter ->Subvec ->Symbol ->TaggedLiteral ->TransformerIterator ->TransientArrayMap ->TransientHashMap ->TransientHashSet ->TransientVector ->UUID ->ValSeq ->Var ->VectorNode ->Volatile -add-method -add-watch -as-transient -assoc -assoc! -assoc-n -assoc-n! -chunked-first -chunked-next -chunked-rest -clj->js -clone -comparator -compare -conj -conj! -contains-key? -count -default-dispatch-val -deref -deref-with-timeout -disjoin -disjoin! -dispatch-fn -dissoc -dissoc! -drop-first -empty -entry-key -equiv -find -first -flush -get-method -hash -invoke -iterator -js->clj -key -key->js -kv-reduce -lookup -meta -methods -name -namespace -next -notify-watches -nth -peek -persistent! -pop -pop! -pr-writer -prefer-method -prefers -realized? -reduce -remove-method -remove-watch -reset -reset! -rest -rseq -seq -sorted-seq -sorted-seq-from -swap! -val -vreset! -with-meta -write .. / < <= = == > >= APersistentVector ASeq ArrayChunk ArrayIter ArrayList ArrayNode ArrayNodeIterator ArrayNodeSeq Atom BitmapIndexedNode BlackNode Box CHAR_MAP ChunkBuffer ChunkedCons ChunkedSeq Cons DEMUNGE_MAP DEMUNGE_PATTERN Delay ES6EntriesIterator ES6Iterator ES6IteratorSeq ES6SetEntriesIterator Eduction Empty EmptyList ExceptionInfo Fn HashCollisionNode HashMapIter HashSetIter IAssociative IAtom IChunk IChunkedNext IChunkedSeq ICloneable ICollection IComparable ICounted IDeref IDerefWithTimeout IEditableCollection IEmptyableCollection IEncodeClojure IEncodeJS IEquiv IFind IFn IHash IIndexed IIterable IKVReduce IList ILookup IMap IMapEntry IMeta IMultiFn INIT INamed INext IPending IPrintWithWriter IRecord IReduce IReset IReversible ISeq ISeqable ISequential ISet ISorted IStack ISwap ITER_SYMBOL ITransientAssociative ITransientCollection ITransientMap ITransientSet ITransientVector IUUID IVector IVolatile IWatchable IWithMeta IWriter IndexedSeq IndexedSeqIterator Inst KeySeq Keyword LazySeq List MODULE_INFOS MODULE_URIS Many MapEntry MetaFn MultiFn MultiIterator NS_CACHE Namespace NeverEquiv NodeIterator NodeSeq ObjMap PROTOCOL_SENTINEL PersistentArrayMap PersistentArrayMapIterator PersistentArrayMapSeq PersistentHashMap PersistentHashSet PersistentQueue PersistentQueueIter PersistentQueueSeq PersistentTreeMap PersistentTreeMapSeq PersistentTreeSet PersistentVector RSeq Range RangeIterator RangedIterator RecordIter RedNode Reduced START SeqIter Single StringBufferWriter StringIter Subvec Symbol TaggedLiteral TransformerIterator TransientArrayMap TransientHashMap TransientHashSet TransientVector UUID ValSeq Var VectorNode Volatile aclone add-to-string-hash-cache add-watch aget alength alter-meta! amap ancestors and any? apply apply-to areduce array array-chunk array-index-of array-iter array-list array-map array-seq array? as-> aset assert assoc assoc! assoc-in associative? atom binding bit-and bit-and-not bit-clear bit-count bit-flip bit-not bit-or bit-set bit-shift-left bit-shift-right bit-shift-right-zero-fill bit-test bit-xor boolean boolean? booleans bounded-count butlast byte bytes caching-hash case cat char char? chars chunk chunk-append chunk-buffer chunk-cons chunk-first chunk-next chunk-rest chunked-seq chunked-seq? clj->js clone cloneable? coercive-= coercive-boolean coercive-not coercive-not= coll? comment comp comparator compare compare-and-set! complement completing concat cond cond-> cond->> condp conj conj! cons constantly contains? copy-arguments count counted? create-ns cycle dec declare dedupe default-dispatch-val defmacro defmethod defmulti defn defn- defonce defprotocol defrecord deftype delay delay? demunge deref derive descendants disj disj! dispatch-fn dissoc dissoc! distinct distinct? divide doall dorun doseq dotimes doto double double-array double? doubles drop drop-last drop-while eduction empty empty? enable-console-print! ensure-reduced equiv-map es6-entries-iterator es6-iterable es6-iterator es6-iterator-seq es6-set-entries-iterator even? every-pred every? ex-cause ex-data ex-info ex-message exists? extend-protocol extend-type false? ffirst filter filterv find find-macros-ns find-ns find-ns-obj first fixture1 fixture2 flatten float float? floats flush fn fn? fnext fnil for force frequencies gen-apply-to gen-apply-to-simple gensym gensym_counter get get-in get-method get-validator goog-define group-by halt-when hash hash-combine hash-keyword hash-map hash-ordered-coll hash-set hash-string hash-string* hash-unordered-coll ident? identical? identity if-let if-not if-some ifind? ifn? implements? import import-macros imul inc indexed? infinite? inst-ms inst-ms* inst? instance? int int-array int-rotate-left int? integer? interleave interpose into into-array ints is_proto_ isa? iter iterable? iterate js->clj js-arguments js-comment js-debugger js-delete js-in js-inline-comment js-invoke js-keys js-mod js-obj js-reserved js-str juxt keep keep-indexed key key->js key-test keys keyword keyword-identical? keyword? last lazy-cat lazy-seq let letfn list list* list? load-file load-file* locking long long-array longs loop m3-C1 m3-C2 m3-fmix m3-hash-int m3-hash-unencoded-chars m3-mix-H1 m3-mix-K1 m3-seed macroexpand macroexpand-1 make-array make-hierarchy map map-indexed map? mapcat mapv max max-key memfn memoize merge merge-with meta methods min min-key missing-protocol mix-collection-hash mk-bound-fn mod munge name namespace nat-int? native-satisfies? neg-int? neg? newline next nfirst nil-iter nil? nnext not not-any? not-empty not-every? not-native not= ns-imports ns-interns ns-interns* ns-name ns-publics ns-unmap nth nthnext nthrest number? obj-map object-array object? odd? or parents partial partition partition-all partition-by peek persistent! persistent-array-map-seq pop pop! pos-int? pos? pr pr-seq-writer pr-sequential-writer pr-str pr-str* pr-str-with-opts prefer-method prefers prim-seq print print-map print-meta? print-prefix-map print-str println println-str prn prn-str prn-str-with-opts qualified-ident? qualified-keyword? qualified-symbol? quot rand rand-int rand-nth random-sample random-uuid range ranged-iterator re-find re-matches re-pattern re-seq realized? record? reduce reduce-kv reduceable? reduced reduced? reductions refer-clojure regexp? reify rem remove remove-all-methods remove-method remove-watch repeat repeatedly replace replicate require require-macros reset! reset-meta! reset-vals! resolve rest reverse reversible? rseq rsubseq run! satisfies? second select-keys seq seq-iter seq? seqable? sequence sequential? set set-from-indexed-seq set-print-err-fn! set-print-fn! set-validator! set? short shorts shuffle simple-benchmark simple-ident? simple-keyword? simple-symbol? some some-> some->> some-fn some? sort sort-by sorted-map sorted-map-by sorted-set sorted-set-by sorted? special-symbol? specify specify! split-at split-with spread str string-hash-cache string-hash-cache-count string-iter string-print string? subs subseq subvec swap! swap-vals! symbol symbol-identical? symbol? system-time tagged-literal tagged-literal? take take-last take-nth take-while test this-as time to-array to-array-2d trampoline transduce transformer-iterator transient tree-seq true? truth_ type type->str unchecked-add unchecked-add-int unchecked-byte unchecked-char unchecked-dec unchecked-dec-int unchecked-divide-int unchecked-double unchecked-float unchecked-get unchecked-inc unchecked-inc-int unchecked-int unchecked-long unchecked-multiply unchecked-multiply-int unchecked-negate unchecked-negate-int unchecked-remainder-int unchecked-set unchecked-short unchecked-subtract unchecked-subtract-int undefined? underive unreduced unsafe-bit-and unsafe-cast unsigned-bit-shift-right update update-in uri? use use-macros uuid uuid? val vals var? vary-meta vec vector vector? volatile! volatile? vreset! vswap! when when-first when-let when-not when-some while with-meta with-out-str with-redefs write-all zero? zipmap], :type :cljs, :sym cljs.core} {:var-syms [* + - -> ->> .. / < <= == > >= aget alength amap and areduce array array-map as-> aset assert binding bit-and bit-and-not bit-clear bit-flip bit-not bit-or bit-set bit-shift-left bit-shift-right bit-shift-right-zero-fill bit-test bit-xor bitpos byte caching-hash case coercive-= coercive-boolean coercive-not coercive-not= comment cond cond-> cond->> condp copy-arguments dec declare defmacro defmethod defmulti defn defn- defonce defprotocol defrecord deftype delay destructure divide doseq dotimes doto double dt->et es6-iterable exists? extend-protocol extend-type false? fast-path-protocol-partitions-count fast-path-protocols float fn for gen-apply-to gen-apply-to-simple goog-define hash-map hash-set identical? if-let if-not if-some implements? import inc instance? int js-arguments js-comment js-debugger js-delete js-in js-inline-comment js-mod js-obj js-str keyword? lazy-cat lazy-seq let letfn list load-file* locking loop macroexpand macroexpand-1 make-array mask max memfn min neg? nil? ns-imports ns-interns ns-publics ns-unmap number? or pos? refer-clojure reify require require-macros resolve satisfies? short simple-benchmark some-> some->> some? specify specify! str string? symbol? this-as time true? truth_ unchecked-add unchecked-add-int unchecked-byte unchecked-char unchecked-dec unchecked-dec-int unchecked-divide-int unchecked-double unchecked-float unchecked-get unchecked-inc unchecked-inc-int unchecked-multiply unchecked-multiply-int unchecked-negate unchecked-negate-int unchecked-remainder-int unchecked-set unchecked-short unchecked-subtract unchecked-subtract-int undefined? unsafe-bit-and unsafe-cast unsigned-bit-shift-right use use-macros vector vswap! when when-first when-let when-not when-some while with-out-str with-redefs zero?], :type :cljs, :sym cljs.core$macros} {:var-syms [<! >! Mix Mult Mux Pub admix admix* alts! buffer chan close! do-alts dropping-buffer filter< filter> into ioc-alts! map map< map> mapcat< mapcat> merge mix mult muxch* offer! onto-chan partition partition-by pipe pipeline pipeline-async poll! promise-chan pub put! reduce remove< remove> sliding-buffer solo-mode solo-mode* split sub sub* take take! tap tap* timeout to-chan toggle toggle* transduce unblocking-buffer? unique unmix unmix* unmix-all unmix-all* unsub unsub* unsub-all unsub-all* untap untap* untap-all untap-all*], :type :cljs, :sym cljs.core.async} {:var-syms [->DroppingBuffer ->FixedBuffer ->PromiseBuffer ->RingBuffer ->SlidingBuffer DroppingBuffer FixedBuffer PromiseBuffer RingBuffer SlidingBuffer acopy dropping-buffer fixed-buffer promise-buffer ring-buffer sliding-buffer], :type :cljs, :sym cljs.core.async.impl.buffers} {:var-syms [->ManyToManyChannel ->PutBox MAX_DIRTY MMC ManyToManyChannel PutBox abort box chan put-active?], :type :cljs, :sym cljs.core.async.impl.channels} {:var-syms [TASK_BATCH_SIZE process-messages queue-delay queue-dispatcher queued? run running? tasks], :type :cljs, :sym cljs.core.async.impl.dispatch} {:var-syms [->ExceptionFrame BINDINGS-IDX CURRENT-EXCEPTION EXCEPTION-FRAMES ExceptionFrame FN-IDX STATE-IDX USER-START-IDX VALUE-IDX add-exception-frame aget-object aset-object finished? map->ExceptionFrame process-exception put! return-chan run-state-machine run-state-machine-wrapped take!], :type :cljs, :sym cljs.core.async.impl.ioc-helpers} {:var-syms [index-state-machine fixup-aliases EXCEPTION-FRAMES block-references reads-from index-block ->Try ->ProcessExceptionWithValue map->Case add-block instruction? expand let-binding-to-ssa map->CondBr map->Const ->Call ->Jmp ->CondBr ->EndCatchFinally count-persistent-values get-binding gen-plan -item-to-ssa ->Case get-block id-for-inst index-instruction writes-to ->Dot map->EndCatchFinally map->CustomTerminator terminator-code set-block STATE-IDX sexpr-to-ssa ->Fn ->Return IEmittableInstruction map->Call ITerminator map->Fn special-override? default-sexpr map->ProcessExceptionWithValue emit-instruction IInstruction map->Dot terminate-block persistent-value? ->Set! assoc-in-plan push-alter-binding aset-all! debug parse-to-state-machine get-plan FN-IDX all pop-binding ->Recur add-instruction no-op push-binding ->CustomTerminator BINDINGS-IDX map->Return item-to-ssa terminate-custom map->Try async-custom-terminators is-special? CURRENT-EXCEPTION ->Const print-plan map->Set! get-in-plan update-in-plan map->Recur map->Jmp USER-START-IDX state-machine VALUE-IDX], :type :clj, :sym cljs.core.async.impl.ioc-macros} {:var-syms [aset-all! gen-plan], :type :cljs, :sym cljs.core.async.impl.ioc-macros} {:var-syms [Buffer Channel Handler MAX-QUEUE-SIZE ReadPort UnblockingBuffer WritePort active? add! add!* blockable? close! close-buf! closed? commit full? put! remove! take!], :type :cljs, :sym cljs.core.async.impl.protocols} {:var-syms [->SkipList ->SkipListNode MAX_LEVEL P SkipList SkipListNode TIMEOUT_RESOLUTION_MS least-greater-node random-level skip-list skip-list-node timeout timeouts-map], :type :cljs, :sym cljs.core.async.impl.timers} {:var-syms [go alt! go-loop do-alt], :type :clj, :sym cljs.core.async.macros} {:var-syms [alt! go go-loop], :type :cljs, :sym cljs.core.async.macros} {:var-syms [ensure with-compiler-env default-compiler-env *compiler*], :type :clj, :sym cljs.env} {:var-syms [*compiler* default-compiler-env], :type :cljs, :sym cljs.env} {:var-syms [ensure with-compiler-env], :type :clj, :sym cljs.env.macros} {:var-syms [ensure with-compiler-env], :type :cljs, :sym cljs.env.macros} {:var-syms [parse-extern-node get-type parse-externs externs-map annotate index-externs get-type*], :type :clj, :sym cljs.externs} {:var-syms [with-state dump-core], :type :clj, :sym cljs.js} {:var-syms [*eval-fn* *load-fn* *loaded* analyze-str compile-str dump-core empty-state eval eval-str file->ns js-eval load-analysis-cache! load-source-map! ns->relpath require with-state], :type :cljs, :sym cljs.js} {:var-syms [zip-file goog-dependencies load-foreign-library find-js-jar find-js-fs find-js-resources to-url -requires build-index jar-entry-names find-js-classpath goog-dependencies* -provides native-node-modules IJavaScript -source lib-spec-merge dependency-order-visit js-dependency-index -relative-path load-foreign-library* load-library -url find-url -foreign? get-file load-library* jar-entry-names* -closure-lib? library-dependencies find-classpath-lib parse-js-ns dependency-order], :type :clj, :sym cljs.js-deps} {:var-syms [add-cljs-base-dep deps-for-module normalize index-inputs sort-modules inputs->assigned-modules add-cljs-base parent? deps-for annotate-depths depth-of module-for modules->module-uris validate-modules deps-for-entry canonical-name deepest-common-parent expand-modules maybe-add-out-file topo-sort modules->module-infos find-sources-for-module-entry], :type :clj, :sym cljs.module-graph} {:var-syms [add-data-readers], :type :clj, :sym cljs.reader} {:var-syms [*default-data-reader-fn* *tag-table* add-data-readers deregister-default-tag-parser! deregister-tag-parser! parse-and-validate-timestamp parse-timestamp read read-string register-default-tag-parser! register-tag-parser!], :type :cljs, :sym cljs.reader} {:var-syms [update-result encode invert-reverse-map relativize-path decode seg->map source-compare decode-reverse lines->segs merge-source-maps update-reverse-result indexed-sources encode* seg-combine], :type :clj, :sym cljs.source-map} {:var-syms [decode decode-reverse encode indexed-sources invert-reverse-map lines->segs merge-source-maps seg->map seg-combine source-compare update-result update-reverse-result], :type :cljs, :sym cljs.source-map} {:var-syms [chars64 encode int->char decode char->int], :type :clj, :sym cljs.source-map.base64} {:var-syms [char->int chars64 decode encode int->char], :type :cljs, :sym cljs.source-map.base64} {:var-syms [encode-val encode vlq-continuation-bit vlq-base-mask bit-shift-right-zero-fill decode vlq-base-shift from-vlq-signed to-vlq-signed vlq-base], :type :clj, :sym cljs.source-map.base64-vlq} {:var-syms [decode encode encode-val from-vlq-signed to-vlq-signed vlq-base vlq-base-mask vlq-base-shift vlq-continuation-bit], :type :cljs, :sym cljs.source-map.base64-vlq} {:var-syms [& fspec every keys* speced-vars registry-ref nilable coll-of cat * every-kv int-in alt or exercise-fn multi-spec tuple assert ? merge conformer spec keys + map-of double-in inst-in and def fdef], :type :clj, :sym cljs.spec.alpha} {:var-syms [& * *coll-check-limit* *coll-error-limit* *compile-asserts* *explain-out* *fspec-iterations* *recursion-limit* + ? MAX_INT Spec Specize abbrev alt alt-impl amp-impl and and-spec-impl assert assert* cat cat-impl check-asserts check-asserts? coll-of conform conform* conformer def def-impl describe describe* double-in every every-impl every-kv exercise exercise-fn explain explain* explain-data explain-data* explain-out explain-printer explain-str fdef form fspec fspec-impl gen gen* get-spec inst-in inst-in-range? int-in int-in-range? invalid? keys keys* map-of map-spec map-spec-impl maybe-impl merge merge-spec-impl multi-spec multi-spec-impl nilable nilable-impl nonconforming or or-spec-impl regex-spec-impl regex? registry rep+impl rep-impl spec spec-impl spec? specize* tuple tuple-impl unform unform* valid? with-gen with-gen*], :type :cljs, :sym cljs.spec.alpha} {:var-syms [lazy-prim delay lazy-prims dynaload lazy-combinators lazy-combinator], :type :clj, :sym cljs.spec.gen.alpha} {:var-syms [->LazyVar LazyVar any any-printable bind boolean cat char char-alpha char-alphanumeric char-ascii choose delay delay-impl double double* dynaload elements fmap for-all* frequency gen-for-pred generate hash-map int keyword keyword-ns large-integer large-integer* lazy-combinator lazy-combinators lazy-prim lazy-prims list map not-empty one-of quick-check ratio return sample set simple-type simple-type-printable string string-alphanumeric string-ascii such-that symbol symbol-ns tuple uuid vector vector-distinct], :type :cljs, :sym cljs.spec.gen.alpha} {:var-syms [assert-args], :type :clj, :sym cljs.support} {:var-syms [assert-args], :type :cljs, :sym cljs.support} {:var-syms [read-uuid valid-js-literal-key? read-inst read-queue *cljs-data-readers* ->JSValue read-js], :type :clj, :sym cljs.tagged-literals} {:var-syms [*cljs-data-readers* ->JSValue JSValue read-inst read-js read-queue read-uuid valid-js-literal-key?], :type :cljs, :sym cljs.tagged-literals} {:var-syms [*alias-map* *data-readers* *default-data-reader-fn* *read-delim* *suppress-read* bool? default-data-readers map-func read read-regex read-string resolve-symbol sb], :type :cljs, :sym cljs.tools.reader} {:var-syms [read read-string], :type :cljs, :sym cljs.tools.reader.edn} {:var-syms [float-pattern int-pattern match-number matches? number-literal? parse-symbol ratio-pattern read-comment read-past skip-line throwing-reader], :type :cljs, :sym cljs.tools.reader.impl.commons} {:var-syms [eof-error illegal-arg-error reader-error throw-bad-char throw-bad-dispatch throw-bad-escape-char throw-bad-metadata throw-bad-metadata-target throw-bad-ns throw-bad-octal-number throw-bad-reader-tag throw-dup-keys throw-eof-at-dispatch throw-eof-at-start throw-eof-delimited throw-eof-error throw-eof-in-character throw-eof-reading throw-feature-not-keyword throw-invalid throw-invalid-character-literal throw-invalid-number throw-invalid-octal-len throw-invalid-unicode-char throw-invalid-unicode-digit throw-invalid-unicode-digit-in-token throw-invalid-unicode-escape throw-invalid-unicode-len throw-invalid-unicode-literal throw-no-dispatch throw-ns-map-no-map throw-odd-map throw-single-colon throw-unknown-reader-tag throw-unmatch-delimiter throw-unsupported-character], :type :cljs, :sym cljs.tools.reader.impl.errors} {:var-syms [inspect inspect*], :type :cljs, :sym cljs.tools.reader.impl.inspect} {:var-syms [->ReaderConditional ReaderConditional char desugar-meta ex-info? last-id map->ReaderConditional namespace-keys newline? next-id numeric? reader-conditional reader-conditional? second' whitespace? ws-rx], :type :cljs, :sym cljs.tools.reader.impl.utils} {:var-syms [log-source], :type :clj, :sym cljs.tools.reader.reader-types} {:var-syms [->IndexingPushbackReader ->NodeReadableReader ->PushbackReader ->SourceLoggingPushbackReader ->StringReader IPushbackReader IndexingPushbackReader IndexingReader NodeReadableReader PushbackReader Reader SourceLoggingPushbackReader StringReader get-column-number get-file-name get-line-number indexing-push-back-reader indexing-reader? line-start? log-source log-source* merge-meta node-readable-push-back-reader peek-char read-char read-line source-logging-push-back-reader source-logging-reader? string-push-back-reader string-reader unread], :type :cljs, :sym cljs.tools.reader.reader-types} {:var-syms [output-directory windows? *clojurescript-version* boolean? file-or-resource distinct-by path normalize-path clojurescript-version ext content-sha valid-js-id-start? ns->relpath get-name debug-prn-mutex map-merge to-target-file mkdirs compile-if url? module-file-seq conjunction-str suggestion path-seq compiled-by-version measure ns->source last-modified debug-prn file? unknown-opts levenshtein-distance filename to-path topo-sort munge-path build-options changed? relative-name], :type :clj, :sym cljs.util} {:var-syms [IEventType all-listeners dispatch-event event-types expose fire-listeners get-listener has-listener listen listen-once remove-all total-listener-count unique-event-id unlisten unlisten-by-key], :type :cljs, :sym clojure.browser.event} {:var-syms [*timeout* IConnection ICrossPageChannel IWebSocket close connect event-types open? register-service transmit websocket-connection xhr-connection xpc-config-fields xpc-connection], :type :cljs, :sym clojure.browser.net} {:var-syms [primitives-classnames +' decimal? restart-agent sort-by macroexpand ensure chunk-first eduction tree-seq unchecked-remainder-int seq reduce when-first find-ns get-thread-bindings contains? every? proxy-mappings keep-indexed cond->> subs ref-min-history set take-last bit-set reader-conditional gen-class qualified-keyword? while ->Eduction butlast satisfies? line-seq unchecked-subtract-int *print-namespace-maps* take-nth first re-groups seq? dec' ns-unmap println-str with-bindings* inst-ms iterator-seq iterate slurp newline short-array fn? doall prefers enumeration-seq dedupe dissoc atom import bit-shift-right print-method peek aget pvalues bound-fn vswap! last pr namespace push-thread-bindings bases = dosync remove-ns take vector? thread-bound? send-via boolean bit-shift-left any? find-var rand-int aclone vreset! chunk dec future-call resultset-seq struct map juxt ns-publics < *source-path* with-loading-context test rest ex-data compile isa? boolean? .. munge delay set-error-mode! re-seq char? make-hierarchy set-agent-send-executor! swap-vals! keep char mapcat unchecked-long aset-long some? unchecked-negate gen-interface *command-line-args* reverse inst? range sort -cache-protocol-fn unchecked-inc-int map-indexed with-bindings rand-nth comp await spit future-done? *read-eval* dorun simple-symbol? disj *2 eval cons refer print-dup -reset-methods floats pos? fnil merge-with nthrest load if-not *verbose-defrecords* sequential? *print-level* shuffle boolean-array find alength bit-xor deliver doseq unsigned-bit-shift-right neg? var-set unchecked-float pmap error-mode num reduced? disj! float? aset-float deftype bean booleans ns-unalias when-let int-array set? inc' cat StackTraceElement->vec *suppress-read* flush take-while vary-meta <= alter -' if-some conj! repeatedly zipmap reset-vals! alter-var-root biginteger remove * re-pattern min pop! chunk-append prn-str with-precision format reversible? shutdown-agents conj bound? transduce lazy-seq *print-length* *file* compare-and-set! *use-context-classloader* await1 let ref-set pop-thread-bindings interleave printf map? -> defstruct *err* get doto identity into areduce long double volatile? definline nfirst meta find-protocol-impl bit-and-not *default-data-reader-fn* var? method-sig unchecked-add-int unquote-splicing hash-ordered-coll future reset-meta! cycle fn seque empty? short definterface filterv hash quot ns-aliases read unchecked-double key longs not= string? uri? aset-double unchecked-multiply-int chunk-rest pcalls *allow-unresolved-vars* remove-all-methods ns-resolve as-> aset-boolean trampoline double? when-not *1 vec *print-meta* when int map-entry? ns-refers rand second vector-of hash-combine > replace int? associative? unchecked-int set-error-handler! inst-ms* keyword? force bound-fn* namespace-munge group-by prn extend unchecked-multiply some->> default-data-readers ->VecSeq even? unchecked-dec Inst tagged-literal? double-array in-ns create-ns re-matcher defn ref bigint extends? promise aset-char rseq construct-proxy agent-errors *compile-files* *math-context* float pr-str concat aset-short set-agent-send-off-executor! ns symbol to-array-2d mod amap pop use unquote declare dissoc! reductions aset-byte indexed? ref-history-count - assoc! hash-set reduce-kv or cast reset! name ffirst sorted-set counted? byte-array tagged-literal println extend-type macroexpand-1 assoc-in char-name-string bit-test defmethod EMPTY-NODE time memoize alter-meta! future? zero? simple-keyword? require unchecked-dec-int persistent! nnext add-watch not-every? class? rem agent-error some future-cancelled? memfn neg-int? struct-map drop *data-readers* nth sorted? nil? extend-protocol split-at *e load-reader random-sample cond-> dotimes select-keys bit-and bounded-count update list* reify update-in prefer-method aset-int *clojure-version* ensure-reduced *' instance? with-open mix-collection-hash re-find run! val defonce unchecked-add loaded-libs ->Vec bytes? not with-meta unreduced the-ns record? type identical? unchecked-divide-int ns-name max-key *unchecked-math* defn- *out* file-seq agent ns-map set-validator! ident? defprotocol swap! vals unchecked-subtract *warn-on-reflection* sorted-set-by sync qualified-ident? assert *compile-path* true? release-pending-sends print empty remove-method *in* print-ctor letfn volatile! / read-line reader-conditional? bit-or clear-agent-errors vector proxy-super >= drop-last not-empty distinct partition loop add-classpath bit-flip long-array descendants merge accessor integer? mapv partition-all partition-by numerator object-array with-out-str condp derive load-string special-symbol? ancestors subseq error-handler gensym cond ratio? delay? intern print-simple flatten doubles halt-when with-in-str remove-watch ex-info ifn? some-> nat-int? proxy-name ns-interns all-ns find-protocol-method subvec for binding partial chunked-seq? find-keyword replicate min-key reduced char-escape-string re-matches array-map unchecked-byte with-local-vars ns-imports send-off defmacro every-pred keys rationalize load-file distinct? pos-int? extenders unchecked-short methods odd? ->ArrayChunk float-array *3 alias frequencies read-string proxy rsubseq inc get-method with-redefs uuid? bit-clear filter locking list + split-with aset ->VecNode keyword *ns* destructure *assert* defmulti chars str next hash-map if-let underive ref-max-history Throwable->map false? *print-readably* ints class some-fn case *flush-on-newline* to-array bigdec list? simple-ident? bit-not io! xml-seq byte max == *agent* lazy-cat comment parents count supers *fn-loader* sorted-map-by apply interpose deref assoc rational? transient clojure-version chunk-cons comparator sorted-map send drop-while proxy-call-with-super realized? char-array resolve compare complement *compiler-options* *print-dup* defrecord with-redefs-fn sequence constantly get-proxy-class make-array shorts completing update-proxy unchecked-negate-int hash-unordered-coll repeat unchecked-inc *reader-resolver* nthnext and create-struct get-validator number? await-for chunk-next print-str not-any? into-array qualified-symbol? init-proxy chunk-buffer seqable? symbol? when-some unchecked-char ->> future-cancel var-get commute coll? get-in fnext denominator bytes refer-clojure], :type :clj, :sym clojure.core} {:var-syms [Pub reduce remove> timeout unsub* admix* unmix* mix pub take unsub-all* <! map Mux mapcat> buffer close! offer! chan solo-mode* tap go admix promise-chan unique muxch* solo-mode transduce onto-chan to-chan dropping-buffer untap-all into >!! alt! pipeline sub go-loop map> pipe unmix filter< sub* remove< alt!! untap* <!! toggle untap-all* sliding-buffer partition Mult merge partition-by unsub-all >! unmix-all* split unmix-all filter> tap* untap alts! unsub poll! thread map< fn-handler do-alts pipeline-blocking pipeline-async Mix toggle* mult thread-call alts!! mapcat< ioc-alts! unblocking-buffer? do-alt put! take!], :type :clj, :sym clojure.core.async} {:var-syms [->PromiseBuffer ->DroppingBuffer dropping-buffer fixed-buffer ->FixedBuffer sliding-buffer ->SlidingBuffer promise-buffer], :type :clj, :sym clojure.core.async.impl.buffers} {:var-syms [cleanup chan box MMC abort assert-unlock ->ManyToManyChannel], :type :clj, :sym clojure.core.async.impl.channels} {:var-syms [counted-thread-factory processors], :type :clj, :sym clojure.core.async.impl.concurrent} {:var-syms [executor run], :type :clj, :sym clojure.core.async.impl.dispatch} {:var-syms [thread-pool-executor], :type :clj, :sym clojure.core.async.impl.exec.threadpool} {:var-syms [index-state-machine ->PopTry EXCEPTION-FRAMES block-references reads-from index-block map->Case map->InstanceInterop add-block instruction? ->RawCode let-binding-to-ssa map->CondBr map->Const ->Call ->Jmp ->CondBr map->PushTry count-persistent-values get-binding gen-plan -item-to-ssa ->Case get-block id-for-inst index-instruction pdebug writes-to ->Dot map->CustomTerminator terminator-code set-block ->CatchHandler STATE-IDX ->PushTry mark-transitions ->Fn map->CatchHandler ->Return aset-object run-passes IEmittableInstruction map->Call ITerminator map->Fn emit-instruction IInstruction map->Dot make-env propagate-recur terminate-block ->InstanceInterop map->PopTry persistent-value? propagate-transitions assoc-in-plan run-state-machine-wrapped push-alter-binding aset-all! debug parse-to-state-machine get-plan FN-IDX aget-object return-chan all pop-binding ->EndFinally nested-go? ->Recur add-instruction no-op passes push-binding ->CustomTerminator BINDINGS-IDX map->Return item-to-ssa map->EndFinally async-custom-terminators ->StaticCall map->RawCode CURRENT-EXCEPTION emit-hinted ->Const map->StaticCall print-plan run-state-machine get-in-plan update-in-plan map->Recur map->Jmp finished? USER-START-IDX put! take! var-name state-machine VALUE-IDX], :type :clj, :sym clojure.core.async.impl.ioc-macros} {:var-syms [mutex], :type :clj, :sym clojure.core.async.impl.mutex} {:var-syms [remove! close-buf! close! Handler blockable? active? Buffer full? add! lock-id exec Executor add!* ReadPort Channel closed? UnblockingBuffer MAX-QUEUE-SIZE commit put! take! WritePort], :type :clj, :sym clojure.core.async.impl.protocols} {:var-syms [->TimeoutQueueEntry timeout timeout-daemon TIMEOUT_RESOLUTION_MS], :type :clj, :sym clojure.core.async.impl.timers} {:var-syms [defcache clear-soft-cache! make-reference ->FnCache ->SoftCache soft-cache-factory ->TTLCache has? evict miss lookup hit through ttl-cache-factory lu-cache-factory ->LIRSCache ->LRUCache ->BasicCache lirs-cache-factory basic-cache-factory CacheProtocol seed fifo-cache-factory ->FIFOCache ->LUCache lru-cache-factory], :type :clj, :sym clojure.core.cache} {:var-syms [memo-ttl ->PluggableMemoization memo memoized? lu fifo memo-unwrap through* memo-fifo memo-swap! ->RetryingDelay lru build-memoizer snapshot ttl memo-lu memo-clear! memo-lru], :type :clj, :sym clojure.core.memoize} {:var-syms [IKVReduce CollReduce coll-reduce internal-reduce InternalReduce kv-reduce], :type :clj, :sym clojure.core.protocols} {:var-syms [stop-server repl-init start-server start-servers stop-servers repl-read *session* repl], :type :clj, :sym clojure.core.server} {:var-syms [diff equality-partition EqualityPartition diff-similar Diff], :type :clj, :sym clojure.data} {:var-syms [pprint -write read-json read-str read json-str write-str pprint-json JSONWriter write write-json print-json], :type :clj, :sym clojure.data.json} {:var-syms [->PersistentPriorityMap priority-map-by apply-keyfn priority-map-keyfn priority-map-keyfn-by priority-map], :type :clj, :sym clojure.data.priority-map} {:var-syms [read read-string], :type :clj, :sym clojure.edn} {:var-syms [validated read-instant-timestamp read-instant-calendar read-instant-date parse-timestamp], :type :clj, :sym clojure.instant} {:var-syms [URLClasspath classpath urls get-urls classpath-directories classpath-jarfiles jar-file? filenames-in-jar loader-classpath system-classpath], :type :clj, :sym clojure.java.classpath} {:var-syms [default-streams-impl make-output-stream make-parents delete-file input-stream make-writer as-relative-path copy as-file output-stream make-reader Coercions file make-input-stream IOFactory resource writer as-url reader], :type :clj, :sym clojure.java.io} {:var-syms [sh *sh-dir* with-sh-dir *sh-env* with-sh-env], :type :clj, :sym clojure.java.shell} {:var-syms [main with-bindings stack-element-str repl-caught repl-exception repl-read load-script skip-if-eol skip-whitespace root-cause repl-requires demunge with-read-known repl repl-prompt], :type :clj, :sym clojure.main} {:var-syms [pprint simple-dispatch get-pretty-writer *print-suppress-namespaces* *print-pretty* *print-pprint-dispatch* pprint-newline code-dispatch print-length-loop pprint-tab pprint-logical-block print-table pp set-pprint-dispatch fresh-line formatter-out formatter pprint-indent *print-radix* cl-format *print-miser-width* write *print-right-margin* write-out with-pprint-dispatch *print-base*], :type :clj, :sym clojure.pprint} {:var-syms [->Field ->Method TypeReference reflect map->Field map->Method typename ->JavaReflector ->AsmReflector resolve-class flag-descriptors do-reflect ClassResolver Reflector ->Constructor map->Constructor type-reflect], :type :clj, :sym clojure.reflect} {:var-syms [source-fn doc stack-element-str find-doc dir pst dir-fn source set-break-handler! root-cause demunge thread-stopper apropos], :type :clj, :sym clojure.repl} {:var-syms [union map-invert join select intersection superset? index subset? rename rename-keys project difference], :type :clj, :sym clojure.set} {:var-syms [difference index intersection join map-invert project rename rename-keys select subset? superset? union], :type :cljs, :sym clojure.set} {:var-syms [form & nilable-impl *recursion-limit* *coll-error-limit* fspec explain-printer Specize every keys* alt-impl def-impl *explain-out* regex-spec-impl merge-spec-impl explain-data* check-asserts assert* inst-in-range? nilable and-spec-impl describe* map-spec-impl coll-of cat * explain with-gen* or-spec-impl *fspec-iterations* Spec unform valid? gen every-kv int-in alt nonconforming unform* abbrev regex? int-in-range? or spec? registry rep+impl exercise-fn exercise multi-spec explain-data tuple-impl multi-spec-impl tuple conform gen* fspec-impl assert ? *coll-check-limit* merge get-spec conformer every-impl spec keys spec-impl + invalid? amp-impl map-of cat-impl explain-str *compile-asserts* with-gen conform* check-asserts? rep-impl double-in inst-in describe explain-out and specize* def maybe-impl explain* fdef], :type :clj, :sym clojure.spec.alpha} {:var-syms [uuid gen-for-pred lazy-prim set one-of any-printable vector-distinct boolean string-alphanumeric map delay simple-type char bind symbol-ns any lazy-prims cat double char-alpha int return gen-for-name symbol quick-check char-alphanumeric choose for-all* string-ascii frequency double* generate delay-impl lazy-combinators tuple string vector large-integer keyword-ns not-empty elements sample list large-integer* keyword hash-map ratio such-that fmap char-ascii simple-type-printable lazy-combinator bytes], :type :clj, :sym clojure.spec.gen.alpha} {:var-syms [check-fn summarize-results instrumentable-syms instrument unstrument ->sym check with-instrument-disabled checkable-syms enumerate-namespace abbrev-result], :type :clj, :sym clojure.spec.test.alpha} {:var-syms [print-stack-trace print-trace-element print-cause-trace e root-cause print-throwable], :type :clj, :sym clojure.stacktrace} {:var-syms [ends-with? capitalize reverse join replace-first starts-with? escape last-index-of re-quote-replacement includes? replace split-lines lower-case trim-newline upper-case split trimr index-of trim triml blank?], :type :clj, :sym clojure.string} {:var-syms [blank? capitalize ends-with? escape includes? index-of join last-index-of lower-case replace replace-first reverse split split-lines starts-with? trim trim-newline triml trimr upper-case], :type :cljs, :sym clojure.string} {:var-syms [macroexpand valid-binding-symbol? analyze-let analyze-map parse-def parse-quote parse-new analyze-fn-method parse-invoke analyze parse-dot parse-do analyze-const parse-loop* analyze-vector var? parse-if -analyze-form create-var parse-try analyze-symbol macroexpand-1 analyze-body parse-letfn* parse-catch analyze-seq parse-recur empty-env analyze-in-env parse-fn* validate-bindings parse-let* parse-throw analyze-set -parse parse wrapping-meta parse-set! specials analyze-form parse-var], :type :clj, :sym clojure.tools.analyzer} {:var-syms [update-children postwalk children walk prewalk children* cycling ast->eav update-children-reduced nodes], :type :clj, :sym clojure.tools.analyzer.ast} {:var-syms [ensure deref-env *env* with-env], :type :clj, :sym clojure.tools.analyzer.env} {:var-syms [analyze-ns parse-case* global-env analyze qualify-arglists parse-reify* analyze+eval analyze-method-impls desugar-symbol create-var run-passes parse-monitor-enter parse-import* build-ns-map macroexpand-1 desugar-host-expr parse-deftype* parse-opts+methods -deftype default-passes empty-env update-ns-map! macroexpand-all scheduled-default-passes parse default-passes-opts parse-monitor-exit specials ->ExceptionThrown], :type :clj, :sym clojure.tools.analyzer.jvm} {:var-syms [unbox static-methods members special-arrays static-field primitive? instance-methods numeric? instance-method static-members wider-tag static-method wider-primitive prim-or-obj ns->relpath try-best-match maybe-class instance-members maybe-class-from-string box array-class ns-url members* subsumes? wider-tag* name-matches? convertible? instance-field prim-interface inline? tag-match? maybe-class-literal specials macro? wider-than object-members], :type :clj, :sym clojure.tools.analyzer.jvm.utils} {:var-syms [schedule-passes satisfies-affected? schedule group compile-passes schedule* calculate-deps desugar-deps maybe-looping-pass collapse], :type :clj, :sym clojure.tools.analyzer.passes} {:var-syms [add-binding-atom], :type :clj, :sym clojure.tools.analyzer.passes.add-binding-atom} {:var-syms [cleanup], :type :clj, :sym clojure.tools.analyzer.passes.cleanup} {:var-syms [constant-lift], :type :clj, :sym clojure.tools.analyzer.passes.constant-lifter} {:var-syms [elides elide-meta replace-meta get-elides -elide-meta], :type :clj, :sym clojure.tools.analyzer.passes.elide-meta} {:var-syms [emit-bindings -emit-form emit-form -emit-form* emit-hygienic-form], :type :clj, :sym clojure.tools.analyzer.passes.emit-form} {:var-syms [-analyze-host-expr analyze-host-expr maybe-static-field maybe-instance-method analyze-host-call maybe-instance-field analyze-host-field maybe-static-method], :type :clj, :sym clojure.tools.analyzer.passes.jvm.analyze-host-expr} {:var-syms [annotate-host-info], :type :clj, :sym clojure.tools.analyzer.passes.jvm.annotate-host-info} {:var-syms [annotate-loops check-recur -check-recur -loops], :type :clj, :sym clojure.tools.analyzer.passes.jvm.annotate-loops} {:var-syms [-annotate-tag annotate-tag], :type :clj, :sym clojure.tools.analyzer.passes.jvm.annotate-tag} {:var-syms [if-let-box boxed? -box box], :type :clj, :sym clojure.tools.analyzer.passes.jvm.box} {:var-syms [classify-invoke], :type :clj, :sym clojure.tools.analyzer.passes.jvm.classify-invoke} {:var-syms [constant-lift constant-lift*], :type :clj, :sym clojure.tools.analyzer.passes.jvm.constant-lifter} {:var-syms [-emit-form emit-form -emit-form* class->str emit-hygienic-form class->sym], :type :clj, :sym clojure.tools.analyzer.passes.jvm.emit-form} {:var-syms [fix-case-test], :type :clj, :sym clojure.tools.analyzer.passes.jvm.fix-case-test} {:var-syms [-infer-tag infer-tag =-arglists?], :type :clj, :sym clojure.tools.analyzer.passes.jvm.infer-tag} {:var-syms [validate-tag validate-call validate validate-interfaces -validate], :type :clj, :sym clojure.tools.analyzer.passes.jvm.validate} {:var-syms [find-mismatches dirty -validate-loop-locals validate-loop-locals -validate-loop-locals* -cleanup-dirty-nodes], :type :clj, :sym clojure.tools.analyzer.passes.jvm.validate-loop-locals} {:var-syms [validate-recur], :type :clj, :sym clojure.tools.analyzer.passes.jvm.validate-recur} {:var-syms [warn-on-reflection warn], :type :clj, :sym clojure.tools.analyzer.passes.jvm.warn-on-reflection} {:var-syms [-merge-source-info source-info], :type :clj, :sym clojure.tools.analyzer.passes.source-info} {:var-syms [preserving-raw-forms trim -trim], :type :clj, :sym clojure.tools.analyzer.passes.trim} {:var-syms [normalize uniquify-locals* -uniquify-locals *locals-frame* uniquify-binding *locals-counter* uniquify-locals-around uniquify-locals uniquify], :type :clj, :sym clojure.tools.analyzer.passes.uniquify} {:var-syms [warn-earmuff], :type :clj, :sym clojure.tools.analyzer.passes.warn-earmuff} {:var-syms [type? ctx boolean? mapv' rseqv protocol-node? select-keys' -source-info classify reference? update-vals resolve-sym private? constant? regex? dynamic? compile-if into! const-val dissoc-env update-kv record? butlast+last obj? source-info mmerge resolve-ns update-keys arglist-for-arity macro? merge'], :type :clj, :sym clojure.tools.analyzer.utils} {:var-syms [immediate-dependencies remove-edge depends? depend immediate-dependents set-conj remove-node ->MapDependencyGraph transitive-dependents-set topo-comparator transitive-dependencies map->MapDependencyGraph DependencyGraph topo-sort transitive-dependents nodes graph DependencyGraphUpdate remove-all dependent? transitive-dependencies-set], :type :clj, :sym clojure.tools.namespace.dependency} {:var-syms [clojurescript-file? add-files file-with-extension? remove-files clojure-extensions clojurescript-extensions read-file-ns-decl clojure-file?], :type :clj, :sym clojure.tools.namespace.file} {:var-syms [find-namespaces-in-jarfile clj cljs find-namespaces-in-dir sources-in-jar find-ns-decls-in-jarfile find-sources-in-dir read-ns-decl-from-jarfile-entry find-ns-decls find-clojure-sources-in-dir clojure-sources-in-jar find-namespaces find-ns-decls-in-dir], :type :clj, :sym clojure.tools.namespace.find} {:var-syms [ns-decl? name-from-ns-decl deps-from-ns-decl cljs-read-opts clj-read-opts read-ns-decl comment?], :type :clj, :sym clojure.tools.namespace.parse} {:var-syms [add tracker remove], :type :clj, :sym clojure.tools.namespace.track} {:var-syms [*read-eval* *suppress-read* *default-data-reader-fn* read read-symbol default-data-readers *data-readers* *read-delim* resolve-symbol *alias-map* read-regex syntax-quote read-string map-func], :type :clj, :sym clojure.tools.reader} {:var-syms [default-uuid-reader validated read-instant-timestamp read-instant-calendar read-instant-date parse-timestamp], :type :clj, :sym clojure.tools.reader.default-data-readers} {:var-syms [match-number skip-line int-pattern read-comment parse-symbol number-literal? read-past float-pattern throwing-reader ratio-pattern], :type :clj, :sym clojure.tools.reader.impl.commons} {:var-syms [throw-bad-dispatch throw-invalid-unicode-escape throw-bad-ns throw-unknown-reader-tag throw-eof-at-dispatch throw-bad-metadata-target throw-invalid-number reader-error throw-invalid-unicode-literal throw-ns-map-no-map throw-unsupported-character throw-feature-not-keyword throw-eof-delimited throw-eof-in-character throw-bad-char eof-error throw-bad-metadata throw-eof-reading throw-eof-error illegal-arg-error throw-invalid-octal-len throw-invalid-unicode-digit throw-invalid-unicode-digit-in-token throw-invalid-unicode-len throw-single-colon throw-odd-map throw-bad-octal-number throw-bad-reader-tag throw-unmatch-delimiter throw-invalid-character-literal throw-invalid-unicode-char throw-bad-escape-char throw-no-dispatch throw-eof-at-start throw-invalid], :type :clj, :sym clojure.tools.reader.impl.errors} {:var-syms [inspect inspect*], :type :clj, :sym clojure.tools.reader.impl.inspect} {:var-syms [whitespace? char numeric? make-var second' desugar-meta <=clojure-1-7-alpha5 ex-info? newline? namespace-keys compile-when], :type :clj, :sym clojure.tools.reader.impl.utils} {:var-syms [ReaderCoercer indexing-push-back-reader log-source* merge-meta ->StringReader to-pbr to-rdr Reader source-logging-push-back-reader unread peek-char push-back-reader IPushbackReader indexing-reader? string-reader read-char get-column-number get-file-name read-line ->PushbackReader PushbackReaderCoercer string-push-back-reader log-source ->SourceLoggingPushbackReader ->InputStreamReader line-start? input-stream-push-back-reader source-logging-reader? IndexingReader get-line-number input-stream-reader ->IndexingPushbackReader], :type :clj, :sym clojure.tools.reader.reader-types} {:var-syms [postwalk keywordize-keys walk prewalk-replace stringify-keys prewalk postwalk-demo prewalk-demo macroexpand-all postwalk-replace], :type :clj, :sym clojure.walk} {:var-syms [keywordize-keys postwalk postwalk-replace prewalk prewalk-replace stringify-keys walk], :type :cljs, :sym clojure.walk} {:var-syms [var-sym->url spec->html example->html expandable-section ns-sym->url sidebar var->html page-url update-link export-form export source->html app], :type :clj, :sym dynadoc.common} {:var-syms [print-server handler get-clj-vars dev-start get-cljs-nses-and-vars-dynamically get-clj-nses get-examples var-map->vars get-cljs-nses-and-vars start *options public-files get-cljs-vars page export *web-server get-cljs-nses get-clj-var-info], :type :clj, :sym dynadoc.core} {:var-syms [defexample registry-ref parse-example defexamples parse-val non-evaled-fn? parse-ns defexample* parse-keys defexamples*], :type :clj, :sym dynadoc.example} {:var-syms [defexample defexamples], :type :cljs, :sym dynadoc.example} {:var-syms [read-cljs-file get-cljs-arglists get-cljs-nses-and-vars], :type :clj, :sym dynadoc.static} {:var-syms [form->serializable flatten-vals process-example], :type :clj, :sym dynadoc.utils} {:var-syms [when-resolves], :type :clj, :sym dynapath.defaults} {:var-syms [can-read? DynamicClasspath add-classpath-url can-add? base-readable-addable-classpath classpath-urls], :type :clj, :sym dynapath.dynamic-classpath} {:var-syms [all-classpath-urls addable-classpath? add-classpath-url readable-classpath? classpath-urls], :type :clj, :sym dynapath.util} {:var-syms [thunk-timeout uglify-time-unit], :type :clj, :sym eval-soup.clojail} {:var-syms [code->results eval-form-safely with-security eval-form], :type :clj, :sym eval-soup.core} {:var-syms [add-timeout-checks add-timeout-reset add-timeouts-if-necessary code->results custom-load! eval-forms fix-goog-path state str->form wrap-macroexpand], :type :cljs, :sym eval-soup.core} {:var-syms [process-handler process-paths extract-paths-by-type created? watch! stop! deleted? remove-duplicate-paths file? remove-children-paths process-context directory? modified? catch-errors], :type :clj, :sym hawk.core} {:var-syms [standard-watch-event-kinds polling-watcher-impl barbary-watch-event-kinds stop! new-watcher barbary-watcher-impl sensitivity-watch-event-modifiers Watcher java-watcher-impl take! register!], :type :clj, :sym hawk.watcher} {:var-syms [line->segments tag->hiccup line->html code->hiccup split-lines code->html line->hiccup tags-for-line->hiccup tag->html escape-html-str tags-for-line->html structurize-hiccup escape-html-char parse-lines], :type :clj, :sym html-soup.core} {:var-syms [run-main! compile-cljs! stop-server! init-server-logs! start-build-thread! init-reload-server! start-app! append! get-cljs-options start-server! send-message! create-app-bridge compile-clj! redirect-stdio! stop-app!], :type :clj, :sym lightmod.app} {:var-syms [font! up! should-remove? undo! close! dark-theme! export! find! redo! font-inc! new-file! font-dec! focus-on-find! light-theme! toggle-instarepl! restart! apply-template! save! new-project!], :type :clj, :sym lightmod.controller} {:var-syms [version handler dev-main actions start-web-server!], :type :clj, :sym lightmod.core} {:var-syms [read-logo], :type :clj, :sym lightmod.init} {:var-syms [clj-logo construct-hud-node current-ns eval-code form->serializable read-logo], :type :cljs, :sym lightmod.init} {:var-syms [connect! send-changed! reload-handler start-reload-server! reload-file! send-message! web-path], :type :clj, :sym lightmod.reload} {:var-syms [create-pipes pipe-into-console! start-repl-thread!], :type :clj, :sym lightmod.repl} {:var-syms [init-docs! init-console! alert! dir-pane open-in-file-browser! open-in-web-browser! init-server-repl! set-selection-listener! init-client-repl! create-tab eval-cljs-code], :type :clj, :sym lightmod.ui} {:var-syms [get-project-dir sanitize-name path->ns check-namespaces! current-project? get-files-in-dep-order copy-from-resources!], :type :clj, :sym lightmod.utils} {:var-syms [update-editor-buttons! create-file-watcher remove-editors! handler wrap-exts form->serializable max-file-size remove-non-existing-editors! get-bridge should-open? toggle-instarepl! ids save-file! start-web-server! editor-pane remove-editor! eval-code onload clojure-exts], :type :clj, :sym nightcode.editors} {:var-syms [id->key-char hide-tooltips! add-tooltip! set-shortcut-listeners! remove-tooltips! show-tabs! add-tooltips! show-tooltip! hide-tooltip! key-char->id update-tabs! init-tabs! show-tooltips! remove-tooltip! hide-tabs! run-shortcut!], :type :clj, :sym nightcode.shortcuts} {:var-syms [ns? obs-list? atom? tree-item? file-array-type file-array? pane? scene? file? stage? node?], :type :clj, :sym nightcode.spec} {:var-syms [read-pref init-pref-state! write-pref! runtime-state remove-pref! pref-state], :type :clj, :sym nightcode.state} {:var-syms [get-icon-path filter-paths get-boot-tasks show-warning! get-extension delete-children-recursively! build-systems normalize-text-size uri->str get-project-path remove-returns get-exec-uri get-project-root-path parent-path? get-relative-path delete-parents-recursively! get-boot-path update-webviews!], :type :clj, :sym nightcode.utils} {:var-syms [ns-tracker], :type :clj, :sym ns-tracker.core} {:var-syms [dependent seq-union dependencies remove-key depends? depend dependents graph remove-all], :type :clj, :sym ns-tracker.dependency} {:var-syms [deps-from-ns-decl], :type :clj, :sym ns-tracker.nsdeps} {:var-syms [in-ns-decl? read-in-ns-decl], :type :clj, :sym ns-tracker.parse} {:var-syms [*read-eval* *suppress-read* *default-data-reader-fn* read read-symbol default-data-readers *data-readers* *read-delim* resolve-symbol *alias-map* *wrap-value-and-add-metadata?* read-regex syntax-quote read-string map-func], :type :clj, :sym oakclojure.tools.reader} {:var-syms [default-uuid-reader validated read-instant-timestamp read-instant-calendar read-instant-date parse-timestamp], :type :clj, :sym oakclojure.tools.reader.default-data-readers} {:var-syms [match-number skip-line int-pattern read-comment parse-symbol number-literal? read-past float-pattern throwing-reader ratio-pattern], :type :clj, :sym oakclojure.tools.reader.impl.commons} {:var-syms [throw-bad-dispatch throw-invalid-unicode-escape throw-bad-ns throw-unknown-reader-tag throw-eof-at-dispatch throw-bad-metadata-target throw-invalid-number reader-error throw-invalid-unicode-literal throw-ns-map-no-map throw-unsupported-character throw-feature-not-keyword throw-eof-delimited throw-eof-in-character throw-bad-char eof-error throw-bad-metadata throw-eof-reading throw-eof-error illegal-arg-error throw-invalid-octal-len throw-invalid-unicode-digit throw-invalid-unicode-digit-in-token throw-invalid-unicode-len throw-single-colon throw-odd-map throw-bad-octal-number throw-bad-reader-tag throw-unmatch-delimiter throw-invalid-character-literal throw-invalid-unicode-char throw-bad-escape-char throw-no-dispatch throw-eof-at-start throw-invalid], :type :clj, :sym oakclojure.tools.reader.impl.errors} {:var-syms [inspect inspect*], :type :clj, :sym oakclojure.tools.reader.impl.inspect} {:var-syms [whitespace? char numeric? make-var second' desugar-meta <=clojure-1-7-alpha5 ex-info? newline? namespace-keys compile-when], :type :clj, :sym oakclojure.tools.reader.impl.utils} {:var-syms [ReaderCoercer indexing-push-back-reader log-source* merge-meta ->StringReader to-pbr to-rdr Reader source-logging-push-back-reader unread peek-char push-back-reader IPushbackReader indexing-reader? string-reader read-char get-column-number get-file-name read-line ->PushbackReader PushbackReaderCoercer string-push-back-reader log-source ->SourceLoggingPushbackReader ->InputStreamReader line-start? input-stream-push-back-reader source-logging-reader? IndexingReader get-line-number input-stream-reader ->IndexingPushbackReader], :type :clj, :sym oakclojure.tools.reader.reader-types} {:var-syms [on-receive accept run-server send! send-websocket-handshake! on-close with-channel Channel close sec-websocket-accept websocket? open?], :type :clj, :sym org.httpkit.server} {:var-syms [:animation :arc :bezier :contour :curve :div :ellipse :fill :hsb :image :line :point :quad :rect :rgb :shape :stroke :text :triangle Game Screen create-game get-asset get-canvas get-delta-time get-height get-pressed-keys get-renderer get-screen get-total-time get-width listen load-image load-tiled-map on-hide on-render on-show pre-render render set-screen set-size start], :type :cljs, :sym play-cljs.core} {:var-syms [basic-defaults halign->constant hsb-defaults img-defaults rgb-defaults style->constant text-defaults update-opts valign->constant], :type :cljs, :sym play-cljs.utils} {:var-syms [NODE_ENV], :type :cljs, :sym process.env} {:var-syms [run-jetty], :type :clj, :sym ring.adapter.jetty} {:var-syms [StreamableResponseBody write-body-to-stream], :type :clj, :sym ring.core.protocols} {:var-syms [wrap-content-type content-type-response], :type :clj, :sym ring.middleware.content-type} {:var-syms [file-request wrap-file], :type :clj, :sym ring.middleware.file} {:var-syms [head-request wrap-head head-response], :type :clj, :sym ring.middleware.head} {:var-syms [keyword-params-request wrap-keyword-params], :type :clj, :sym ring.middleware.keyword-params} {:var-syms [wrap-params params-request assoc-form-params assoc-query-params], :type :clj, :sym ring.middleware.params} {:var-syms [wrap-reload], :type :clj, :sym ring.middleware.reload} {:var-syms [wrap-resource resource-request], :type :clj, :sym ring.middleware.resource} {:var-syms [percent-encode url-decode fix-string-replace-bug form-encode form-decode-str form-decode assoc-conj url-encode FormEncodeable form-encode* base64-decode percent-decode base64-encode], :type :clj, :sym ring.util.codec} {:var-syms [last-modified-date close! piped-input-stream string-input-stream], :type :clj, :sym ring.util.io} {:var-syms [ext-mime-type default-mime-types], :type :clj, :sym ring.util.mime-type} {:var-syms [re-token re-quoted re-charset re-value], :type :clj, :sym ring.util.parsing} {:var-syms [request-url body-string content-length content-type path-info character-encoding urlencoded-form? set-context in-context?], :type :clj, :sym ring.util.request} {:var-syms [get-header redirect redirect-status-codes set-cookie response find-header file-response resource-response get-charset created header charset url-response redirect-after-post update-header resource-data status not-found content-type response?], :type :clj, :sym ring.util.response} {:var-syms [update-servlet-response merge-servlet-keys make-service-method servlet build-request-map defservice], :type :clj, :sym ring.util.servlet} {:var-syms [http-date-formats format-date parse-date], :type :clj, :sym ring.util.time} {:var-syms [mount unmount local reactive ref-node react render-static-markup request-render with-key build-defcs ref defc static defcs cursor state cursor-in dom-node with-ref build-defc render-html build-defcc derived-atom defcc], :type :clj, :sym rum.core} {:var-syms [->Cursor], :type :clj, :sym rum.cursor} {:var-syms [derived-atom], :type :clj, :sym rum.derived-atom} {:var-syms [normalize-css-value render-class! render-inner-html! *select-value* render-attrs! render-style-kv! normalize-css-key unitless-css-props render-static-markup to-str normalize-attr-key render-textarea-value! render-content! nothing? normalize-element render-attr! render-classes! append! get-value ToString parse-selector -render-html render-html HtmlRenderer render-element! normalized-attrs escape-html render-style! adler32], :type :clj, :sym rum.server-render} {:var-syms [call-all filter-vals collect collect*], :type :clj, :sym rum.util} {:var-syms [compile-merge-attrs compile-react compile-react-element to-js compile-attr ICompile compile-attrs compile-html IJSValue], :type :clj, :sym sablono.compiler} {:var-syms [map-lookup? attributes compact-map children element match-tag strip-css class class-name merge-with-class], :type :clj, :sym sablono.normalize} {:var-syms [join-classes to-str react-fn camel-case-keys element? *base-url* as-str html-to-dom-attrs ToString ToURI camel-case to-uri], :type :clj, :sym sablono.util} {:var-syms [special-indent code->tags indent-for-line adjust-indent read-safe unwrap-value get-tags-before-line forward-indent-for-line tag-map back-indent-for-line], :type :clj, :sym tag-soup.core}], :cljs-nses-and-vars {cljs.env.macros [{:sym ensure, :meta {:doc nil, :arglists ([& body])}, :examples []} {:sym with-compiler-env, :meta {:doc "Evaluates [body] with [env] bound as the value of the `*compiler*` var in\n this namespace.", :arglists ([env & body])}, :examples []}], eval-soup.core [{:sym add-timeout-checks, :meta {:doc nil, :arglists ([form])}, :examples []} {:sym add-timeout-reset, :meta {:doc nil, :arglists ([form])}, :examples []} {:sym add-timeouts-if-necessary, :meta {:doc nil, :arglists ([forms expanded-forms])}, :examples []} {:sym code->results, :meta {:doc nil, :arglists ([forms cb] [forms cb {:keys [custom-load current-ns], :or {custom-load custom-load!, current-ns (atom (quote cljs.user))}}])}, :examples []} {:sym custom-load!, :meta {:doc nil, :arglists ([opts cb] [opts extensions cb])}, :examples []} {:sym eval-forms, :meta {:doc nil, :arglists ([forms cb state current-ns custom-load])}, :examples []} {:sym fix-goog-path, :meta {:doc nil, :arglists ([path])}, :examples []} {:sym state, :meta {:doc nil, :arglists nil}, :examples []} {:sym str->form, :meta {:doc nil, :arglists ([s])}, :examples []} {:sym wrap-macroexpand, :meta {:doc nil, :arglists ([form])}, :examples []}], cljs.compiler [{:sym *inputs*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *lexical-renames*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *recompiled*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *source-map-data*, :meta {:doc nil, :arglists nil}, :examples []} {:sym base-types, :meta {:doc nil, :arglists nil}, :examples []} {:sym checking-types?, :meta {:doc nil, :arglists ([])}, :examples []} {:sym cljs-reserved-file-names, :meta {:doc nil, :arglists nil}, :examples []} {:sym distinct-constants?, :meta {:doc nil, :arglists ([items])}, :examples []} {:sym distinct-keys?, :meta {:doc nil, :arglists ([keys])}, :examples []} {:sym emit, :meta {:doc nil, :arglists ([ast])}, :examples []} {:sym emit*, :meta {:doc nil, :arglists nil}, :examples []} {:sym emit-apply-to, :meta {:doc nil, :arglists ([{:keys [name params env]}])}, :examples []} {:sym emit-arguments-to-array, :meta {:doc "Emit code that copies function arguments into an array starting at an index.\n  Returns name of var holding the array.", :arglists ([startslice])}, :examples []} {:sym emit-comment, :meta {:doc "Emit a nicely formatted comment string.", :arglists ([doc jsdoc] [env doc jsdoc])}, :examples []} {:sym emit-constant, :meta {:doc nil, :arglists nil}, :examples []} {:sym emit-constants-table, :meta {:doc nil, :arglists ([table])}, :examples []} {:sym emit-externs, :meta {:doc nil, :arglists ([externs] [prefix externs top-level known-externs])}, :examples []} {:sym emit-fn-method, :meta {:doc nil, :arglists ([{:keys [type name variadic params expr env recurs max-fixed-arity]}])}, :examples []} {:sym emit-fn-params, :meta {:doc nil, :arglists ([params])}, :examples []} {:sym emit-let, :meta {:doc nil, :arglists ([{:keys [bindings expr env]} is-loop])}, :examples []} {:sym emit-str, :meta {:doc nil, :arglists ([expr])}, :examples []} {:sym emit-variadic-fn-method, :meta {:doc nil, :arglists ([{:keys [type name variadic params expr env recurs max-fixed-arity], :as f}])}, :examples []} {:sym emitln, :meta {:doc nil, :arglists ([& xs])}, :examples []} {:sym emits, :meta {:doc nil, :arglists ([& xs])}, :examples []} {:sym emits-keyword, :meta {:doc nil, :arglists ([kw])}, :examples []} {:sym emits-symbol, :meta {:doc nil, :arglists ([sym])}, :examples []} {:sym falsey-constant?, :meta {:doc nil, :arglists ([{:keys [op form const-expr]}])}, :examples []} {:sym find-ns-starts-with, :meta {:doc nil, :arglists ([needle])}, :examples []} {:sym fn-self-name, :meta {:doc nil, :arglists ([{:keys [name info], :as name-var}])}, :examples []} {:sym get-define, :meta {:doc nil, :arglists ([mname jsdoc])}, :examples []} {:sym get-first-ns-segment, :meta {:doc "Gets the part up to the first `.` of a namespace.\n   Returns the empty string for nil.\n   Returns the entire string if no `.` in namespace", :arglists ([ns])}, :examples []} {:sym hash-scope, :meta {:doc nil, :arglists ([s])}, :examples []} {:sym js-reserved, :meta {:doc nil, :arglists nil}, :examples []} {:sym load-libs, :meta {:doc nil, :arglists ([libs seen reloads deps ns-name])}, :examples []} {:sym mapped-types, :meta {:doc nil, :arglists nil}, :examples []} {:sym munge, :meta {:doc nil, :arglists ([s] [s reserved])}, :examples []} {:sym munge-param-return, :meta {:doc nil, :arglists ([env line])}, :examples []} {:sym munge-reserved, :meta {:doc nil, :arglists ([reserved])}, :examples []} {:sym protocol-prefix, :meta {:doc nil, :arglists ([psym])}, :examples []} {:sym resolve-type, :meta {:doc nil, :arglists ([env t])}, :examples []} {:sym resolve-types, :meta {:doc nil, :arglists ([env ts])}, :examples []} {:sym safe-test?, :meta {:doc nil, :arglists ([env e])}, :examples []} {:sym shadow-depth, :meta {:doc nil, :arglists ([s])}, :examples []} {:sym truthy-constant?, :meta {:doc nil, :arglists ([{:keys [op form const-expr]}])}, :examples []} {:sym valid-define-value?, :meta {:doc nil, :arglists ([x])}, :examples []}], adzerk.boot-reload.connection [{:sym alive?, :meta {:doc nil, :arglists ([])}, :examples []} {:sym send-message!, :meta {:doc nil, :arglists ([message])}, :examples []} {:sym ws-conn, :meta {:doc nil, :arglists nil}, :examples []}], adzerk.boot-reload.reload [{:sym has-dom?, :meta {:doc "Perform heuristics to check if a non-shimmed DOM is available", :arglists ([])}, :examples []} {:sym load-files, :meta {:doc nil, :arglists ([urls])}, :examples []} {:sym reload, :meta {:doc nil, :arglists ([changed opts])}, :examples []}], cljs.source-map.base64 [{:sym char->int, :meta {:doc nil, :arglists nil}, :examples []} {:sym chars64, :meta {:doc nil, :arglists nil}, :examples []} {:sym decode, :meta {:doc nil, :arglists ([c])}, :examples []} {:sym encode, :meta {:doc nil, :arglists ([n])}, :examples []} {:sym int->char, :meta {:doc nil, :arglists nil}, :examples []}], basic-game.client [{:sym game, :meta {:doc nil, :arglists nil}, :examples []} {:sym main-screen, :meta {:doc nil, :arglists nil}, :examples []} {:sym state, :meta {:doc nil, :arglists nil}, :examples []}], cljs.core.async.impl.channels [{:sym ->ManyToManyChannel, :meta {:doc nil, :arglists ([takes dirty-takes puts dirty-puts buf closed add!])}, :examples []} {:sym ->PutBox, :meta {:doc nil, :arglists ([handler val])}, :examples []} {:sym MAX_DIRTY, :meta {:doc nil, :arglists nil}, :examples []} {:sym MMC, :meta {:doc nil, :arglists nil}, :examples []} {:sym ManyToManyChannel, :meta {:doc nil, :arglists nil}, :examples []} {:sym PutBox, :meta {:doc nil, :arglists nil}, :examples []} {:sym abort, :meta {:doc nil, :arglists ([this])}, :examples []} {:sym box, :meta {:doc nil, :arglists ([val])}, :examples []} {:sym chan, :meta {:doc nil, :arglists ([buf] [buf xform] [buf xform exh])}, :examples []} {:sym put-active?, :meta {:doc nil, :arglists ([box])}, :examples []}], cljs.core.async.impl.dispatch [{:sym TASK_BATCH_SIZE, :meta {:doc nil, :arglists nil}, :examples []} {:sym process-messages, :meta {:doc nil, :arglists ([])}, :examples []} {:sym queue-delay, :meta {:doc nil, :arglists ([f delay])}, :examples []} {:sym queue-dispatcher, :meta {:doc nil, :arglists ([])}, :examples []} {:sym queued?, :meta {:doc nil, :arglists nil}, :examples []} {:sym run, :meta {:doc nil, :arglists ([f])}, :examples []} {:sym running?, :meta {:doc nil, :arglists nil}, :examples []} {:sym tasks, :meta {:doc nil, :arglists nil}, :examples []}], cljs.core.async.macros [{:sym alt!, :meta {:doc "Makes a single choice between one of several channel operations,\n  as if by alts!, returning the value of the result expr corresponding\n  to the operation completed. Must be called inside a (go ...) block.\n\n  Each clause takes the form of:\n\n  channel-op[s] result-expr\n\n  where channel-ops is one of:\n\n  take-port - a single port to take\n  [take-port | [put-port put-val] ...] - a vector of ports as per alts!\n  :default | :priority - an option for alts!\n\n  and result-expr is either a list beginning with a vector, whereupon that\n  vector will be treated as a binding for the [val port] return of the\n  operation, else any other expression.\n\n  (alt!\n    [c t] ([val ch] (foo ch val))\n    x ([v] v)\n    [[out val]] :wrote\n    :default 42)\n\n  Each option may appear at most once. The choice and parking\n  characteristics are those of alts!.", :arglists ([& clauses])}, :examples []} {:sym go, :meta {:doc "Asynchronously executes the body, returning immediately to the\n  calling thread. Additionally, any visible calls to <!, >! and alt!/alts!\n  channel operations within the body will block (if necessary) by\n  'parking' the calling thread rather than tying up an OS thread (or\n  the only JS thread when in ClojureScript). Upon completion of the\n  operation, the body will be resumed.\n\n  Returns a channel which will receive the result of the body when\n  completed", :arglists ([& body])}, :examples []} {:sym go-loop, :meta {:doc "Like (go (loop ...))", :arglists ([bindings & body])}, :examples []}], play-cljs.utils [{:sym basic-defaults, :meta {:doc nil, :arglists nil}, :examples []} {:sym halign->constant, :meta {:doc nil, :arglists ([renderer halign])}, :examples []} {:sym hsb-defaults, :meta {:doc nil, :arglists nil}, :examples []} {:sym img-defaults, :meta {:doc nil, :arglists nil}, :examples []} {:sym rgb-defaults, :meta {:doc nil, :arglists nil}, :examples []} {:sym style->constant, :meta {:doc nil, :arglists ([renderer style])}, :examples []} {:sym text-defaults, :meta {:doc nil, :arglists nil}, :examples []} {:sym update-opts, :meta {:doc nil, :arglists ([opts parent-opts defaults])}, :examples []} {:sym valign->constant, :meta {:doc nil, :arglists ([renderer valign])}, :examples []}], adzerk.boot-reload.display [{:sym ->css, :meta {:doc nil, :arglists ([rules])}, :examples []} {:sym cljs-logo, :meta {:doc nil, :arglists nil}, :examples []} {:sym construct-hud-node, :meta {:doc nil, :arglists ([{:keys [warnings exception], :as messages}])}, :examples []} {:sym current-container, :meta {:doc nil, :arglists nil}, :examples []} {:sym display, :meta {:doc nil, :arglists ([messages opts])}, :examples []} {:sym exception-node, :meta {:doc nil, :arglists ([{:keys [message line file], :as data}])}, :examples []} {:sym gen-id, :meta {:doc nil, :arglists ([])}, :examples []} {:sym insert-container!, :meta {:doc nil, :arglists ([id {:keys [warnings exception], :as messages}])}, :examples []} {:sym logo-node, :meta {:doc nil, :arglists ([logo])}, :examples []} {:sym mk-node, :meta {:doc nil, :arglists ([type] [type attrs] [type attrs content])}, :examples []} {:sym open-file, :meta {:doc nil, :arglists ([data])}, :examples []} {:sym reloaded-node, :meta {:doc nil, :arglists ([])}, :examples []} {:sym remove-container!, :meta {:doc nil, :arglists ([id])}, :examples []} {:sym style, :meta {:doc nil, :arglists ([& types])}, :examples []} {:sym transition-duration, :meta {:doc nil, :arglists nil}, :examples []} {:sym warning-node, :meta {:doc nil, :arglists ([{:keys [message line file], :as data}])}, :examples []} {:sym warnings-node, :meta {:doc nil, :arglists ([warnings])}, :examples []}], cljs.tools.reader.impl.commons [{:sym float-pattern, :meta {:doc nil, :arglists nil}, :examples []} {:sym int-pattern, :meta {:doc nil, :arglists nil}, :examples []} {:sym match-number, :meta {:doc nil, :arglists ([s])}, :examples []} {:sym matches?, :meta {:doc nil, :arglists ([pattern s])}, :examples []} {:sym number-literal?, :meta {:doc "Checks whether the reader is at the start of a number literal", :arglists ([reader initch])}, :examples []} {:sym parse-symbol, :meta {:doc "Parses a string into a vector of the namespace and symbol", :arglists ([token])}, :examples []} {:sym ratio-pattern, :meta {:doc nil, :arglists nil}, :examples []} {:sym read-comment, :meta {:doc nil, :arglists ([rdr & _])}, :examples []} {:sym read-past, :meta {:doc "Read until first character that doesn't match pred, returning\n   char.", :arglists ([pred rdr])}, :examples []} {:sym skip-line, :meta {:doc "Advances the reader to the end of a line. Returns the reader", :arglists ([reader])}, :examples []} {:sym throwing-reader, :meta {:doc nil, :arglists ([msg])}, :examples []}], cljs.tools.reader.edn [{:sym read, :meta {:doc "Reads the first object from an IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\n   If no reader is provided, *in* will be used.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   clojure.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\n   is done by passing an opt map.\n\n   opts is a map that can include the following keys:\n   :eof - value to return on end-of-file. When not supplied, eof throws an exception.\n   :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\n              When not supplied, only the default-data-readers will be used.\n   :default - A function of two args, that will, if present and no reader is found for a tag,\n              be called with the tag and the value.", :arglists ([reader] [{:keys [eof], :as opts} reader] [reader eof-error? eof opts])}, :examples []} {:sym read-string, :meta {:doc "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   opts is a map as per clojure.tools.reader.edn/read", :arglists ([s] [opts s])}, :examples []}], cljs.source-map.base64-vlq [{:sym decode, :meta {:doc nil, :arglists ([s])}, :examples []} {:sym encode, :meta {:doc nil, :arglists ([v])}, :examples []} {:sym encode-val, :meta {:doc nil, :arglists ([n])}, :examples []} {:sym from-vlq-signed, :meta {:doc nil, :arglists ([v])}, :examples []} {:sym to-vlq-signed, :meta {:doc nil, :arglists ([v])}, :examples []} {:sym vlq-base, :meta {:doc nil, :arglists nil}, :examples []} {:sym vlq-base-mask, :meta {:doc nil, :arglists nil}, :examples []} {:sym vlq-base-shift, :meta {:doc nil, :arglists nil}, :examples []} {:sym vlq-continuation-bit, :meta {:doc nil, :arglists nil}, :examples []}], cljs.core$macros [{:sym *, :meta {:doc nil, :arglists ([&form &env] [&form &env x] [&form &env x y] [&form &env x y & more])}, :examples []} {:sym +, :meta {:doc nil, :arglists ([&form &env] [&form &env x] [&form &env x y] [&form &env x y & more])}, :examples []} {:sym -, :meta {:doc nil, :arglists ([&form &env x] [&form &env x y] [&form &env x y & more])}, :examples []} {:sym ->, :meta {:doc "Threads the expr through the forms. Inserts x as the\n     second item in the first form, making a list of it if it is not a\n     list already. If there are more forms, inserts the first form as the\n     second item in second form, etc.", :arglists ([&form &env x & forms])}, :examples []} {:sym ->>, :meta {:doc "Threads the expr through the forms. Inserts x as the\n     last item in the first form, making a list of it if it is not a\n     list already. If there are more forms, inserts the first form as the\n     last item in second form, etc.", :arglists ([&form &env x & forms])}, :examples []} {:sym .., :meta {:doc "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n     Expands into a member access (.) of the first member on the first\n     argument, followed by the next member on the result, etc. For\n     instance:\n\n     (.. System (getProperties) (get \"os.name\"))\n\n     expands to:\n\n     (. (. System (getProperties)) (get \"os.name\"))\n\n     but is easier to write, read, and understand.", :arglists ([&form &env x form] [&form &env x form & more])}, :examples []} {:sym /, :meta {:doc nil, :arglists ([&form &env x] [&form &env x y] [&form &env x y & more])}, :examples []} {:sym <, :meta {:doc nil, :arglists ([&form &env x] [&form &env x y] [&form &env x y & more])}, :examples []} {:sym <=, :meta {:doc nil, :arglists ([&form &env x] [&form &env x y] [&form &env x y & more])}, :examples []} {:sym ==, :meta {:doc nil, :arglists ([&form &env x] [&form &env x y] [&form &env x y & more])}, :examples []} {:sym >, :meta {:doc nil, :arglists ([&form &env x] [&form &env x y] [&form &env x y & more])}, :examples []} {:sym >=, :meta {:doc nil, :arglists ([&form &env x] [&form &env x y] [&form &env x y & more])}, :examples []} {:sym aget, :meta {:doc nil, :arglists ([&form &env array idx] [&form &env array idx & idxs])}, :examples []} {:sym alength, :meta {:doc nil, :arglists ([a])}, :examples []} {:sym amap, :meta {:doc "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting\n  each element of ret to the evaluation of expr, returning the new\n  array ret.", :arglists ([a idx ret expr])}, :examples []} {:sym and, :meta {:doc "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.", :arglists ([&form &env] [&form &env x] [&form &env x & next])}, :examples []} {:sym areduce, :meta {:doc "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the\n  evaluation of expr at each step, returning ret.", :arglists ([a idx ret init expr])}, :examples []} {:sym array, :meta {:doc nil, :arglists ([&form &env & rest])}, :examples []} {:sym array-map, :meta {:doc nil, :arglists ([&form &env] [&form &env & kvs])}, :examples []} {:sym as->, :meta {:doc "Binds name to expr, evaluates the first form in the lexical context\n     of that binding, then binds name to that result, repeating for each\n     successive form, returning the result of the last form.", :arglists ([&form &env expr name & forms])}, :examples []} {:sym aset, :meta {:doc nil, :arglists ([&form &env array idx val] [&form &env array idx idx2 & idxv])}, :examples []} {:sym assert, :meta {:doc "Evaluates expr and throws an exception if it does not evaluate to\n  logical true.", :arglists ([&form &env x] [&form &env x message])}, :examples []} {:sym binding, :meta {:doc "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.", :arglists ([&form &env bindings & body])}, :examples []} {:sym bit-and, :meta {:doc nil, :arglists ([&form &env x y] [&form &env x y & more])}, :examples []} {:sym bit-and-not, :meta {:doc nil, :arglists ([&form &env x y] [&form &env x y & more])}, :examples []} {:sym bit-clear, :meta {:doc nil, :arglists ([x n])}, :examples []} {:sym bit-flip, :meta {:doc nil, :arglists ([x n])}, :examples []} {:sym bit-not, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym bit-or, :meta {:doc nil, :arglists ([&form &env x y] [&form &env x y & more])}, :examples []} {:sym bit-set, :meta {:doc nil, :arglists ([x n])}, :examples []} {:sym bit-shift-left, :meta {:doc nil, :arglists ([x n])}, :examples []} {:sym bit-shift-right, :meta {:doc nil, :arglists ([x n])}, :examples []} {:sym bit-shift-right-zero-fill, :meta {:doc nil, :arglists ([x n])}, :examples []} {:sym bit-test, :meta {:doc nil, :arglists ([x n])}, :examples []} {:sym bit-xor, :meta {:doc nil, :arglists ([&form &env x y] [&form &env x y & more])}, :examples []} {:sym bitpos, :meta {:doc nil, :arglists ([hash shift])}, :examples []} {:sym byte, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym caching-hash, :meta {:doc nil, :arglists ([coll hash-fn hash-key])}, :examples []} {:sym case, :meta {:doc "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an Error is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (ClojureScript) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.", :arglists ([&form &env e & clauses])}, :examples []} {:sym coercive-=, :meta {:doc nil, :arglists ([x y])}, :examples []} {:sym coercive-boolean, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym coercive-not, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym coercive-not=, :meta {:doc nil, :arglists ([x y])}, :examples []} {:sym comment, :meta {:doc "Ignores body, yields nil", :arglists ([&form &env & body])}, :examples []} {:sym cond, :meta {:doc "Takes a set of test/expr pairs. It evaluates each test one at a\n     time.  If a test returns logical true, cond evaluates and returns\n     the value of the corresponding expr and doesn't evaluate any of the\n     other tests or exprs. (cond) returns nil.", :arglists ([&form &env & clauses])}, :examples []} {:sym cond->, :meta {:doc "Takes an expression and a set of test/form pairs. Threads expr (via ->)\n     through each form for which the corresponding test\n     expression is true. Note that, unlike cond branching, cond-> threading does\n     not short circuit after the first true test expression.", :arglists ([&form &env expr & clauses])}, :examples []} {:sym cond->>, :meta {:doc "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n     through each form for which the corresponding test expression\n     is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n     after the first true test expression.", :arglists ([&form &env expr & clauses])}, :examples []} {:sym condp, :meta {:doc "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an\n  IllegalArgumentException is thrown.", :arglists ([&form &env pred expr & clauses])}, :examples []} {:sym copy-arguments, :meta {:doc nil, :arglists ([dest])}, :examples []} {:sym dec, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym declare, :meta {:doc "defs the supplied var names with no bindings, useful for making forward declarations.", :arglists ([&form &env & names])}, :examples []} {:sym defmacro, :meta {:doc "Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.", :arglists ([&form &env name & args])}, :examples []} {:sym defmethod, :meta {:doc "Creates and installs a new method of multimethod associated with dispatch-value. ", :arglists ([&form &env multifn dispatch-val & fn-tail])}, :examples []} {:sym defmulti, :meta {:doc "Creates a new multimethod with the associated dispatch function.\n  The docstring and attribute-map are optional.\n\n  Options are key-value pairs and may be one of:\n    :default    the default dispatch value, defaults to :default\n    :hierarchy  the isa? hierarchy to use for dispatching\n                defaults to the global hierarchy", :arglists ([&form &env mm-name & options])}, :examples []} {:sym defn, :meta {:doc "Same as (def name (core/fn [params* ] exprs*)) or (def\n    name (core/fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.", :arglists ([name doc-string? attr-map? [params*] prepost-map? body] [name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?])}, :examples []} {:sym defn-, :meta {:doc "same as defn, yielding non-public def", :arglists ([&form &env name & decls])}, :examples []} {:sym defonce, :meta {:doc "defs name to have the root value of init iff the named var has no root value,\n  else init is unevaluated", :arglists ([x init])}, :examples []} {:sym defprotocol, :meta {:doc "A protocol is a named set of named methods and their signatures:\n\n  (defprotocol AProtocolName\n    ;optional doc string\n    \"A doc string for AProtocol abstraction\"\n\n  ;method signatures\n    (bar [this a b] \"bar docs\")\n    (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in\n  JavaScript parlance). defprotocol is dynamic, has no special compile-time\n  effect, and defines no new types.\n\n  (defprotocol P\n    (foo [this])\n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c]\n    P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n\n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo\n    (let [x 42]\n      (reify P\n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17", :arglists ([&form &env psym & doc+methods])}, :examples []} {:sym defrecord, :meta {:doc "(defrecord name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The record will have the (immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in JavaScript parlance). Note also\n  that recur calls to the method head should *not* pass the target object, it\n  will be supplied automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The type will have implementations of several ClojureScript\n  protocol generated automatically: IMeta/IWithMeta (metadata support) and\n  IMap, etc.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will define ClojureScript IHash and IEquiv.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta\n  and __extmap are currently reserved and should not be used when\n  defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values.", :arglists ([&form &env rsym fields & impls])}, :examples []} {:sym deftype, :meta {:doc "(deftype name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The type will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly. Fields can be qualified\n  with the metadata :mutable true at which point (set! afield aval) will be\n  supported in method bodies. Note well that mutable fields are extremely\n  difficult to use correctly, and are present only to facilitate the building\n  of higherlevel constructs, such as ClojureScript's reference types, in\n  ClojureScript itself. They are for experts only - if the semantics and\n  implications of :mutable are not immediately apparent to you, you should not\n  be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for methods of Object. Note that\n  a parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta and __extmap are currently reserved and\n  should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields", :arglists ([&form &env t fields & impls])}, :examples []} {:sym delay, :meta {:doc "Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls.", :arglists ([&form &env & body])}, :examples []} {:sym destructure, :meta {:doc nil, :arglists ([bindings])}, :examples []} {:sym divide, :meta {:doc nil, :arglists ([&form &env x] [&form &env x y] [&form &env x y & more])}, :examples []} {:sym doseq, :meta {:doc "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \"for\".  Does not retain\n  the head of the sequence. Returns nil.", :arglists ([&form &env seq-exprs & body])}, :examples []} {:sym dotimes, :meta {:doc "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.", :arglists ([&form &env bindings & body])}, :examples []} {:sym doto, :meta {:doc "Evaluates x then calls all of the methods and functions with the\n     value of x supplied at the front of the given arguments.  The forms\n     are evaluated in order.  Returns x.\n\n     (doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))", :arglists ([&form &env x & forms])}, :examples []} {:sym double, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym dt->et, :meta {:doc nil, :arglists ([type specs fields] [type specs fields inline])}, :examples []} {:sym es6-iterable, :meta {:doc nil, :arglists ([ty])}, :examples []} {:sym exists?, :meta {:doc "Return true if argument exists, analogous to usage of typeof operator\n   in JavaScript.", :arglists ([x])}, :examples []} {:sym extend-protocol, :meta {:doc "Useful when you want to provide several implementations of the same\n     protocol all at once. Takes a single protocol and the implementation\n     of that protocol for one or more types. Expands into calls to\n     extend-type:\n\n     (extend-protocol Protocol\n       AType\n         (foo [x] ...)\n         (bar [x y] ...)\n       BType\n         (foo [x] ...)\n         (bar [x y] ...)\n       AClass\n         (foo [x] ...)\n         (bar [x y] ...)\n       nil\n         (foo [x] ...)\n         (bar [x y] ...))\n\n     expands into:\n\n     (do\n      (clojure.core/extend-type AType Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type BType Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type AClass Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type nil Protocol\n        (foo [x] ...)\n        (bar [x y] ...)))", :arglists ([&form &env p & specs])}, :examples []} {:sym extend-type, :meta {:doc "Extend a type to a series of protocols. Useful when you are\n  supplying the definitions explicitly inline. Propagates the\n  type as a type hint on the first argument of all fns.\n\n  type-sym may be\n\n   * default, meaning the definitions will apply for any value,\n     unless an extend-type exists for one of the more specific\n     cases below.\n   * nil, meaning the definitions will apply for the nil value.\n   * any of object, boolean, number, string, array, or function,\n     indicating the definitions will apply for values of the\n     associated base JavaScript types. Note that, for example,\n     string should be used instead of js/String.\n   * a JavaScript type not covered by the previous list, such\n     as js/RegExp.\n   * a type defined by deftype or defrecord.\n\n  (extend-type MyType\n    ICounted\n    (-count [c] ...)\n    Foo\n    (bar [x y] ...)\n    (baz ([x] ...) ([x y] ...) ...)", :arglists ([&form &env type-sym & impls])}, :examples []} {:sym false?, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym fast-path-protocol-partitions-count, :meta {:doc "total number of partitions", :arglists nil}, :examples []} {:sym fast-path-protocols, :meta {:doc "protocol fqn -> [partition number, bit]", :arglists nil}, :examples []} {:sym float, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym fn, :meta {:doc "params => positional-params* , or positional-params* & next-param\n     positional-param => binding-form\n     next-param => binding-form\n     name => symbol\n\n     Defines a function", :arglists ([&form &env & sigs])}, :examples []} {:sym for, :meta {:doc "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))", :arglists ([seq-exprs body-expr])}, :examples []} {:sym gen-apply-to, :meta {:doc nil, :arglists ([])}, :examples []} {:sym gen-apply-to-simple, :meta {:doc nil, :arglists ([f num-args args])}, :examples []} {:sym goog-define, :meta {:doc "Defines a var using `goog.define`. Passed default value must be\n  string, number or boolean.\n\n  Default value can be overridden at compile time using the\n  compiler option `:closure-defines`.\n\n  Example:\n    (ns your-app.core)\n    (goog-define DEBUG! false)\n    ;; can be overridden with\n    :closure-defines {\"your_app.core.DEBUG_BANG_\" true}\n    or\n    :closure-defines {'your-app.core/DEBUG! true}", :arglists ([sym default])}, :examples []} {:sym hash-map, :meta {:doc nil, :arglists ([&form &env] [&form &env & kvs])}, :examples []} {:sym hash-set, :meta {:doc nil, :arglists ([&form &env] [&form &env & xs])}, :examples []} {:sym identical?, :meta {:doc nil, :arglists ([a b])}, :examples []} {:sym if-let, :meta {:doc "bindings => binding-form test\n\n     If test is true, evaluates then with binding-form bound to the value of\n     test, if not, yields else", :arglists ([&form &env bindings then] [&form &env bindings then else & oldform])}, :examples []} {:sym if-not, :meta {:doc "Evaluates test. If logical false, evaluates and returns then expr,\n     otherwise else expr, if supplied, else nil.", :arglists ([&form &env test then] [&form &env test then else])}, :examples []} {:sym if-some, :meta {:doc "bindings => binding-form test\n\n      If test is not nil, evaluates then with binding-form bound to the\n      value of test, if not, yields else", :arglists ([&form &env bindings then] [&form &env bindings then else & oldform])}, :examples []} {:sym implements?, :meta {:doc "EXPERIMENTAL", :arglists ([psym x])}, :examples []} {:sym import, :meta {:doc "import-list => (closure-namespace constructor-name-symbols*)\n\n  For each name in constructor-name-symbols, adds a mapping from name to the\n  constructor named by closure-namespace to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.", :arglists ([&form &env & import-symbols-or-lists])}, :examples []} {:sym inc, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym instance?, :meta {:doc nil, :arglists ([c x])}, :examples []} {:sym int, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym js-arguments, :meta {:doc nil, :arglists ([])}, :examples []} {:sym js-comment, :meta {:doc "Emit a top-level JavaScript multi-line comment. New lines will create a\n  new comment line. Comment block will be preceded and followed by a newline", :arglists ([comment])}, :examples []} {:sym js-debugger, :meta {:doc "Emit JavaScript \"debugger;\" statement", :arglists ([])}, :examples []} {:sym js-delete, :meta {:doc nil, :arglists ([obj key])}, :examples []} {:sym js-in, :meta {:doc nil, :arglists ([key obj])}, :examples []} {:sym js-inline-comment, :meta {:doc "Emit an inline JavaScript comment.", :arglists ([comment])}, :examples []} {:sym js-mod, :meta {:doc nil, :arglists ([num div])}, :examples []} {:sym js-obj, :meta {:doc nil, :arglists ([&form &env & rest])}, :examples []} {:sym js-str, :meta {:doc nil, :arglists ([s])}, :examples []} {:sym keyword?, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym lazy-cat, :meta {:doc "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed.\n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))", :arglists ([&form &env & colls])}, :examples []} {:sym lazy-seq, :meta {:doc "Takes a body of expressions that returns an ISeq or nil, and yields\n  a ISeqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls.", :arglists ([&form &env & body])}, :examples []} {:sym let, :meta {:doc "binding => binding-form init-expr\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.", :arglists ([&form &env bindings & body])}, :examples []} {:sym letfn, :meta {:doc "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n     Takes a vector of function specs and a body, and generates a set of\n     bindings of functions to their names. All of the names are available\n     in all of the definitions of the functions, as well as the body.", :arglists ([&form &env fnspecs & body])}, :examples []} {:sym list, :meta {:doc nil, :arglists ([&form &env] [&form &env x & xs])}, :examples []} {:sym load-file*, :meta {:doc nil, :arglists ([f])}, :examples []} {:sym locking, :meta {:doc nil, :arglists ([&form &env x & forms])}, :examples []} {:sym loop, :meta {:doc "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.", :arglists ([&form &env bindings & body])}, :examples []} {:sym macroexpand, :meta {:doc "Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms.", :arglists ([quoted])}, :examples []} {:sym macroexpand-1, :meta {:doc "If form represents a macro form, returns its expansion,\n  else returns form.", :arglists ([quoted])}, :examples []} {:sym make-array, :meta {:doc nil, :arglists ([&form &env size] [&form &env type size] [&form &env type size & more-sizes])}, :examples []} {:sym mask, :meta {:doc nil, :arglists ([hash shift])}, :examples []} {:sym max, :meta {:doc nil, :arglists ([&form &env x] [&form &env x y] [&form &env x y & more])}, :examples []} {:sym memfn, :meta {:doc "Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a JavaScript\n  method as a first-class fn.", :arglists ([&form &env name & args])}, :examples []} {:sym min, :meta {:doc nil, :arglists ([&form &env x] [&form &env x y] [&form &env x y & more])}, :examples []} {:sym neg?, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym nil?, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym ns-imports, :meta {:doc "Returns a map of the import mappings for the namespace.", :arglists ([quoted-ns])}, :examples []} {:sym ns-interns, :meta {:doc "Returns a map of the intern mappings for the namespace.", :arglists ([quoted-ns])}, :examples []} {:sym ns-publics, :meta {:doc "Returns a map of the public intern mappings for the namespace.", :arglists ([quoted-ns])}, :examples []} {:sym ns-unmap, :meta {:doc "Removes the mappings for the symbol from the namespace.", :arglists ([quoted-ns quoted-sym])}, :examples []} {:sym number?, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym or, :meta {:doc "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.", :arglists ([&form &env] [&form &env x] [&form &env x & next])}, :examples []} {:sym pos?, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym refer-clojure, :meta {:doc "Refers to all the public vars of `cljs.core`, subject to\n  filters.\n  Filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  Filters can be used to select a subset, via exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent clashes.", :arglists ([&form &env & args])}, :examples []} {:sym reify, :meta {:doc "reify is a macro with the following structure:\n\n (reify options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of the protocol name followed by zero\n  or more method bodies:\n\n  protocol\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for Object methods. Note that\n  the first parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls\n  to the method head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n\n  (str (let [f \"foo\"]\n       (reify Object\n         (toString [this] f))))\n  == \"foo\"\n\n  (seq (let [f \"foo\"]\n       (reify ISeqable\n         (-seq [this] (seq f)))))\n  == (\"f\" \"o\" \"o\"))\n\n  reify always implements IMeta and IWithMeta and transfers meta\n  data of the form to the created object.\n\n  (meta ^{:k :v} (reify Object (toString [this] \"foo\")))\n  == {:k :v}", :arglists ([&form &env & impls])}, :examples []} {:sym require, :meta {:doc "Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib or a flag that modifies how all the identified\n  libs are loaded. Use :require in the ns macro in preference to calling this\n  directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of ClojureScript code. Lib names are symbols and each lib is associated\n  with a ClojureScript namespace. A lib's name also locates its root directory\n  within classpath using Java's package name to classpath-relative path mapping.\n  All resources in a lib should be contained in the directory structure under its\n  root directory. All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj. The root\n  resource should contain code to create the lib's namespace (usually by using\n  the ns macro) and load any additional lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :refer takes a list of symbols to refer from the namespace.\n  :refer-macros takes a list of macro symbols to refer from the namespace.\n  :include-macros true causes macros from the namespace to be required.\n  :rename specifies a map from referred var names to different\n    symbols (and can be used to prevent clashes)\n\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the library clojure.string :as string.\n\n  (require '[clojure.string :as string])", :arglists ([&form &env & args])}, :examples []} {:sym require-macros, :meta {:doc "Similar to require but only for macros.", :arglists ([&form &env & args])}, :examples []} {:sym resolve, :meta {:doc "Returns the var to which a symbol will be resolved in the namespace else nil.", :arglists ([quoted-sym])}, :examples []} {:sym satisfies?, :meta {:doc "Returns true if x satisfies the protocol", :arglists ([psym x])}, :examples []} {:sym short, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym simple-benchmark, :meta {:doc "Runs expr iterations times in the context of a let expression with\n  the given bindings, then prints out the bindings and the expr\n  followed by number of iterations and total time. The optional\n  argument print-fn, defaulting to println, sets function used to\n  print the result. expr's string representation will be produced\n  using pr-str in any case.", :arglists ([&form &env bindings expr iterations & {:keys [print-fn], :or {print-fn (quote println)}}])}, :examples []} {:sym some->, :meta {:doc "When expr is not nil, threads it into the first form (via ->),\n     and when that result is not nil, through the next etc", :arglists ([&form &env expr & forms])}, :examples []} {:sym some->>, :meta {:doc "When expr is not nil, threads it into the first form (via ->>),\n     and when that result is not nil, through the next etc", :arglists ([&form &env expr & forms])}, :examples []} {:sym some?, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym specify, :meta {:doc "Identical to specify! but does not mutate its first argument. The first\n  argument must be an ICloneable instance.", :arglists ([&form &env expr & impls])}, :examples []} {:sym specify!, :meta {:doc "Identical to reify but mutates its first argument.", :arglists ([&form &env expr & impls])}, :examples []} {:sym str, :meta {:doc nil, :arglists ([&form &env & xs])}, :examples []} {:sym string?, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym symbol?, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym this-as, :meta {:doc "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided.", :arglists ([&form &env name & body])}, :examples []} {:sym time, :meta {:doc "Evaluates expr and prints the time it took. Returns the value of expr.", :arglists ([expr])}, :examples []} {:sym true?, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym truth_, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-add, :meta {:doc nil, :arglists ([&form &env & xs])}, :examples []} {:sym unchecked-add-int, :meta {:doc nil, :arglists ([&form &env & xs])}, :examples []} {:sym unchecked-byte, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-char, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-dec, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-dec-int, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-divide-int, :meta {:doc nil, :arglists ([&form &env & xs])}, :examples []} {:sym unchecked-double, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-float, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-get, :meta {:doc "INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis.", :arglists ([obj key])}, :examples []} {:sym unchecked-inc, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-inc-int, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-multiply, :meta {:doc nil, :arglists ([&form &env & xs])}, :examples []} {:sym unchecked-multiply-int, :meta {:doc nil, :arglists ([&form &env & xs])}, :examples []} {:sym unchecked-negate, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-negate-int, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-remainder-int, :meta {:doc nil, :arglists ([x n])}, :examples []} {:sym unchecked-set, :meta {:doc "INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis.", :arglists ([obj key val])}, :examples []} {:sym unchecked-short, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-subtract, :meta {:doc nil, :arglists ([&form &env & xs])}, :examples []} {:sym unchecked-subtract-int, :meta {:doc nil, :arglists ([&form &env & xs])}, :examples []} {:sym undefined?, :meta {:doc "Return true if argument is identical to the JavaScript undefined value.", :arglists ([x])}, :examples []} {:sym unsafe-bit-and, :meta {:doc nil, :arglists ([&form &env x y] [&form &env x y & more])}, :examples []} {:sym unsafe-cast, :meta {:doc "EXPERIMENTAL: Subject to change. Unsafely cast a value to a different type.", :arglists ([t x])}, :examples []} {:sym unsigned-bit-shift-right, :meta {:doc nil, :arglists ([x n])}, :examples []} {:sym use, :meta {:doc "Like require, but referring vars specified by the mandatory\n  :only option.\n\n  Example:\n\n  The following would load the library clojure.set while referring\n  the intersection var.\n\n  (use '[clojure.set :only [intersection]])", :arglists ([&form &env & args])}, :examples []} {:sym use-macros, :meta {:doc "Similar to use but only for macros.", :arglists ([&form &env & args])}, :examples []} {:sym vector, :meta {:doc nil, :arglists ([&form &env] [&form &env & xs])}, :examples []} {:sym vswap!, :meta {:doc "Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in.", :arglists ([&form &env vol f & args])}, :examples []} {:sym when, :meta {:doc "Evaluates test. If logical true, evaluates body in an implicit do.", :arglists ([&form &env test & body])}, :examples []} {:sym when-first, :meta {:doc "bindings => x xs\n\n     Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once", :arglists ([&form &env bindings & body])}, :examples []} {:sym when-let, :meta {:doc "bindings => binding-form test\n\n     When test is true, evaluates body with binding-form bound to the value of test", :arglists ([&form &env bindings & body])}, :examples []} {:sym when-not, :meta {:doc "Evaluates test. If logical false, evaluates body in an implicit do.", :arglists ([&form &env test & body])}, :examples []} {:sym when-some, :meta {:doc "bindings => binding-form test\n\n      When test is not nil, evaluates body with binding-form bound to the\n      value of test", :arglists ([&form &env bindings & body])}, :examples []} {:sym while, :meta {:doc "Repeatedly executes body while test expression is true. Presumes\n     some side-effect will cause test to become false/nil. Returns nil", :arglists ([&form &env test & body])}, :examples []} {:sym with-out-str, :meta {:doc "Evaluates exprs in a context in which *print-fn* is bound to .append\n  on a fresh StringBuffer.  Returns the string created by any nested\n  printing calls.", :arglists ([&form &env & body])}, :examples []} {:sym with-redefs, :meta {:doc "binding => var-symbol temp-value-expr\n\n  Temporarily redefines vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its var.  After the body is\n  executed, the root values of all the vars will be set back to their\n  old values. Useful for mocking out functions during testing.", :arglists ([&form &env bindings & body])}, :examples []} {:sym zero?, :meta {:doc nil, :arglists ([x])}, :examples []}], lightmod.init [{:sym clj-logo, :meta {:doc nil, :arglists nil}, :examples []} {:sym construct-hud-node, :meta {:doc nil, :arglists ([{:keys [type warnings exception], :as messages}])}, :examples []} {:sym current-ns, :meta {:doc nil, :arglists nil}, :examples []} {:sym eval-code, :meta {:doc nil, :arglists ([path code])}, :examples []} {:sym form->serializable, :meta {:doc nil, :arglists ([form])}, :examples []} {:sym read-logo, :meta {:doc nil, :arglists ([])}, :examples []}], cljs.core.async.impl.ioc-macros [{:sym aset-all!, :meta {:doc nil, :arglists ([arr & more])}, :examples []} {:sym gen-plan, :meta {:doc "Allows a user to define a state monad binding plan.\n\n  (gen-plan\n    [_ (assoc-in-plan [:foo :bar] 42)\n     val (get-in-plan [:foo :bar])]\n    val)", :arglists ([binds id-expr])}, :examples []}], cljs.analyzer.macros [{:sym allowing-redef, :meta {:doc nil, :arglists ([& body])}, :examples []} {:sym disallowing-ns*, :meta {:doc nil, :arglists ([& body])}, :examples []} {:sym disallowing-recur, :meta {:doc nil, :arglists ([& body])}, :examples []} {:sym no-warn, :meta {:doc nil, :arglists ([& body])}, :examples []} {:sym with-core-macros, :meta {:doc nil, :arglists ([path & body])}, :examples []} {:sym with-core-macros-file, :meta {:doc nil, :arglists ([path & body])}, :examples []} {:sym with-warning-handlers, :meta {:doc nil, :arglists ([handlers & body])}, :examples []} {:sym wrapping-errors, :meta {:doc nil, :arglists ([env & body])}, :examples []}], dynadoc.example [{:sym defexample, :meta {:doc "Defines one example code block for a symbol or an arbitrary\n  piece of Clojure data. If `k` is not a namespace-qualified symbol or\n  keyword, it will be associated with the current namespace.", :arglists ([k & args])}, :examples []} {:sym defexamples, :meta {:doc "Defines multiple example code blocks for a symbol or an arbitrary\n  piece of Clojure data. If `k` is not a namespace-qualified symbol or\n  keyword, it will be associated with the current namespace.", :arglists ([k & examples])}, :examples []}], cljs.tools.reader [{:sym *alias-map*, :meta {:doc "Map from ns alias to ns, if non-nil, it will be used to resolve read-time\n   ns aliases.\n\n   Defaults to nil", :arglists nil}, :examples []} {:sym *data-readers*, :meta {:doc "Map from reader tag symbols to data reader Vars.\n  Reader tags without namespace qualifiers are reserved for Clojure.\n  This light version of tools.reader has no implementation for default\n  reader tags such as #inst and #uuid.", :arglists nil}, :examples []} {:sym *default-data-reader-fn*, :meta {:doc "When no data reader is found for a tag and *default-data-reader-fn*\n  is non-nil, it will be called with two arguments, the tag and the value.\n  If *default-data-reader-fn* is nil (the default value), an exception\n  will be thrown for the unknown tag.", :arglists nil}, :examples []} {:sym *read-delim*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *suppress-read*, :meta {:doc nil, :arglists nil}, :examples []} {:sym bool?, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym default-data-readers, :meta {:doc "Default map of data reader functions provided by Clojure.\n  May be overridden by binding *data-readers*", :arglists nil}, :examples []} {:sym map-func, :meta {:doc "Decide which map type to use, array-map if less than 16 elements", :arglists ([coll])}, :examples []} {:sym read, :meta {:doc "Reads the first object from an IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true.\n   Otherwise returns sentinel. If no stream is providen, *in* will be used.\n\n   Opts is a persistent map with valid keys:\n    :read-cond - :allow to process reader conditionals, or\n                 :preserve to keep all branches\n    :features - persistent set of feature keywords for reader conditionals\n    :eof - on eof, return value unless :eofthrow, then throw.\n           if not specified, will throw\n\n   To read data structures only, use clojure.tools.reader.edn/read\n\n   Note that the function signature of clojure.tools.reader/read and\n   clojure.tools.reader.edn/read is not the same for eof-handling", :arglists ([reader] [{eof :eof, :as opts, :or {eof :eofthrow}} reader] [reader eof-error? sentinel])}, :examples []} {:sym read-regex, :meta {:doc nil, :arglists ([rdr ch opts pending-forms])}, :examples []} {:sym read-string, :meta {:doc "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   To read data structures only, use clojure.tools.reader.edn/read-string\n\n   Note that the function signature of clojure.tools.reader/read-string and\n   clojure.tools.reader.edn/read-string is not the same for eof-handling", :arglists ([s] [opts s])}, :examples []} {:sym resolve-symbol, :meta {:doc "Resolve a symbol s into its fully qualified namespace version", :arglists ([s])}, :examples []} {:sym sb, :meta {:doc nil, :arglists nil}, :examples []}], cljs.tools.reader.impl.errors [{:sym eof-error, :meta {:doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :arglists ([rdr & msgs])}, :examples []} {:sym illegal-arg-error, :meta {:doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :arglists ([rdr & msgs])}, :examples []} {:sym reader-error, :meta {:doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :arglists ([rdr & msgs])}, :examples []} {:sym throw-bad-char, :meta {:doc nil, :arglists ([rdr kind ch])}, :examples []} {:sym throw-bad-dispatch, :meta {:doc nil, :arglists ([rdr ch])}, :examples []} {:sym throw-bad-escape-char, :meta {:doc nil, :arglists ([rdr ch])}, :examples []} {:sym throw-bad-metadata, :meta {:doc nil, :arglists ([rdr x])}, :examples []} {:sym throw-bad-metadata-target, :meta {:doc nil, :arglists ([rdr target])}, :examples []} {:sym throw-bad-ns, :meta {:doc nil, :arglists ([rdr ns-name])}, :examples []} {:sym throw-bad-octal-number, :meta {:doc nil, :arglists ([rdr])}, :examples []} {:sym throw-bad-reader-tag, :meta {:doc nil, :arglists ([rdr tag])}, :examples []} {:sym throw-dup-keys, :meta {:doc nil, :arglists ([rdr kind ks])}, :examples []} {:sym throw-eof-at-dispatch, :meta {:doc nil, :arglists ([rdr])}, :examples []} {:sym throw-eof-at-start, :meta {:doc nil, :arglists ([rdr kind])}, :examples []} {:sym throw-eof-delimited, :meta {:doc nil, :arglists ([rdr kind column line] [rdr kind line column n])}, :examples []} {:sym throw-eof-error, :meta {:doc nil, :arglists ([rdr line])}, :examples []} {:sym throw-eof-in-character, :meta {:doc nil, :arglists ([rdr])}, :examples []} {:sym throw-eof-reading, :meta {:doc nil, :arglists ([rdr kind & start])}, :examples []} {:sym throw-feature-not-keyword, :meta {:doc nil, :arglists ([rdr feature])}, :examples []} {:sym throw-invalid, :meta {:doc nil, :arglists ([rdr kind token])}, :examples []} {:sym throw-invalid-character-literal, :meta {:doc nil, :arglists ([rdr token])}, :examples []} {:sym throw-invalid-number, :meta {:doc nil, :arglists ([rdr token])}, :examples []} {:sym throw-invalid-octal-len, :meta {:doc nil, :arglists ([rdr token])}, :examples []} {:sym throw-invalid-unicode-char, :meta {:doc nil, :arglists ([rdr token])}, :examples []} {:sym throw-invalid-unicode-digit, :meta {:doc nil, :arglists ([rdr ch])}, :examples []} {:sym throw-invalid-unicode-digit-in-token, :meta {:doc nil, :arglists ([rdr ch token])}, :examples []} {:sym throw-invalid-unicode-escape, :meta {:doc nil, :arglists ([rdr ch])}, :examples []} {:sym throw-invalid-unicode-len, :meta {:doc nil, :arglists ([rdr actual expected])}, :examples []} {:sym throw-invalid-unicode-literal, :meta {:doc nil, :arglists ([rdr token])}, :examples []} {:sym throw-no-dispatch, :meta {:doc nil, :arglists ([rdr ch])}, :examples []} {:sym throw-ns-map-no-map, :meta {:doc nil, :arglists ([rdr ns-name])}, :examples []} {:sym throw-odd-map, :meta {:doc nil, :arglists ([rdr line col elements])}, :examples []} {:sym throw-single-colon, :meta {:doc nil, :arglists ([rdr])}, :examples []} {:sym throw-unknown-reader-tag, :meta {:doc nil, :arglists ([rdr tag])}, :examples []} {:sym throw-unmatch-delimiter, :meta {:doc nil, :arglists ([rdr ch])}, :examples []} {:sym throw-unsupported-character, :meta {:doc nil, :arglists ([rdr token])}, :examples []}], cljs.js [{:sym *eval-fn*, :meta {:doc "Each runtime environment provides various ways to eval JavaScript\n  source. Whatever function *eval-fn* is bound to will be passed a map\n  containing the following keys:\n\n  :source - the source of the library (string)\n  :name   - used to unique identify the script (symbol)\n  :cache  - if the source was originally ClojureScript, will be given the\n            analysis cache.\n\n  The result of evaluation should be the return value.", :arglists nil}, :examples []} {:sym *load-fn*, :meta {:doc "Each runtime environment provides a different way to load a library.\n  Whatever function *load-fn* is bound to will be passed two arguments - a\n  map and a callback function: The map will have the following keys:\n\n  :name   - the name of the library (a symbol)\n  :macros - modifier signaling a macros namespace load\n  :path   - munged relative library path (a string)\n\n  It is up to the implementor to correctly resolve the corresponding .cljs,\n  .cljc, or .js resource (the order must be respected). If :macros is true\n  resolution should only consider .clj or .cljc resources (the order must be\n  respected). Upon resolution the callback should be invoked with a map\n  containing the following keys:\n\n  :lang       - the language, :clj or :js\n  :source     - the source of the library (a string)\n  :file       - optional, the file path, it will be added to AST's :file keyword\n                (but not in :meta)\n  :cache      - optional, if a :clj namespace has been precompiled to :js, can\n                give an analysis cache for faster loads.\n  :source-map - optional, if a :clj namespace has been precompiled to :js, can\n                give a V3 source map JSON\n\n  If the resource could not be resolved, the callback should be invoked with\n  nil.", :arglists nil}, :examples []} {:sym *loaded*, :meta {:doc nil, :arglists nil}, :examples []} {:sym analyze-str, :meta {:doc "Analyze ClojureScript source. The compiler state will be populated with\n   the results of analyzes. The parameters:\n\n   state (atom)\n     the compiler state\n\n   source (string)\n     the ClojureScript source\n\n   name (symbol or string)\n     optional, the name of the source\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false).\n                          Defaults to false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:expr`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value, the actual value is not meaningful. If unsuccessful the\n     map will contain a key :error with an ex-info instance describing the cause\n     of failure.", :arglists ([state source cb] [state source name cb] [state source name opts cb])}, :examples []} {:sym compile-str, :meta {:doc "Compile ClojureScript source into JavaScript. The parameters:\n\n   state (atom)\n     the compiler state\n\n   source (string)\n     the ClojureScript source\n\n   name (symbol or string)\n     optional, the name of the source\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false). Default\n                          is false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:expr`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value with the compilation result (string). If unsuccessful the map\n     will contain a key :error with an ex-info instance describing the cause\n     of failure.", :arglists ([state source cb] [state source name cb] [state source name opts cb])}, :examples []} {:sym dump-core, :meta {:doc nil, :arglists ([])}, :examples []} {:sym empty-state, :meta {:doc "Construct an empty compiler state. Required to invoke analyze, compile,\n   eval and eval-str.", :arglists ([] [init])}, :examples []} {:sym eval, :meta {:doc "Evaluate a single ClojureScript form. The parameters:\n\n   state (atom)\n     the compiler state\n\n   form (s-expr)\n     the ClojureScript source\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false). Default\n                          is false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:expr`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value with the result of evalution. If unsuccessful the map will\n     contain a key :error with an ex-info instance describing the cause of\n     failure.", :arglists ([state form cb] [state form opts cb])}, :examples []} {:sym eval-str, :meta {:doc "Evalute ClojureScript source given as a string. The parameters:\n\n  state (atom)\n    the compiler state\n\n  source (string)\n    the ClojureScript source\n\n  name (symbol or string)\n    optional, the name of the source\n\n  opts (map)\n    compilation options.\n\n    :eval             - eval function to invoke, see *eval-fn*\n    :load             - library resolution function, see *load-fn*\n    :source-map       - set to true to generate inline source map information\n    :cache-source     - optional, a function to run side-effects with the\n                        compilation result prior to actual evalution. This function\n                        takes two arguments, the first is the eval map, the source\n                        will be under :source. The second argument is a callback of\n                        one argument. If an error occurs an :error key should be\n                        supplied.\n    :def-emits-var    - sets whether def (and derived) forms return either a Var\n                        (if set to true) or the def init value (if false). Default\n                        is false.\n    :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                        to aget/aset. Logs for incorrect values if :warn, throws if\n                        :error. Defaults to false.\n    :static-fns       - employ static dispatch to specific function arities in\n                        emitted JavaScript, as opposed to making use of the\n                        `call` construct. Defaults to false.\n    :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                        unknown functions, but instead direct invokes via\n                        `f(a0,a1...)`. Defaults to `false`.\n    :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                        at the moment.\n    :ns               - optional, the namespace in which to evaluate the source.\n    :verbose          - optional, emit details from compiler activity. Defaults to\n                        false.\n    :context          - optional, sets the context for the source. Possible values\n                     are `:expr`, `:statement` and `:return`. Defaults to\n                      `:expr`.\n\n  cb (function)\n    callback, will be invoked with a map. If succesful the map will contain\n    a :value key with the result of evaluation and :ns the current namespace.\n    If unsuccessful will contain a :error key with an ex-info instance describing\n    the cause of failure.", :arglists ([state source cb] [state source name cb] [state source name opts cb])}, :examples []} {:sym file->ns, :meta {:doc nil, :arglists ([file])}, :examples []} {:sym js-eval, :meta {:doc "A default JavaScript evaluation function.", :arglists ([{:keys [source], :as resource}])}, :examples []} {:sym load-analysis-cache!, :meta {:doc nil, :arglists ([state ns cache])}, :examples []} {:sym load-source-map!, :meta {:doc nil, :arglists ([state ns sm-json])}, :examples []} {:sym ns->relpath, :meta {:doc "Given a namespace as a symbol return the relative path sans extension", :arglists ([ns-sym])}, :examples []} {:sym require, :meta {:doc nil, :arglists ([name cb] [name opts cb] [bound-vars name opts cb] [bound-vars name reload opts cb])}, :examples []} {:sym with-state, :meta {:doc nil, :arglists ([state & body])}, :examples []}], cljs.core [{:sym *, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists ([] [x] [x y] [x y & more])}, :examples []} {:sym *1, :meta {:doc "bound in a repl thread to the most recent value printed", :arglists nil}, :examples []} {:sym *2, :meta {:doc "bound in a repl thread to the second most recent value printed", :arglists nil}, :examples []} {:sym *3, :meta {:doc "bound in a repl thread to the third most recent value printed", :arglists nil}, :examples []} {:sym *assert*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *clojurescript-version*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *command-line-args*, :meta {:doc "A sequence of the supplied command line arguments, or nil if\n  none were supplied", :arglists nil}, :examples []} {:sym *e, :meta {:doc "bound in a repl thread to the most recent exception caught by the repl", :arglists nil}, :examples []} {:sym *flush-on-newline*, :meta {:doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true.", :arglists nil}, :examples []} {:sym *loaded-libs*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *main-cli-fn*, :meta {:doc "When compiled for a command-line target, whatever function\n  *main-cli-fn* is set to will be called with the command-line\n  argv as arguments", :arglists nil}, :examples []} {:sym *ns*, :meta {:doc "Var bound to the current namespace. Only used for bootstrapping.", :arglists nil}, :examples []} {:sym *out*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *print-dup*, :meta {:doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.", :arglists nil}, :examples []} {:sym *print-err-fn*, :meta {:doc "Each runtime environment provides a different way to print error output.\n  Whatever function *print-err-fn* is bound to will be passed any\n  Strings which should be printed.", :arglists nil}, :examples []} {:sym *print-fn*, :meta {:doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.", :arglists nil}, :examples []} {:sym *print-fn-bodies*, :meta {:doc "*print-fns-bodies* controls whether functions print their source or\n    only their names.", :arglists nil}, :examples []} {:sym *print-length*, :meta {:doc "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit.", :arglists nil}, :examples []} {:sym *print-level*, :meta {:doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.", :arglists nil}, :examples []} {:sym *print-meta*, :meta {:doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false.", :arglists nil}, :examples []} {:sym *print-namespace-maps*, :meta {:doc "*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax.\n\n  Defaults to false, but the REPL binds it to true.", :arglists nil}, :examples []} {:sym *print-newline*, :meta {:doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects.", :arglists nil}, :examples []} {:sym *print-readably*, :meta {:doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true", :arglists nil}, :examples []} {:sym *target*, :meta {:doc "Var bound to the name value of the compiler build :target option.\n  For example, if the compiler build :target is :nodejs, *target* will be bound\n  to \"nodejs\". *target* is a Google Closure define and can be set by compiler\n  :closure-defines option.", :arglists nil}, :examples []} {:sym *unchecked-arrays*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *unchecked-if*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *warn-on-infer*, :meta {:doc nil, :arglists nil}, :examples []} {:sym +, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists ([] [x] [x y] [x y & more])}, :examples []} {:sym -, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists ([x] [x y] [x y & more])}, :examples []} {:sym ->, :meta {:doc "Threads the expr through the forms. Inserts x as the\n  second item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  second item in second form, etc.", :arglists ([x & forms])}, :examples []} {:sym ->>, :meta {:doc "Threads the expr through the forms. Inserts x as the\n  last item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  last item in second form, etc.", :arglists ([x & forms])}, :examples []} {:sym ->ArrayChunk, :meta {:doc nil, :arglists ([arr off end])}, :examples []} {:sym ->ArrayIter, :meta {:doc nil, :arglists ([arr i])}, :examples []} {:sym ->ArrayList, :meta {:doc nil, :arglists ([arr])}, :examples []} {:sym ->ArrayNode, :meta {:doc nil, :arglists ([edit cnt arr])}, :examples []} {:sym ->ArrayNodeIterator, :meta {:doc nil, :arglists ([arr i next-iter])}, :examples []} {:sym ->ArrayNodeSeq, :meta {:doc nil, :arglists ([meta nodes i s __hash])}, :examples []} {:sym ->Atom, :meta {:doc nil, :arglists ([state meta validator watches])}, :examples []} {:sym ->BitmapIndexedNode, :meta {:doc nil, :arglists ([edit bitmap arr])}, :examples []} {:sym ->BlackNode, :meta {:doc nil, :arglists ([key val left right __hash])}, :examples []} {:sym ->Box, :meta {:doc nil, :arglists ([val])}, :examples []} {:sym ->ChunkBuffer, :meta {:doc nil, :arglists ([buf end])}, :examples []} {:sym ->ChunkedCons, :meta {:doc nil, :arglists ([chunk more meta __hash])}, :examples []} {:sym ->ChunkedSeq, :meta {:doc nil, :arglists ([vec node i off meta __hash])}, :examples []} {:sym ->Cons, :meta {:doc nil, :arglists ([meta first rest __hash])}, :examples []} {:sym ->Delay, :meta {:doc nil, :arglists ([f value])}, :examples []} {:sym ->ES6EntriesIterator, :meta {:doc nil, :arglists ([s])}, :examples []} {:sym ->ES6Iterator, :meta {:doc nil, :arglists ([s])}, :examples []} {:sym ->ES6IteratorSeq, :meta {:doc nil, :arglists ([value iter _rest])}, :examples []} {:sym ->ES6SetEntriesIterator, :meta {:doc nil, :arglists ([s])}, :examples []} {:sym ->Eduction, :meta {:doc nil, :arglists ([xform coll])}, :examples []} {:sym ->Empty, :meta {:doc nil, :arglists ([])}, :examples []} {:sym ->EmptyList, :meta {:doc nil, :arglists ([meta])}, :examples []} {:sym ->HashCollisionNode, :meta {:doc nil, :arglists ([edit collision-hash cnt arr])}, :examples []} {:sym ->HashMapIter, :meta {:doc nil, :arglists ([nil-val root-iter seen])}, :examples []} {:sym ->HashSetIter, :meta {:doc nil, :arglists ([iter])}, :examples []} {:sym ->IndexedSeq, :meta {:doc nil, :arglists ([arr i meta])}, :examples []} {:sym ->IndexedSeqIterator, :meta {:doc nil, :arglists ([arr i])}, :examples []} {:sym ->KeySeq, :meta {:doc nil, :arglists ([mseq _meta])}, :examples []} {:sym ->Keyword, :meta {:doc nil, :arglists ([ns name fqn _hash])}, :examples []} {:sym ->LazySeq, :meta {:doc nil, :arglists ([meta fn s __hash])}, :examples []} {:sym ->List, :meta {:doc nil, :arglists ([meta first rest count __hash])}, :examples []} {:sym ->Many, :meta {:doc nil, :arglists ([vals])}, :examples []} {:sym ->MapEntry, :meta {:doc nil, :arglists ([key val __hash])}, :examples []} {:sym ->MetaFn, :meta {:doc nil, :arglists ([afn meta])}, :examples []} {:sym ->MultiFn, :meta {:doc nil, :arglists ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy])}, :examples []} {:sym ->MultiIterator, :meta {:doc nil, :arglists ([iters])}, :examples []} {:sym ->Namespace, :meta {:doc nil, :arglists ([obj name])}, :examples []} {:sym ->NeverEquiv, :meta {:doc nil, :arglists ([])}, :examples []} {:sym ->NodeIterator, :meta {:doc nil, :arglists ([arr i next-entry next-iter])}, :examples []} {:sym ->NodeSeq, :meta {:doc nil, :arglists ([meta nodes i s __hash])}, :examples []} {:sym ->ObjMap, :meta {:doc nil, :arglists ([meta keys strobj update-count __hash])}, :examples []} {:sym ->PersistentArrayMap, :meta {:doc nil, :arglists ([meta cnt arr __hash])}, :examples []} {:sym ->PersistentArrayMapIterator, :meta {:doc nil, :arglists ([arr i cnt])}, :examples []} {:sym ->PersistentArrayMapSeq, :meta {:doc nil, :arglists ([arr i _meta])}, :examples []} {:sym ->PersistentHashMap, :meta {:doc nil, :arglists ([meta cnt root has-nil? nil-val __hash])}, :examples []} {:sym ->PersistentHashSet, :meta {:doc nil, :arglists ([meta hash-map __hash])}, :examples []} {:sym ->PersistentQueue, :meta {:doc nil, :arglists ([meta count front rear __hash])}, :examples []} {:sym ->PersistentQueueIter, :meta {:doc nil, :arglists ([fseq riter])}, :examples []} {:sym ->PersistentQueueSeq, :meta {:doc nil, :arglists ([meta front rear __hash])}, :examples []} {:sym ->PersistentTreeMap, :meta {:doc nil, :arglists ([comp tree cnt meta __hash])}, :examples []} {:sym ->PersistentTreeMapSeq, :meta {:doc nil, :arglists ([meta stack ascending? cnt __hash])}, :examples []} {:sym ->PersistentTreeSet, :meta {:doc nil, :arglists ([meta tree-map __hash])}, :examples []} {:sym ->PersistentVector, :meta {:doc nil, :arglists ([meta cnt shift root tail __hash])}, :examples []} {:sym ->RSeq, :meta {:doc nil, :arglists ([ci i meta])}, :examples []} {:sym ->Range, :meta {:doc nil, :arglists ([meta start end step __hash])}, :examples []} {:sym ->RangeIterator, :meta {:doc nil, :arglists ([i end step])}, :examples []} {:sym ->RangedIterator, :meta {:doc nil, :arglists ([i base arr v start end])}, :examples []} {:sym ->RecordIter, :meta {:doc nil, :arglists ([i record base-count fields ext-map-iter])}, :examples []} {:sym ->RedNode, :meta {:doc nil, :arglists ([key val left right __hash])}, :examples []} {:sym ->Reduced, :meta {:doc nil, :arglists ([val])}, :examples []} {:sym ->SeqIter, :meta {:doc nil, :arglists ([_seq _next])}, :examples []} {:sym ->Single, :meta {:doc nil, :arglists ([val])}, :examples []} {:sym ->StringBufferWriter, :meta {:doc nil, :arglists ([sb])}, :examples []} {:sym ->StringIter, :meta {:doc nil, :arglists ([s i])}, :examples []} {:sym ->Subvec, :meta {:doc nil, :arglists ([meta v start end __hash])}, :examples []} {:sym ->Symbol, :meta {:doc nil, :arglists ([ns name str _hash _meta])}, :examples []} {:sym ->TaggedLiteral, :meta {:doc nil, :arglists ([tag form])}, :examples []} {:sym ->TransformerIterator, :meta {:doc nil, :arglists ([buffer _next completed xf sourceIter multi])}, :examples []} {:sym ->TransientArrayMap, :meta {:doc nil, :arglists ([editable? len arr])}, :examples []} {:sym ->TransientHashMap, :meta {:doc nil, :arglists ([edit root count has-nil? nil-val])}, :examples []} {:sym ->TransientHashSet, :meta {:doc nil, :arglists ([transient-map])}, :examples []} {:sym ->TransientVector, :meta {:doc nil, :arglists ([cnt shift root tail])}, :examples []} {:sym ->UUID, :meta {:doc nil, :arglists ([uuid __hash])}, :examples []} {:sym ->ValSeq, :meta {:doc nil, :arglists ([mseq _meta])}, :examples []} {:sym ->Var, :meta {:doc nil, :arglists ([val sym _meta])}, :examples []} {:sym ->VectorNode, :meta {:doc nil, :arglists ([edit arr])}, :examples []} {:sym ->Volatile, :meta {:doc nil, :arglists ([state])}, :examples []} {:sym -add-method, :meta {:doc nil, :arglists ([mf dispatch-val method])}, :examples []} {:sym -add-watch, :meta {:doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.", :arglists ([this key f])}, :examples []} {:sym -as-transient, :meta {:doc "Returns a new, transient version of the collection, in constant time.", :arglists ([coll])}, :examples []} {:sym -assoc, :meta {:doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it.", :arglists ([coll k v])}, :examples []} {:sym -assoc!, :meta {:doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it.", :arglists ([tcoll key val])}, :examples []} {:sym -assoc-n, :meta {:doc "Returns a new vector with value val added at position n.", :arglists ([coll n val])}, :examples []} {:sym -assoc-n!, :meta {:doc "Returns tcoll with value val added at position n.", :arglists ([tcoll n val])}, :examples []} {:sym -chunked-first, :meta {:doc "Returns the first chunk in coll.", :arglists ([coll])}, :examples []} {:sym -chunked-next, :meta {:doc "Returns a new collection of coll without the first chunk.", :arglists ([coll])}, :examples []} {:sym -chunked-rest, :meta {:doc "Return a new collection of coll with the first chunk removed.", :arglists ([coll])}, :examples []} {:sym -clj->js, :meta {:doc "Recursively transforms clj values to JavaScript", :arglists ([x])}, :examples []} {:sym -clone, :meta {:doc "Creates a clone of value.", :arglists ([value])}, :examples []} {:sym -comparator, :meta {:doc "Returns the comparator for coll.", :arglists ([coll])}, :examples []} {:sym -compare, :meta {:doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y.", :arglists ([x y])}, :examples []} {:sym -conj, :meta {:doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)", :arglists ([coll o])}, :examples []} {:sym -conj!, :meta {:doc "Adds value val to tcoll and returns tcoll.", :arglists ([tcoll val])}, :examples []} {:sym -contains-key?, :meta {:doc "Returns true if k is a key in coll.", :arglists ([coll k])}, :examples []} {:sym -count, :meta {:doc "Calculates the count of coll in constant time. Used by cljs.core/count.", :arglists ([coll])}, :examples []} {:sym -default-dispatch-val, :meta {:doc nil, :arglists ([mf])}, :examples []} {:sym -deref, :meta {:doc "Returns the value of the reference o.", :arglists ([o])}, :examples []} {:sym -deref-with-timeout, :meta {:doc nil, :arglists ([o msec timeout-val])}, :examples []} {:sym -disjoin, :meta {:doc "Returns a new collection of coll that does not contain v.", :arglists ([coll v])}, :examples []} {:sym -disjoin!, :meta {:doc "Returns tcoll without v.", :arglists ([tcoll v])}, :examples []} {:sym -dispatch-fn, :meta {:doc nil, :arglists ([mf])}, :examples []} {:sym -dissoc, :meta {:doc "Returns a new collection of coll without the mapping for key k.", :arglists ([coll k])}, :examples []} {:sym -dissoc!, :meta {:doc "Returns a new transient collection of tcoll without the mapping for key.", :arglists ([tcoll key])}, :examples []} {:sym -drop-first, :meta {:doc "Return a new chunk of coll with the first item removed.", :arglists ([coll])}, :examples []} {:sym -empty, :meta {:doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty.", :arglists ([coll])}, :examples []} {:sym -entry-key, :meta {:doc "Returns the key for entry.", :arglists ([coll entry])}, :examples []} {:sym -equiv, :meta {:doc "Returns true if o and other are equal, false otherwise.", :arglists ([o other])}, :examples []} {:sym -find, :meta {:doc "Returns the map entry for key, or nil if key not present.", :arglists ([coll k])}, :examples []} {:sym -first, :meta {:doc "Returns the first item in the collection coll. Used by cljs.core/first.", :arglists ([coll])}, :examples []} {:sym -flush, :meta {:doc "Flush writer.", :arglists ([writer])}, :examples []} {:sym -get-method, :meta {:doc nil, :arglists ([mf dispatch-val])}, :examples []} {:sym -hash, :meta {:doc "Returns the hash code of o.", :arglists ([o])}, :examples []} {:sym -invoke, :meta {:doc nil, :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest])}, :examples []} {:sym -iterator, :meta {:doc "Returns an iterator for coll.", :arglists ([coll])}, :examples []} {:sym -js->clj, :meta {:doc "Transforms JavaScript values to Clojure", :arglists ([x options])}, :examples []} {:sym -key, :meta {:doc "Returns the key of the map entry.", :arglists ([coll])}, :examples []} {:sym -key->js, :meta {:doc "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)", :arglists ([x])}, :examples []} {:sym -kv-reduce, :meta {:doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments.", :arglists ([coll f init])}, :examples []} {:sym -lookup, :meta {:doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned.", :arglists ([o k] [o k not-found])}, :examples []} {:sym -meta, :meta {:doc "Returns the metadata of object o.", :arglists ([o])}, :examples []} {:sym -methods, :meta {:doc nil, :arglists ([mf])}, :examples []} {:sym -name, :meta {:doc "Returns the name String of x.", :arglists ([x])}, :examples []} {:sym -namespace, :meta {:doc "Returns the namespace String of x.", :arglists ([x])}, :examples []} {:sym -next, :meta {:doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil", :arglists ([coll])}, :examples []} {:sym -notify-watches, :meta {:doc "Calls all watchers with this, oldval and newval.", :arglists ([this oldval newval])}, :examples []} {:sym -nth, :meta {:doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied.", :arglists ([coll n] [coll n not-found])}, :examples []} {:sym -peek, :meta {:doc "Returns the item from the top of the stack. Is used by cljs.core/peek.", :arglists ([coll])}, :examples []} {:sym -persistent!, :meta {:doc "Creates a persistent data structure from tcoll and returns it.", :arglists ([tcoll])}, :examples []} {:sym -pop, :meta {:doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop.", :arglists ([coll])}, :examples []} {:sym -pop!, :meta {:doc "Returns tcoll with the last item removed from it.", :arglists ([tcoll])}, :examples []} {:sym -pr-writer, :meta {:doc nil, :arglists ([o writer opts])}, :examples []} {:sym -prefer-method, :meta {:doc nil, :arglists ([mf dispatch-val dispatch-val-y])}, :examples []} {:sym -prefers, :meta {:doc nil, :arglists ([mf])}, :examples []} {:sym -realized?, :meta {:doc "Returns true if a value for x has been produced, false otherwise.", :arglists ([x])}, :examples []} {:sym -reduce, :meta {:doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc.", :arglists ([coll f] [coll f start])}, :examples []} {:sym -remove-method, :meta {:doc nil, :arglists ([mf dispatch-val])}, :examples []} {:sym -remove-watch, :meta {:doc "Removes watcher that corresponds to key from this.", :arglists ([this key])}, :examples []} {:sym -reset, :meta {:doc nil, :arglists ([mf])}, :examples []} {:sym -reset!, :meta {:doc "Sets the value of o to new-value.", :arglists ([o new-value])}, :examples []} {:sym -rest, :meta {:doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()", :arglists ([coll])}, :examples []} {:sym -rseq, :meta {:doc "Returns a seq of the items in coll in reversed order.", :arglists ([coll])}, :examples []} {:sym -seq, :meta {:doc "Returns a seq of o, or nil if o is empty.", :arglists ([o])}, :examples []} {:sym -sorted-seq, :meta {:doc "Returns a sorted seq from coll in either ascending or descending order.", :arglists ([coll ascending?])}, :examples []} {:sym -sorted-seq-from, :meta {:doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)", :arglists ([coll k ascending?])}, :examples []} {:sym -swap!, :meta {:doc "Swaps the value of o to be (apply f current-value-of-atom args).", :arglists ([o f] [o f a] [o f a b] [o f a b xs])}, :examples []} {:sym -val, :meta {:doc "Returns the value of the map entry.", :arglists ([coll])}, :examples []} {:sym -vreset!, :meta {:doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value.", :arglists ([o new-value])}, :examples []} {:sym -with-meta, :meta {:doc "Returns a new object with value of o and metadata meta added to it.", :arglists ([o meta])}, :examples []} {:sym -write, :meta {:doc "Writes s with writer and returns the result.", :arglists ([writer s])}, :examples []} {:sym .., :meta {:doc "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n  Expands into a member access (.) of the first member on the first\n  argument, followed by the next member on the result, etc. For\n  instance:\n\n  (.. System (getProperties) (get \"os.name\"))\n\n  expands to:\n\n  (. (. System (getProperties)) (get \"os.name\"))\n\n  but is easier to write, read, and understand.", :arglists ([x form] [x form & more])}, :examples []} {:sym /, :meta {:doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :arglists ([x] [x y] [x y & more])}, :examples []} {:sym <, :meta {:doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :arglists ([x] [x y] [x y & more])}, :examples []} {:sym <=, :meta {:doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :arglists ([x] [x y] [x y & more])}, :examples []} {:sym =, :meta {:doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.", :arglists ([x] [x y] [x y & more])}, :examples []} {:sym ==, :meta {:doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.", :arglists ([x] [x y] [x y & more])}, :examples []} {:sym >, :meta {:doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :arglists ([x] [x y] [x y & more])}, :examples []} {:sym >=, :meta {:doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :arglists ([x] [x y] [x y & more])}, :examples []} {:sym APersistentVector, :meta {:doc "Marker protocol", :arglists nil}, :examples []} {:sym ASeq, :meta {:doc "Marker protocol indicating an array sequence.", :arglists nil}, :examples []} {:sym ArrayChunk, :meta {:doc nil, :arglists nil}, :examples []} {:sym ArrayIter, :meta {:doc nil, :arglists nil}, :examples []} {:sym ArrayList, :meta {:doc nil, :arglists nil}, :examples []} {:sym ArrayNode, :meta {:doc nil, :arglists nil}, :examples []} {:sym ArrayNodeIterator, :meta {:doc nil, :arglists nil}, :examples []} {:sym ArrayNodeSeq, :meta {:doc nil, :arglists nil}, :examples []} {:sym Atom, :meta {:doc nil, :arglists nil}, :examples []} {:sym BitmapIndexedNode, :meta {:doc nil, :arglists nil}, :examples []} {:sym BlackNode, :meta {:doc nil, :arglists nil}, :examples []} {:sym Box, :meta {:doc nil, :arglists nil}, :examples []} {:sym CHAR_MAP, :meta {:doc nil, :arglists nil}, :examples []} {:sym ChunkBuffer, :meta {:doc nil, :arglists nil}, :examples []} {:sym ChunkedCons, :meta {:doc nil, :arglists nil}, :examples []} {:sym ChunkedSeq, :meta {:doc nil, :arglists nil}, :examples []} {:sym Cons, :meta {:doc nil, :arglists nil}, :examples []} {:sym DEMUNGE_MAP, :meta {:doc nil, :arglists nil}, :examples []} {:sym DEMUNGE_PATTERN, :meta {:doc nil, :arglists nil}, :examples []} {:sym Delay, :meta {:doc nil, :arglists nil}, :examples []} {:sym ES6EntriesIterator, :meta {:doc nil, :arglists nil}, :examples []} {:sym ES6Iterator, :meta {:doc nil, :arglists nil}, :examples []} {:sym ES6IteratorSeq, :meta {:doc nil, :arglists nil}, :examples []} {:sym ES6SetEntriesIterator, :meta {:doc nil, :arglists nil}, :examples []} {:sym Eduction, :meta {:doc nil, :arglists nil}, :examples []} {:sym Empty, :meta {:doc nil, :arglists nil}, :examples []} {:sym EmptyList, :meta {:doc nil, :arglists nil}, :examples []} {:sym ExceptionInfo, :meta {:doc nil, :arglists ([message data cause])}, :examples []} {:sym Fn, :meta {:doc "Marker protocol", :arglists nil}, :examples []} {:sym HashCollisionNode, :meta {:doc nil, :arglists nil}, :examples []} {:sym HashMapIter, :meta {:doc nil, :arglists nil}, :examples []} {:sym HashSetIter, :meta {:doc nil, :arglists nil}, :examples []} {:sym IAssociative, :meta {:doc "Protocol for adding associativity to collections.", :arglists nil}, :examples []} {:sym IAtom, :meta {:doc "Marker protocol indicating an atom.", :arglists nil}, :examples []} {:sym IChunk, :meta {:doc "Protocol for accessing the items of a chunk.", :arglists nil}, :examples []} {:sym IChunkedNext, :meta {:doc "Protocol for accessing the chunks of a collection.", :arglists nil}, :examples []} {:sym IChunkedSeq, :meta {:doc "Protocol for accessing a collection as sequential chunks.", :arglists nil}, :examples []} {:sym ICloneable, :meta {:doc "Protocol for cloning a value.", :arglists nil}, :examples []} {:sym ICollection, :meta {:doc "Protocol for adding to a collection.", :arglists nil}, :examples []} {:sym IComparable, :meta {:doc "Protocol for values that can be compared.", :arglists nil}, :examples []} {:sym ICounted, :meta {:doc "Protocol for adding the ability to count a collection in constant time.", :arglists nil}, :examples []} {:sym IDeref, :meta {:doc "Protocol for adding dereference functionality to a reference.", :arglists nil}, :examples []} {:sym IDerefWithTimeout, :meta {:doc nil, :arglists nil}, :examples []} {:sym IEditableCollection, :meta {:doc "Protocol for collections which can transformed to transients.", :arglists nil}, :examples []} {:sym IEmptyableCollection, :meta {:doc "Protocol for creating an empty collection.", :arglists nil}, :examples []} {:sym IEncodeClojure, :meta {:doc nil, :arglists nil}, :examples []} {:sym IEncodeJS, :meta {:doc nil, :arglists nil}, :examples []} {:sym IEquiv, :meta {:doc "Protocol for adding value comparison functionality to a type.", :arglists nil}, :examples []} {:sym IFind, :meta {:doc "Protocol for implementing entry finding in collections.", :arglists nil}, :examples []} {:sym IFn, :meta {:doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2", :arglists nil}, :examples []} {:sym IHash, :meta {:doc "Protocol for adding hashing functionality to a type.", :arglists nil}, :examples []} {:sym IIndexed, :meta {:doc "Protocol for collections to provide indexed-based access to their items.", :arglists nil}, :examples []} {:sym IIterable, :meta {:doc "Protocol for iterating over a collection.", :arglists nil}, :examples []} {:sym IKVReduce, :meta {:doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv.", :arglists nil}, :examples []} {:sym IList, :meta {:doc "Marker interface indicating a persistent list", :arglists nil}, :examples []} {:sym ILookup, :meta {:doc "Protocol for looking up a value in a data structure.", :arglists nil}, :examples []} {:sym IMap, :meta {:doc "Protocol for adding mapping functionality to collections.", :arglists nil}, :examples []} {:sym IMapEntry, :meta {:doc "Protocol for examining a map entry.", :arglists nil}, :examples []} {:sym IMeta, :meta {:doc "Protocol for accessing the metadata of an object.", :arglists nil}, :examples []} {:sym IMultiFn, :meta {:doc nil, :arglists nil}, :examples []} {:sym INIT, :meta {:doc nil, :arglists nil}, :examples []} {:sym INamed, :meta {:doc "Protocol for adding a name.", :arglists nil}, :examples []} {:sym INext, :meta {:doc "Protocol for accessing the next items of a collection.", :arglists nil}, :examples []} {:sym IPending, :meta {:doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq.", :arglists nil}, :examples []} {:sym IPrintWithWriter, :meta {:doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.", :arglists nil}, :examples []} {:sym IRecord, :meta {:doc "Marker interface indicating a record object", :arglists nil}, :examples []} {:sym IReduce, :meta {:doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce.", :arglists nil}, :examples []} {:sym IReset, :meta {:doc "Protocol for adding resetting functionality.", :arglists nil}, :examples []} {:sym IReversible, :meta {:doc "Protocol for reversing a seq.", :arglists nil}, :examples []} {:sym ISeq, :meta {:doc "Protocol for collections to provide access to their items as sequences.", :arglists nil}, :examples []} {:sym ISeqable, :meta {:doc "Protocol for adding the ability to a type to be transformed into a sequence.", :arglists nil}, :examples []} {:sym ISequential, :meta {:doc "Marker interface indicating a persistent collection of sequential items", :arglists nil}, :examples []} {:sym ISet, :meta {:doc "Protocol for adding set functionality to a collection.", :arglists nil}, :examples []} {:sym ISorted, :meta {:doc "Protocol for a collection which can represent their items\n  in a sorted manner. ", :arglists nil}, :examples []} {:sym IStack, :meta {:doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures.", :arglists nil}, :examples []} {:sym ISwap, :meta {:doc "Protocol for adding swapping functionality.", :arglists nil}, :examples []} {:sym ITER_SYMBOL, :meta {:doc nil, :arglists nil}, :examples []} {:sym ITransientAssociative, :meta {:doc "Protocol for adding associativity to transient collections.", :arglists nil}, :examples []} {:sym ITransientCollection, :meta {:doc "Protocol for adding basic functionality to transient collections.", :arglists nil}, :examples []} {:sym ITransientMap, :meta {:doc "Protocol for adding mapping functionality to transient collections.", :arglists nil}, :examples []} {:sym ITransientSet, :meta {:doc "Protocol for adding set functionality to a transient collection.", :arglists nil}, :examples []} {:sym ITransientVector, :meta {:doc "Protocol for adding vector functionality to transient collections.", :arglists nil}, :examples []} {:sym IUUID, :meta {:doc "A marker protocol for UUIDs", :arglists nil}, :examples []} {:sym IVector, :meta {:doc "Protocol for adding vector functionality to collections.", :arglists nil}, :examples []} {:sym IVolatile, :meta {:doc "Protocol for adding volatile functionality.", :arglists nil}, :examples []} {:sym IWatchable, :meta {:doc "Protocol for types that can be watched. Currently only implemented by Atom.", :arglists nil}, :examples []} {:sym IWithMeta, :meta {:doc "Protocol for adding metadata to an object.", :arglists nil}, :examples []} {:sym IWriter, :meta {:doc "Protocol for writing. Currently only implemented by StringBufferWriter.", :arglists nil}, :examples []} {:sym IndexedSeq, :meta {:doc nil, :arglists nil}, :examples []} {:sym IndexedSeqIterator, :meta {:doc nil, :arglists nil}, :examples []} {:sym Inst, :meta {:doc nil, :arglists nil}, :examples []} {:sym KeySeq, :meta {:doc nil, :arglists nil}, :examples []} {:sym Keyword, :meta {:doc nil, :arglists nil}, :examples []} {:sym LazySeq, :meta {:doc nil, :arglists nil}, :examples []} {:sym List, :meta {:doc nil, :arglists nil}, :examples []} {:sym MODULE_INFOS, :meta {:doc nil, :arglists nil}, :examples []} {:sym MODULE_URIS, :meta {:doc nil, :arglists nil}, :examples []} {:sym Many, :meta {:doc nil, :arglists nil}, :examples []} {:sym MapEntry, :meta {:doc nil, :arglists nil}, :examples []} {:sym MetaFn, :meta {:doc nil, :arglists nil}, :examples []} {:sym MultiFn, :meta {:doc nil, :arglists nil}, :examples []} {:sym MultiIterator, :meta {:doc nil, :arglists nil}, :examples []} {:sym NS_CACHE, :meta {:doc "Bootstrap only.", :arglists nil}, :examples []} {:sym Namespace, :meta {:doc nil, :arglists nil}, :examples []} {:sym NeverEquiv, :meta {:doc nil, :arglists nil}, :examples []} {:sym NodeIterator, :meta {:doc nil, :arglists nil}, :examples []} {:sym NodeSeq, :meta {:doc nil, :arglists nil}, :examples []} {:sym ObjMap, :meta {:doc nil, :arglists nil}, :examples []} {:sym PROTOCOL_SENTINEL, :meta {:doc nil, :arglists nil}, :examples []} {:sym PersistentArrayMap, :meta {:doc nil, :arglists nil}, :examples []} {:sym PersistentArrayMapIterator, :meta {:doc nil, :arglists nil}, :examples []} {:sym PersistentArrayMapSeq, :meta {:doc nil, :arglists nil}, :examples []} {:sym PersistentHashMap, :meta {:doc nil, :arglists nil}, :examples []} {:sym PersistentHashSet, :meta {:doc nil, :arglists nil}, :examples []} {:sym PersistentQueue, :meta {:doc nil, :arglists nil}, :examples []} {:sym PersistentQueueIter, :meta {:doc nil, :arglists nil}, :examples []} {:sym PersistentQueueSeq, :meta {:doc nil, :arglists nil}, :examples []} {:sym PersistentTreeMap, :meta {:doc nil, :arglists nil}, :examples []} {:sym PersistentTreeMapSeq, :meta {:doc nil, :arglists nil}, :examples []} {:sym PersistentTreeSet, :meta {:doc nil, :arglists nil}, :examples []} {:sym PersistentVector, :meta {:doc nil, :arglists nil}, :examples []} {:sym RSeq, :meta {:doc nil, :arglists nil}, :examples []} {:sym Range, :meta {:doc nil, :arglists nil}, :examples []} {:sym RangeIterator, :meta {:doc nil, :arglists nil}, :examples []} {:sym RangedIterator, :meta {:doc nil, :arglists nil}, :examples []} {:sym RecordIter, :meta {:doc nil, :arglists nil}, :examples []} {:sym RedNode, :meta {:doc nil, :arglists nil}, :examples []} {:sym Reduced, :meta {:doc nil, :arglists nil}, :examples []} {:sym START, :meta {:doc nil, :arglists nil}, :examples []} {:sym SeqIter, :meta {:doc nil, :arglists nil}, :examples []} {:sym Single, :meta {:doc nil, :arglists nil}, :examples []} {:sym StringBufferWriter, :meta {:doc nil, :arglists nil}, :examples []} {:sym StringIter, :meta {:doc nil, :arglists nil}, :examples []} {:sym Subvec, :meta {:doc nil, :arglists nil}, :examples []} {:sym Symbol, :meta {:doc nil, :arglists nil}, :examples []} {:sym TaggedLiteral, :meta {:doc nil, :arglists nil}, :examples []} {:sym TransformerIterator, :meta {:doc nil, :arglists nil}, :examples []} {:sym TransientArrayMap, :meta {:doc nil, :arglists nil}, :examples []} {:sym TransientHashMap, :meta {:doc nil, :arglists nil}, :examples []} {:sym TransientHashSet, :meta {:doc nil, :arglists nil}, :examples []} {:sym TransientVector, :meta {:doc nil, :arglists nil}, :examples []} {:sym UUID, :meta {:doc nil, :arglists nil}, :examples []} {:sym ValSeq, :meta {:doc nil, :arglists nil}, :examples []} {:sym Var, :meta {:doc nil, :arglists nil}, :examples []} {:sym VectorNode, :meta {:doc nil, :arglists nil}, :examples []} {:sym Volatile, :meta {:doc nil, :arglists nil}, :examples []} {:sym aclone, :meta {:doc "Returns a javascript array, cloned from the passed in array", :arglists ([arr])}, :examples []} {:sym add-to-string-hash-cache, :meta {:doc nil, :arglists ([k])}, :examples []} {:sym add-watch, :meta {:doc "Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1", :arglists ([iref key f])}, :examples []} {:sym aget, :meta {:doc "Returns the value at the index/indices. Works on JavaScript arrays.", :arglists ([array idx] [array idx & idxs])}, :examples []} {:sym alength, :meta {:doc "Returns the length of the array. Works on arrays of all types.", :arglists ([array])}, :examples []} {:sym alter-meta!, :meta {:doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", :arglists ([iref f & args])}, :examples []} {:sym amap, :meta {:doc "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting\n  each element of ret to the evaluation of expr, returning the new\n  array ret.", :arglists ([a idx ret expr])}, :examples []} {:sym ancestors, :meta {:doc "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :arglists ([tag] [h tag])}, :examples []} {:sym and, :meta {:doc "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.", :arglists ([] [x] [x & next])}, :examples []} {:sym any?, :meta {:doc "Returns true if given any argument.", :arglists ([x])}, :examples []} {:sym apply, :meta {:doc "Applies fn f to the argument list formed by prepending intervening arguments to args.", :arglists ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args])}, :examples []} {:sym apply-to, :meta {:doc nil, :arglists ([f argc args])}, :examples []} {:sym areduce, :meta {:doc "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the\n  evaluation of expr at each step, returning ret.", :arglists ([a idx ret init expr])}, :examples []} {:sym array, :meta {:doc "Creates a new javascript array.\n@param {...*} var_args", :arglists ([var-args])}, :examples []} {:sym array-chunk, :meta {:doc nil, :arglists ([arr] [arr off] [arr off end])}, :examples []} {:sym array-index-of, :meta {:doc nil, :arglists ([arr k])}, :examples []} {:sym array-iter, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym array-list, :meta {:doc nil, :arglists ([])}, :examples []} {:sym array-map, :meta {:doc "keyval => key val\n  Returns a new array map with supplied mappings.", :arglists ([& keyvals])}, :examples []} {:sym array-seq, :meta {:doc "Create a seq from a JavaScript array.", :arglists ([array] [array i])}, :examples []} {:sym array?, :meta {:doc "Returns true if x is a JavaScript array.", :arglists ([x])}, :examples []} {:sym as->, :meta {:doc "Binds name to expr, evaluates the first form in the lexical context\n  of that binding, then binds name to that result, repeating for each\n  successive form, returning the result of the last form.", :arglists ([expr name & forms])}, :examples []} {:sym aset, :meta {:doc "Sets the value at the index/indices. Works on JavaScript arrays.\n  Returns val.", :arglists ([array idx val] [array idx idx2 & idxv])}, :examples []} {:sym assert, :meta {:doc "Evaluates expr and throws an exception if it does not evaluate to\n  logical true.", :arglists ([x] [x message])}, :examples []} {:sym assoc, :meta {:doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index.", :arglists ([coll k v] [coll k v & kvs])}, :examples []} {:sym assoc!, :meta {:doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :arglists ([tcoll key val] [tcoll key val & kvs])}, :examples []} {:sym assoc-in, :meta {:doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", :arglists ([m [k & ks] v])}, :examples []} {:sym associative?, :meta {:doc "Returns true if coll implements Associative", :arglists ([x])}, :examples []} {:sym atom, :meta {:doc "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will be come the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an Error.  If either of these error conditions\n  occur, then the value of the atom will not change.", :arglists ([x] [x & {:keys [meta validator]}])}, :examples []} {:sym binding, :meta {:doc "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.", :arglists ([bindings & body])}, :examples []} {:sym bit-and, :meta {:doc "Bitwise and", :arglists ([x y] [x y & more])}, :examples []} {:sym bit-and-not, :meta {:doc "Bitwise and with complement", :arglists ([x y] [x y & more])}, :examples []} {:sym bit-clear, :meta {:doc "Clear bit at index n", :arglists ([x n])}, :examples []} {:sym bit-count, :meta {:doc "Counts the number of bits set in n", :arglists ([v])}, :examples []} {:sym bit-flip, :meta {:doc "Flip bit at index n", :arglists ([x n])}, :examples []} {:sym bit-not, :meta {:doc "Bitwise complement", :arglists ([x])}, :examples []} {:sym bit-or, :meta {:doc "Bitwise or", :arglists ([x y] [x y & more])}, :examples []} {:sym bit-set, :meta {:doc "Set bit at index n", :arglists ([x n])}, :examples []} {:sym bit-shift-left, :meta {:doc "Bitwise shift left", :arglists ([x n])}, :examples []} {:sym bit-shift-right, :meta {:doc "Bitwise shift right", :arglists ([x n])}, :examples []} {:sym bit-shift-right-zero-fill, :meta {:doc "DEPRECATED: Bitwise shift right with zero fill", :arglists ([x n])}, :examples []} {:sym bit-test, :meta {:doc "Test bit at index n", :arglists ([x n])}, :examples []} {:sym bit-xor, :meta {:doc "Bitwise exclusive or", :arglists ([x y] [x y & more])}, :examples []} {:sym boolean, :meta {:doc "Coerce to boolean", :arglists ([x])}, :examples []} {:sym boolean?, :meta {:doc "Return true if x is a Boolean", :arglists ([x])}, :examples []} {:sym booleans, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym bounded-count, :meta {:doc "If coll is counted? returns its count, else will count at most the first n\n   elements of coll using its seq", :arglists ([n coll])}, :examples []} {:sym butlast, :meta {:doc "Return a seq of all but the last item in coll, in linear time", :arglists ([s])}, :examples []} {:sym byte, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym bytes, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym caching-hash, :meta {:doc nil, :arglists ([coll hash-fn hash-key])}, :examples []} {:sym case, :meta {:doc "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an Error is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (ClojureScript) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.", :arglists ([e & clauses])}, :examples []} {:sym cat, :meta {:doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.", :arglists ([rf])}, :examples []} {:sym char, :meta {:doc "Coerce to char", :arglists ([x])}, :examples []} {:sym char?, :meta {:doc "Returns true if x is a JavaScript string of length one.", :arglists ([x])}, :examples []} {:sym chars, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym chunk, :meta {:doc nil, :arglists ([b])}, :examples []} {:sym chunk-append, :meta {:doc nil, :arglists ([b x])}, :examples []} {:sym chunk-buffer, :meta {:doc nil, :arglists ([capacity])}, :examples []} {:sym chunk-cons, :meta {:doc nil, :arglists ([chunk rest])}, :examples []} {:sym chunk-first, :meta {:doc nil, :arglists ([s])}, :examples []} {:sym chunk-next, :meta {:doc nil, :arglists ([s])}, :examples []} {:sym chunk-rest, :meta {:doc nil, :arglists ([s])}, :examples []} {:sym chunked-seq, :meta {:doc nil, :arglists ([vec i off] [vec node i off] [vec node i off meta])}, :examples []} {:sym chunked-seq?, :meta {:doc "Return true if x is satisfies IChunkedSeq.", :arglists ([x])}, :examples []} {:sym clj->js, :meta {:doc "Recursively transforms ClojureScript values to JavaScript.\n  sets/vectors/lists become Arrays, Keywords and Symbol become Strings,\n  Maps become Objects. Arbitrary keys are encoded to by key->js.", :arglists ([x])}, :examples []} {:sym clone, :meta {:doc "Clone the supplied value which must implement ICloneable.", :arglists ([value])}, :examples []} {:sym cloneable?, :meta {:doc "Return true if x implements ICloneable protocol.", :arglists ([value])}, :examples []} {:sym coercive-=, :meta {:doc nil, :arglists ([x y])}, :examples []} {:sym coercive-boolean, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym coercive-not, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym coercive-not=, :meta {:doc nil, :arglists ([x y])}, :examples []} {:sym coll?, :meta {:doc "Returns true if x satisfies ICollection", :arglists ([x])}, :examples []} {:sym comment, :meta {:doc "Ignores body, yields nil", :arglists ([& body])}, :examples []} {:sym comp, :meta {:doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :arglists ([] [f] [f g] [f g h] [f1 f2 f3 & fs])}, :examples []} {:sym comparator, :meta {:doc "Returns an JavaScript compatible comparator based upon pred.", :arglists ([pred])}, :examples []} {:sym compare, :meta {:doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object.", :arglists ([x y])}, :examples []} {:sym compare-and-set!, :meta {:doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false.", :arglists ([a oldval newval])}, :examples []} {:sym complement, :meta {:doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", :arglists ([f])}, :examples []} {:sym completing, :meta {:doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", :arglists ([f] [f cf])}, :examples []} {:sym concat, :meta {:doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :arglists ([] [x] [x y] [x y & zs])}, :examples []} {:sym cond, :meta {:doc "Takes a set of test/expr pairs. It evaluates each test one at a\n  time.  If a test returns logical true, cond evaluates and returns\n  the value of the corresponding expr and doesn't evaluate any of the\n  other tests or exprs. (cond) returns nil.", :arglists ([& clauses])}, :examples []} {:sym cond->, :meta {:doc "Takes an expression and a set of test/form pairs. Threads expr (via ->)\n  through each form for which the corresponding test\n  expression is true. Note that, unlike cond branching, cond-> threading does\n  not short circuit after the first true test expression.", :arglists ([expr & clauses])}, :examples []} {:sym cond->>, :meta {:doc "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n  through each form for which the corresponding test expression\n  is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n  after the first true test expression.", :arglists ([expr & clauses])}, :examples []} {:sym condp, :meta {:doc "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an\n  IllegalArgumentException is thrown.", :arglists ([pred expr & clauses])}, :examples []} {:sym conj, :meta {:doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type.", :arglists ([] [coll] [coll x] [coll x & xs])}, :examples []} {:sym conj!, :meta {:doc "Adds val to the transient collection, and return tcoll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :arglists ([] [tcoll] [tcoll val] [tcoll val & vals])}, :examples []} {:sym cons, :meta {:doc "Returns a new seq where x is the first element and coll is the rest.", :arglists ([x coll])}, :examples []} {:sym constantly, :meta {:doc "Returns a function that takes any number of arguments and returns x.", :arglists ([x])}, :examples []} {:sym contains?, :meta {:doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", :arglists ([coll v])}, :examples []} {:sym copy-arguments, :meta {:doc nil, :arglists ([dest])}, :examples []} {:sym count, :meta {:doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps", :arglists ([coll])}, :examples []} {:sym counted?, :meta {:doc "Returns true if coll implements count in constant time", :arglists ([x])}, :examples []} {:sym create-ns, :meta {:doc "Create a new namespace named by the symbol. Bootstrap only.", :arglists ([sym] [sym ns-obj])}, :examples []} {:sym cycle, :meta {:doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", :arglists ([coll])}, :examples []} {:sym dec, :meta {:doc "Returns a number one less than num.", :arglists ([x])}, :examples []} {:sym declare, :meta {:doc "defs the supplied var names with no bindings, useful for making forward declarations.", :arglists ([& names])}, :examples []} {:sym dedupe, :meta {:doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.", :arglists ([] [coll])}, :examples []} {:sym default-dispatch-val, :meta {:doc "Given a multimethod, return it's default-dispatch-val.", :arglists ([multifn])}, :examples []} {:sym defmacro, :meta {:doc "Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.", :arglists ([name doc-string? attr-map? [params*] body] [name doc-string? attr-map? ([params*] body) + attr-map?])}, :examples []} {:sym defmethod, :meta {:doc "Creates and installs a new method of multimethod associated with dispatch-value. ", :arglists ([multifn dispatch-val & fn-tail])}, :examples []} {:sym defmulti, :meta {:doc "Creates a new multimethod with the associated dispatch function.\n  The docstring and attribute-map are optional.\n\n  Options are key-value pairs and may be one of:\n    :default    the default dispatch value, defaults to :default\n    :hierarchy  the isa? hierarchy to use for dispatching\n                defaults to the global hierarchy", :arglists ([mm-name & options])}, :examples []} {:sym defn, :meta {:doc "Same as (def name (core/fn [params* ] exprs*)) or (def\n    name (core/fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.", :arglists ([name doc-string? attr-map? [params*] prepost-map? body] [name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?])}, :examples []} {:sym defn-, :meta {:doc "same as defn, yielding non-public def", :arglists ([name & decls])}, :examples []} {:sym defonce, :meta {:doc "defs name to have the root value of init iff the named var has no root value,\n  else init is unevaluated", :arglists ([x init])}, :examples []} {:sym defprotocol, :meta {:doc "A protocol is a named set of named methods and their signatures:\n\n  (defprotocol AProtocolName\n    ;optional doc string\n    \"A doc string for AProtocol abstraction\"\n\n  ;method signatures\n    (bar [this a b] \"bar docs\")\n    (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in\n  JavaScript parlance). defprotocol is dynamic, has no special compile-time\n  effect, and defines no new types.\n\n  (defprotocol P\n    (foo [this])\n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c]\n    P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n\n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo\n    (let [x 42]\n      (reify P\n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17", :arglists ([psym & doc+methods])}, :examples []} {:sym defrecord, :meta {:doc "(defrecord name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The record will have the (immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in JavaScript parlance). Note also\n  that recur calls to the method head should *not* pass the target object, it\n  will be supplied automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The type will have implementations of several ClojureScript\n  protocol generated automatically: IMeta/IWithMeta (metadata support) and\n  IMap, etc.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will define ClojureScript IHash and IEquiv.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta\n  and __extmap are currently reserved and should not be used when\n  defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values.", :arglists ([rsym fields & impls])}, :examples []} {:sym deftype, :meta {:doc "(deftype name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The type will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly. Fields can be qualified\n  with the metadata :mutable true at which point (set! afield aval) will be\n  supported in method bodies. Note well that mutable fields are extremely\n  difficult to use correctly, and are present only to facilitate the building\n  of higherlevel constructs, such as ClojureScript's reference types, in\n  ClojureScript itself. They are for experts only - if the semantics and\n  implications of :mutable are not immediately apparent to you, you should not\n  be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for methods of Object. Note that\n  a parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta and __extmap are currently reserved and\n  should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields", :arglists ([t fields & impls])}, :examples []} {:sym delay, :meta {:doc "Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls.", :arglists ([& body])}, :examples []} {:sym delay?, :meta {:doc "returns true if x is a Delay created with delay", :arglists ([x])}, :examples []} {:sym demunge, :meta {:doc nil, :arglists ([name])}, :examples []} {:sym deref, :meta {:doc "Also reader macro: @var/@atom/@delay. Returns the\n   most-recently-committed value of ref. When applied to a var\n   or atom, returns its current state. When applied to a delay, forces\n   it if not already forced. See also - realized?.", :arglists ([o])}, :examples []} {:sym derive, :meta {:doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :arglists ([tag parent] [h tag parent])}, :examples []} {:sym descendants, :meta {:doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships.", :arglists ([tag] [h tag])}, :examples []} {:sym disj, :meta {:doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :arglists ([coll] [coll k] [coll k & ks])}, :examples []} {:sym disj!, :meta {:doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :arglists ([tcoll val] [tcoll val & vals])}, :examples []} {:sym dispatch-fn, :meta {:doc "Given a multimethod, return it's dispatch-fn.", :arglists ([multifn])}, :examples []} {:sym dissoc, :meta {:doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :arglists ([coll] [coll k] [coll k & ks])}, :examples []} {:sym dissoc!, :meta {:doc "Returns a transient map that doesn't contain a mapping for key(s).", :arglists ([tcoll key] [tcoll key & ks])}, :examples []} {:sym distinct, :meta {:doc "Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided.", :arglists ([] [coll])}, :examples []} {:sym distinct?, :meta {:doc "Returns true if no two of the arguments are =", :arglists ([x] [x y] [x y & more])}, :examples []} {:sym divide, :meta {:doc nil, :arglists nil}, :examples []} {:sym doall, :meta {:doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", :arglists ([coll] [n coll])}, :examples []} {:sym dorun, :meta {:doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", :arglists ([coll] [n coll])}, :examples []} {:sym doseq, :meta {:doc "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \"for\".  Does not retain\n  the head of the sequence. Returns nil.", :arglists ([seq-exprs & body])}, :examples []} {:sym dotimes, :meta {:doc "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.", :arglists ([bindings & body])}, :examples []} {:sym doto, :meta {:doc "Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))", :arglists ([x & forms])}, :examples []} {:sym double, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym double-array, :meta {:doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists ([size-or-seq] [size init-val-or-seq])}, :examples []} {:sym double?, :meta {:doc "Returns true for JavaScript numbers, false otherwise.", :arglists ([x])}, :examples []} {:sym doubles, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym drop, :meta {:doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :arglists ([n] [n coll])}, :examples []} {:sym drop-last, :meta {:doc "Return a lazy sequence of all but the last n (default 1) items in coll", :arglists ([s] [n s])}, :examples []} {:sym drop-while, :meta {:doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :arglists ([pred] [pred coll])}, :examples []} {:sym eduction, :meta {:doc "Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called.", :arglists ([& xforms])}, :examples []} {:sym empty, :meta {:doc "Returns an empty collection of the same category as coll, or nil", :arglists ([coll])}, :examples []} {:sym empty?, :meta {:doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))", :arglists ([coll])}, :examples []} {:sym enable-console-print!, :meta {:doc "Set *print-fn* to console.log", :arglists ([])}, :examples []} {:sym ensure-reduced, :meta {:doc "If x is already reduced?, returns it, else returns (reduced x)", :arglists ([x])}, :examples []} {:sym equiv-map, :meta {:doc "Test map equivalence. Returns true if x equals y, otherwise returns false.", :arglists ([x y])}, :examples []} {:sym es6-entries-iterator, :meta {:doc nil, :arglists ([coll])}, :examples []} {:sym es6-iterable, :meta {:doc nil, :arglists ([ty])}, :examples []} {:sym es6-iterator, :meta {:doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll.", :arglists ([coll])}, :examples []} {:sym es6-iterator-seq, :meta {:doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.", :arglists ([iter])}, :examples []} {:sym es6-set-entries-iterator, :meta {:doc nil, :arglists ([coll])}, :examples []} {:sym even?, :meta {:doc "Returns true if n is even, throws an exception if n is not an integer", :arglists ([n])}, :examples []} {:sym every-pred, :meta {:doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])}, :examples []} {:sym every?, :meta {:doc "Returns true if (pred x) is logical true for every x in coll, else\n  false.", :arglists ([pred coll])}, :examples []} {:sym ex-cause, :meta {:doc "Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil.", :arglists ([ex])}, :examples []} {:sym ex-data, :meta {:doc "Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil.", :arglists ([ex])}, :examples []} {:sym ex-info, :meta {:doc "Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data.", :arglists ([msg data] [msg data cause])}, :examples []} {:sym ex-message, :meta {:doc "Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil.", :arglists ([ex])}, :examples []} {:sym exists?, :meta {:doc "Return true if argument exists, analogous to usage of typeof operator\n   in JavaScript.", :arglists ([x])}, :examples []} {:sym extend-protocol, :meta {:doc "Useful when you want to provide several implementations of the same\n  protocol all at once. Takes a single protocol and the implementation\n  of that protocol for one or more types. Expands into calls to\n  extend-type:\n\n  (extend-protocol Protocol\n    AType\n      (foo [x] ...)\n      (bar [x y] ...)\n    BType\n      (foo [x] ...)\n      (bar [x y] ...)\n    AClass\n      (foo [x] ...)\n      (bar [x y] ...)\n    nil\n      (foo [x] ...)\n      (bar [x y] ...))\n\n  expands into:\n\n  (do\n   (clojure.core/extend-type AType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type BType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type AClass Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type nil Protocol \n     (foo [x] ...) \n     (bar [x y] ...)))", :arglists ([p & specs])}, :examples []} {:sym extend-type, :meta {:doc "Extend a type to a series of protocols. Useful when you are\n  supplying the definitions explicitly inline. Propagates the\n  type as a type hint on the first argument of all fns.\n\n  type-sym may be\n\n   * default, meaning the definitions will apply for any value,\n     unless an extend-type exists for one of the more specific\n     cases below.\n   * nil, meaning the definitions will apply for the nil value.\n   * any of object, boolean, number, string, array, or function,\n     indicating the definitions will apply for values of the\n     associated base JavaScript types. Note that, for example,\n     string should be used instead of js/String.\n   * a JavaScript type not covered by the previous list, such\n     as js/RegExp.\n   * a type defined by deftype or defrecord.\n\n  (extend-type MyType\n    ICounted\n    (-count [c] ...)\n    Foo\n    (bar [x y] ...)\n    (baz ([x] ...) ([x y] ...) ...)", :arglists ([type-sym & impls])}, :examples []} {:sym false?, :meta {:doc "Returns true if x is the value false, false otherwise.", :arglists ([x])}, :examples []} {:sym ffirst, :meta {:doc "Same as (first (first x))", :arglists ([coll])}, :examples []} {:sym filter, :meta {:doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :arglists ([pred] [pred coll])}, :examples []} {:sym filterv, :meta {:doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.", :arglists ([pred coll])}, :examples []} {:sym find, :meta {:doc "Returns the map entry for key, or nil if key not present.", :arglists ([coll k])}, :examples []} {:sym find-macros-ns, :meta {:doc "Returns the macros namespace named by the symbol or nil if it doesn't exist.\n  Bootstrap only.", :arglists ([ns])}, :examples []} {:sym find-ns, :meta {:doc "Returns the namespace named by the symbol or nil if it doesn't exist.\n  Bootstrap only.", :arglists ([ns])}, :examples []} {:sym find-ns-obj, :meta {:doc "Bootstrap only.", :arglists ([ns])}, :examples []} {:sym first, :meta {:doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil.", :arglists ([coll])}, :examples []} {:sym fixture1, :meta {:doc nil, :arglists nil}, :examples []} {:sym fixture2, :meta {:doc nil, :arglists nil}, :examples []} {:sym flatten, :meta {:doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil.", :arglists ([x])}, :examples []} {:sym float, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym float?, :meta {:doc "Returns true for JavaScript numbers, false otherwise.", :arglists ([x])}, :examples []} {:sym floats, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym flush, :meta {:doc nil, :arglists ([])}, :examples []} {:sym fn, :meta {:doc "params => positional-params* , or positional-params* & next-param\n  positional-param => binding-form\n  next-param => binding-form\n  name => symbol\n\n  Defines a function", :arglists ([& sigs])}, :examples []} {:sym fn?, :meta {:doc "Return true if f is a JavaScript function or satisfies the Fn protocol.", :arglists ([f])}, :examples []} {:sym fnext, :meta {:doc "Same as (first (next x))", :arglists ([coll])}, :examples []} {:sym fnil, :meta {:doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :arglists ([f x] [f x y] [f x y z])}, :examples []} {:sym for, :meta {:doc "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))", :arglists ([seq-exprs body-expr])}, :examples []} {:sym force, :meta {:doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x", :arglists ([x])}, :examples []} {:sym frequencies, :meta {:doc "Returns a map from distinct items in coll to the number of times\n  they appear.", :arglists ([coll])}, :examples []} {:sym gen-apply-to, :meta {:doc nil, :arglists ([])}, :examples []} {:sym gen-apply-to-simple, :meta {:doc nil, :arglists ([f num-args args])}, :examples []} {:sym gensym, :meta {:doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", :arglists ([] [prefix-string])}, :examples []} {:sym gensym_counter, :meta {:doc nil, :arglists nil}, :examples []} {:sym get, :meta {:doc "Returns the value mapped to key, not-found or nil if key not present.", :arglists ([o k] [o k not-found])}, :examples []} {:sym get-in, :meta {:doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied.", :arglists ([m ks] [m ks not-found])}, :examples []} {:sym get-method, :meta {:doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default", :arglists ([multifn dispatch-val])}, :examples []} {:sym get-validator, :meta {:doc "Gets the validator-fn for a var/ref/agent/atom.", :arglists ([iref])}, :examples []} {:sym goog-define, :meta {:doc "Defines a var using `goog.define`. Passed default value must be\n  string, number or boolean.\n\n  Default value can be overridden at compile time using the\n  compiler option `:closure-defines`.\n\n  Example:\n    (ns your-app.core)\n    (goog-define DEBUG! false)\n    ;; can be overridden with\n    :closure-defines {\"your_app.core.DEBUG_BANG_\" true}\n    or\n    :closure-defines {'your-app.core/DEBUG! true}", :arglists ([sym default])}, :examples []} {:sym group-by, :meta {:doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll.", :arglists ([f coll])}, :examples []} {:sym halt-when, :meta {:doc "Returns a transducer that ends transduction when pred returns true\n  for an input. When retf is supplied it must be a fn of 2 arguments -\n  it will be passed the (completed) result so far and the input that\n  triggered the predicate, and its return value (if it does not throw\n  an exception) will be the return value of the transducer. If retf\n  is not supplied, the input that triggered the predicate will be\n  returned. If the predicate never returns true the transduction is\n  unaffected.", :arglists ([pred] [pred retf])}, :examples []} {:sym hash, :meta {:doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =.", :arglists ([o])}, :examples []} {:sym hash-combine, :meta {:doc nil, :arglists ([seed hash])}, :examples []} {:sym hash-keyword, :meta {:doc nil, :arglists ([k])}, :examples []} {:sym hash-map, :meta {:doc "keyval => key val\n  Returns a new hash map with supplied mappings.", :arglists ([& keyvals])}, :examples []} {:sym hash-ordered-coll, :meta {:doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([coll])}, :examples []} {:sym hash-set, :meta {:doc "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", :arglists ([] [& keys])}, :examples []} {:sym hash-string, :meta {:doc nil, :arglists ([k])}, :examples []} {:sym hash-string*, :meta {:doc nil, :arglists ([s])}, :examples []} {:sym hash-unordered-coll, :meta {:doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([coll])}, :examples []} {:sym ident?, :meta {:doc "Return true if x is a symbol or keyword", :arglists ([x])}, :examples []} {:sym identical?, :meta {:doc "Tests if 2 arguments are the same object", :arglists ([x y])}, :examples []} {:sym identity, :meta {:doc "Returns its argument.", :arglists ([x])}, :examples []} {:sym if-let, :meta {:doc "bindings => binding-form test\n\n  If test is true, evaluates then with binding-form bound to the value of \n  test, if not, yields else", :arglists ([bindings then] [bindings then else & oldform])}, :examples []} {:sym if-not, :meta {:doc "Evaluates test. If logical false, evaluates and returns then expr, \n  otherwise else expr, if supplied, else nil.", :arglists ([test then] [test then else])}, :examples []} {:sym if-some, :meta {:doc "bindings => binding-form test\n\n   If test is not nil, evaluates then with binding-form bound to the\n   value of test, if not, yields else", :arglists ([bindings then] [bindings then else & oldform])}, :examples []} {:sym ifind?, :meta {:doc "Returns true if coll implements IFind", :arglists ([x])}, :examples []} {:sym ifn?, :meta {:doc "Returns true if f returns true for fn? or satisfies IFn.", :arglists ([f])}, :examples []} {:sym implements?, :meta {:doc "EXPERIMENTAL", :arglists ([psym x])}, :examples []} {:sym import, :meta {:doc "import-list => (closure-namespace constructor-name-symbols*)\n\n  For each name in constructor-name-symbols, adds a mapping from name to the\n  constructor named by closure-namespace to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.", :arglists ([& import-symbols-or-lists])}, :examples []} {:sym import-macros, :meta {:doc nil, :arglists ([ns [& vars]])}, :examples []} {:sym imul, :meta {:doc nil, :arglists ([a b])}, :examples []} {:sym inc, :meta {:doc "Returns a number one greater than num.", :arglists ([x])}, :examples []} {:sym indexed?, :meta {:doc "Returns true if coll implements nth in constant time", :arglists ([x])}, :examples []} {:sym infinite?, :meta {:doc "Returns true for Infinity and -Infinity values.", :arglists ([x])}, :examples []} {:sym inst-ms, :meta {:doc "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT", :arglists ([inst])}, :examples []} {:sym inst-ms*, :meta {:doc nil, :arglists ([inst])}, :examples []} {:sym inst?, :meta {:doc "Return true if x satisfies Inst", :arglists ([x])}, :examples []} {:sym instance?, :meta {:doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false", :arglists ([c x])}, :examples []} {:sym int, :meta {:doc "Coerce to int by stripping decimal places.", :arglists ([x])}, :examples []} {:sym int-array, :meta {:doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists ([size-or-seq] [size init-val-or-seq])}, :examples []} {:sym int-rotate-left, :meta {:doc nil, :arglists ([x n])}, :examples []} {:sym int?, :meta {:doc "Return true if x satisfies integer? or is an instance of goog.math.Integer\n   or goog.math.Long.", :arglists ([x])}, :examples []} {:sym integer?, :meta {:doc "Returns true if n is a JavaScript number with no decimal part.", :arglists ([n])}, :examples []} {:sym interleave, :meta {:doc "Returns a lazy seq of the first item in each coll, then the second etc.", :arglists ([] [c1] [c1 c2] [c1 c2 & colls])}, :examples []} {:sym interpose, :meta {:doc "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.", :arglists ([sep] [sep coll])}, :examples []} {:sym into, :meta {:doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :arglists ([] [to] [to from] [to xform from])}, :examples []} {:sym into-array, :meta {:doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure.", :arglists ([aseq] [type aseq])}, :examples []} {:sym ints, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym is_proto_, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym isa?, :meta {:doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", :arglists ([child parent] [h child parent])}, :examples []} {:sym iter, :meta {:doc nil, :arglists ([coll])}, :examples []} {:sym iterable?, :meta {:doc "Return true if x implements IIterable protocol.", :arglists ([x])}, :examples []} {:sym iterate, :meta {:doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :arglists ([f x])}, :examples []} {:sym js->clj, :meta {:doc "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords.", :arglists ([x] [x & opts])}, :examples []} {:sym js-arguments, :meta {:doc nil, :arglists ([])}, :examples []} {:sym js-comment, :meta {:doc "Emit a top-level JavaScript multi-line comment. New lines will create a\n  new comment line. Comment block will be preceded and followed by a newline", :arglists ([comment])}, :examples []} {:sym js-debugger, :meta {:doc "Emit JavaScript \"debugger;\" statement", :arglists ([])}, :examples []} {:sym js-delete, :meta {:doc "Delete a property from a JavaScript object.", :arglists ([obj key])}, :examples []} {:sym js-in, :meta {:doc nil, :arglists ([key obj])}, :examples []} {:sym js-inline-comment, :meta {:doc "Emit an inline JavaScript comment.", :arglists ([comment])}, :examples []} {:sym js-invoke, :meta {:doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name.", :arglists ([obj s & args])}, :examples []} {:sym js-keys, :meta {:doc "Return the JavaScript keys for an object.", :arglists ([obj])}, :examples []} {:sym js-mod, :meta {:doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers", :arglists ([n d])}, :examples []} {:sym js-obj, :meta {:doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values.", :arglists ([] [& keyvals])}, :examples []} {:sym js-reserved, :meta {:doc nil, :arglists nil}, :examples []} {:sym js-str, :meta {:doc nil, :arglists ([s])}, :examples []} {:sym juxt, :meta {:doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", :arglists ([f] [f g] [f g h] [f g h & fs])}, :examples []} {:sym keep, :meta {:doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :arglists ([f] [f coll])}, :examples []} {:sym keep-indexed, :meta {:doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :arglists ([f] [f coll])}, :examples []} {:sym key, :meta {:doc "Returns the key of the map entry.", :arglists ([map-entry])}, :examples []} {:sym key->js, :meta {:doc nil, :arglists ([k])}, :examples []} {:sym key-test, :meta {:doc nil, :arglists ([key other])}, :examples []} {:sym keys, :meta {:doc "Returns a sequence of the map's keys.", :arglists ([hash-map])}, :examples []} {:sym keyword, :meta {:doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :arglists ([name] [ns name])}, :examples []} {:sym keyword-identical?, :meta {:doc "Efficient test to determine that two keywords are identical.", :arglists ([x y])}, :examples []} {:sym keyword?, :meta {:doc "Return true if x is a Keyword", :arglists ([x])}, :examples []} {:sym last, :meta {:doc "Return the last item in coll, in linear time", :arglists ([s])}, :examples []} {:sym lazy-cat, :meta {:doc "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed.\n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))", :arglists ([& colls])}, :examples []} {:sym lazy-seq, :meta {:doc "Takes a body of expressions that returns an ISeq or nil, and yields\n  a ISeqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls.", :arglists ([& body])}, :examples []} {:sym let, :meta {:doc "binding => binding-form init-expr\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.", :arglists ([bindings & body])}, :examples []} {:sym letfn, :meta {:doc "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n  Takes a vector of function specs and a body, and generates a set of\n  bindings of functions to their names. All of the names are available\n  in all of the definitions of the functions, as well as the body.", :arglists ([fnspecs & body])}, :examples []} {:sym list, :meta {:doc "Creates a new list containing the items.", :arglists ([& xs])}, :examples []} {:sym list*, :meta {:doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :arglists ([args] [a args] [a b args] [a b c args] [a b c d & more])}, :examples []} {:sym list?, :meta {:doc "Returns true if x implements IList", :arglists ([x])}, :examples []} {:sym load-file, :meta {:doc nil, :arglists ([file])}, :examples []} {:sym load-file*, :meta {:doc nil, :arglists ([f])}, :examples []} {:sym locking, :meta {:doc nil, :arglists ([x & forms])}, :examples []} {:sym long, :meta {:doc "Coerce to long by stripping decimal places. Identical to `int'.", :arglists ([x])}, :examples []} {:sym long-array, :meta {:doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists ([size-or-seq] [size init-val-or-seq])}, :examples []} {:sym longs, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym loop, :meta {:doc "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.", :arglists ([bindings & body])}, :examples []} {:sym m3-C1, :meta {:doc nil, :arglists nil}, :examples []} {:sym m3-C2, :meta {:doc nil, :arglists nil}, :examples []} {:sym m3-fmix, :meta {:doc nil, :arglists ([h1 len])}, :examples []} {:sym m3-hash-int, :meta {:doc nil, :arglists ([in])}, :examples []} {:sym m3-hash-unencoded-chars, :meta {:doc nil, :arglists ([in])}, :examples []} {:sym m3-mix-H1, :meta {:doc nil, :arglists ([h1 k1])}, :examples []} {:sym m3-mix-K1, :meta {:doc nil, :arglists ([k1])}, :examples []} {:sym m3-seed, :meta {:doc nil, :arglists nil}, :examples []} {:sym macroexpand, :meta {:doc "Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms.", :arglists ([quoted])}, :examples []} {:sym macroexpand-1, :meta {:doc "If form represents a macro form, returns its expansion,\n  else returns form.", :arglists ([quoted])}, :examples []} {:sym make-array, :meta {:doc "Construct a JavaScript array of the specified dimensions. Accepts ignored\n  type argument for compatibility with Clojure. Note that there is no efficient\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\n  will run in polynomial time when called with 3 or more arguments.", :arglists ([size] [type size] [type size & more-sizes])}, :examples []} {:sym make-hierarchy, :meta {:doc "Creates a hierarchy object for use with derive, isa? etc.", :arglists ([])}, :examples []} {:sym map, :meta {:doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :arglists ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])}, :examples []} {:sym map-indexed, :meta {:doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.", :arglists ([f] [f coll])}, :examples []} {:sym map?, :meta {:doc "Return true if x satisfies IMap", :arglists ([x])}, :examples []} {:sym mapcat, :meta {:doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", :arglists ([f] [f & colls])}, :examples []} {:sym mapv, :meta {:doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :arglists ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])}, :examples []} {:sym max, :meta {:doc "Returns the greatest of the nums.", :arglists ([x] [x y] [x y & more])}, :examples []} {:sym max-key, :meta {:doc "Returns the x for which (k x), a number, is greatest.", :arglists ([k x] [k x y] [k x y & more])}, :examples []} {:sym memfn, :meta {:doc "Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a JavaScript\n  method as a first-class fn.", :arglists ([name & args])}, :examples []} {:sym memoize, :meta {:doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use.", :arglists ([f])}, :examples []} {:sym merge, :meta {:doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", :arglists ([& maps])}, :examples []} {:sym merge-with, :meta {:doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", :arglists ([f & maps])}, :examples []} {:sym meta, :meta {:doc "Returns the metadata of obj, returns nil if there is no metadata.", :arglists ([o])}, :examples []} {:sym methods, :meta {:doc "Given a multimethod, returns a map of dispatch values -> dispatch fns", :arglists ([multifn])}, :examples []} {:sym min, :meta {:doc "Returns the least of the nums.", :arglists ([x] [x y] [x y & more])}, :examples []} {:sym min-key, :meta {:doc "Returns the x for which (k x), a number, is least.", :arglists ([k x] [k x y] [k x y & more])}, :examples []} {:sym missing-protocol, :meta {:doc nil, :arglists ([proto obj])}, :examples []} {:sym mix-collection-hash, :meta {:doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([hash-basis count])}, :examples []} {:sym mk-bound-fn, :meta {:doc nil, :arglists ([sc test key])}, :examples []} {:sym mod, :meta {:doc "Modulus of num and div. Truncates toward negative infinity.", :arglists ([n d])}, :examples []} {:sym munge, :meta {:doc nil, :arglists ([name])}, :examples []} {:sym name, :meta {:doc "Returns the name String of a string, symbol or keyword.", :arglists ([x])}, :examples []} {:sym namespace, :meta {:doc "Returns the namespace String of a symbol or keyword, or nil if not present.", :arglists ([x])}, :examples []} {:sym nat-int?, :meta {:doc "Return true if x satisfies int? and is a natural integer value.", :arglists ([x])}, :examples []} {:sym native-satisfies?, :meta {:doc "Internal - do not use!", :arglists ([p x])}, :examples []} {:sym neg-int?, :meta {:doc "Return true if x satisfies int? and is negative.", :arglists ([x])}, :examples []} {:sym neg?, :meta {:doc "Returns true if num is less than zero, else false", :arglists ([x])}, :examples []} {:sym newline, :meta {:doc "Prints a newline using *print-fn*", :arglists ([] [opts])}, :examples []} {:sym next, :meta {:doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil", :arglists ([coll])}, :examples []} {:sym nfirst, :meta {:doc "Same as (next (first x))", :arglists ([coll])}, :examples []} {:sym nil-iter, :meta {:doc nil, :arglists ([])}, :examples []} {:sym nil?, :meta {:doc "Returns true if x is nil, false otherwise.", :arglists ([x])}, :examples []} {:sym nnext, :meta {:doc "Same as (next (next x))", :arglists ([coll])}, :examples []} {:sym not, :meta {:doc "Returns true if x is logical false, false otherwise.", :arglists ([x])}, :examples []} {:sym not-any?, :meta {:doc "Returns false if (pred x) is logical true for any x in coll,\n  else true.", :arglists ([pred coll])}, :examples []} {:sym not-empty, :meta {:doc "If coll is empty, returns nil, else coll", :arglists ([coll])}, :examples []} {:sym not-every?, :meta {:doc "Returns false if (pred x) is logical true for every x in\n  coll, else true.", :arglists ([pred coll])}, :examples []} {:sym not-native, :meta {:doc nil, :arglists nil}, :examples []} {:sym not=, :meta {:doc "Same as (not (= obj1 obj2))", :arglists ([x] [x y] [x y & more])}, :examples []} {:sym ns-imports, :meta {:doc "Returns a map of the import mappings for the namespace.", :arglists ([quoted-ns])}, :examples []} {:sym ns-interns, :meta {:doc "Returns a map of the intern mappings for the namespace.", :arglists ([quoted-ns])}, :examples []} {:sym ns-interns*, :meta {:doc "Returns a map of the intern mappings for the namespace.\n  Bootstrap only.", :arglists ([sym])}, :examples []} {:sym ns-name, :meta {:doc "Returns the name of the namespace, a Namespace object.\n  Bootstrap only.", :arglists ([ns-obj])}, :examples []} {:sym ns-publics, :meta {:doc "Returns a map of the public intern mappings for the namespace.", :arglists ([quoted-ns])}, :examples []} {:sym ns-unmap, :meta {:doc "Removes the mappings for the symbol from the namespace.", :arglists ([quoted-ns quoted-sym])}, :examples []} {:sym nth, :meta {:doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :arglists ([coll n] [coll n not-found])}, :examples []} {:sym nthnext, :meta {:doc "Returns the nth next of coll, (seq coll) when n is 0.", :arglists ([coll n])}, :examples []} {:sym nthrest, :meta {:doc "Returns the nth rest of coll, coll when n is 0.", :arglists ([coll n])}, :examples []} {:sym number?, :meta {:doc "Returns true if x is a JavaScript number.", :arglists ([x])}, :examples []} {:sym obj-map, :meta {:doc "keyval => key val\n  Returns a new object map with supplied mappings.", :arglists ([& keyvals])}, :examples []} {:sym object-array, :meta {:doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists ([size-or-seq] [size init-val-or-seq])}, :examples []} {:sym object?, :meta {:doc "Returns true if x's constructor is Object", :arglists ([x])}, :examples []} {:sym odd?, :meta {:doc "Returns true if n is odd, throws an exception if n is not an integer", :arglists ([n])}, :examples []} {:sym or, :meta {:doc "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.", :arglists ([] [x] [x & next])}, :examples []} {:sym parents, :meta {:doc "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :arglists ([tag] [h tag])}, :examples []} {:sym partial, :meta {:doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :arglists ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more])}, :examples []} {:sym partition, :meta {:doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :arglists ([n coll] [n step coll] [n step pad coll])}, :examples []} {:sym partition-all, :meta {:doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.", :arglists ([n] [n coll] [n step coll])}, :examples []} {:sym partition-by, :meta {:doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.", :arglists ([f] [f coll])}, :examples []} {:sym peek, :meta {:doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", :arglists ([coll])}, :examples []} {:sym persistent!, :meta {:doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", :arglists ([tcoll])}, :examples []} {:sym persistent-array-map-seq, :meta {:doc nil, :arglists ([arr i _meta])}, :examples []} {:sym pop, :meta {:doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast.", :arglists ([coll])}, :examples []} {:sym pop!, :meta {:doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns tcoll", :arglists ([tcoll])}, :examples []} {:sym pos-int?, :meta {:doc "Return true if x satisfies int? and is positive.", :arglists ([x])}, :examples []} {:sym pos?, :meta {:doc "Returns true if num is greater than zero, else false", :arglists ([x])}, :examples []} {:sym pr, :meta {:doc "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader", :arglists ([& objs])}, :examples []} {:sym pr-seq-writer, :meta {:doc nil, :arglists ([objs writer opts])}, :examples []} {:sym pr-sequential-writer, :meta {:doc nil, :arglists ([writer print-one begin sep end opts coll])}, :examples []} {:sym pr-str, :meta {:doc "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter.", :arglists ([& objs])}, :examples []} {:sym pr-str*, :meta {:doc "Support so that collections can implement toString without\n   loading all the printing machinery.", :arglists ([obj])}, :examples []} {:sym pr-str-with-opts, :meta {:doc "Prints a sequence of objects to a string, observing all the\n  options given in opts", :arglists ([objs opts])}, :examples []} {:sym prefer-method, :meta {:doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict", :arglists ([multifn dispatch-val-x dispatch-val-y])}, :examples []} {:sym prefers, :meta {:doc "Given a multimethod, returns a map of preferred value -> set of other values", :arglists ([multifn])}, :examples []} {:sym prim-seq, :meta {:doc "Create seq from a primitive JavaScript Array-like.", :arglists ([prim] [prim i])}, :examples []} {:sym print, :meta {:doc "Prints the object(s) using string-print.\n  print and println produce output for human consumption.", :arglists nil}, :examples []} {:sym print-map, :meta {:doc nil, :arglists ([m print-one writer opts])}, :examples []} {:sym print-meta?, :meta {:doc nil, :arglists ([opts obj])}, :examples []} {:sym print-prefix-map, :meta {:doc nil, :arglists ([prefix m print-one writer opts])}, :examples []} {:sym print-str, :meta {:doc "print to a string, returning it", :arglists ([& objs])}, :examples []} {:sym println, :meta {:doc "Same as print followed by (newline)", :arglists ([& objs])}, :examples []} {:sym println-str, :meta {:doc "println to a string, returning it", :arglists ([& objs])}, :examples []} {:sym prn, :meta {:doc "Same as pr followed by (newline).", :arglists ([& objs])}, :examples []} {:sym prn-str, :meta {:doc "Same as pr-str followed by (newline)", :arglists ([& objs])}, :examples []} {:sym prn-str-with-opts, :meta {:doc "Same as pr-str-with-opts followed by (newline)", :arglists ([objs opts])}, :examples []} {:sym qualified-ident?, :meta {:doc "Return true if x is a symbol or keyword with a namespace", :arglists ([x])}, :examples []} {:sym qualified-keyword?, :meta {:doc "Return true if x is a keyword with a namespace", :arglists ([x])}, :examples []} {:sym qualified-symbol?, :meta {:doc "Return true if x is a symbol with a namespace", :arglists ([x])}, :examples []} {:sym quot, :meta {:doc "quot[ient] of dividing numerator by denominator.", :arglists ([n d])}, :examples []} {:sym rand, :meta {:doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", :arglists ([] [n])}, :examples []} {:sym rand-int, :meta {:doc "Returns a random integer between 0 (inclusive) and n (exclusive).", :arglists ([n])}, :examples []} {:sym rand-nth, :meta {:doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection.", :arglists ([coll])}, :examples []} {:sym random-sample, :meta {:doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.", :arglists ([prob] [prob coll])}, :examples []} {:sym random-uuid, :meta {:doc nil, :arglists ([])}, :examples []} {:sym range, :meta {:doc "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity.", :arglists ([] [end] [start end] [start end step])}, :examples []} {:sym ranged-iterator, :meta {:doc nil, :arglists ([v start end])}, :examples []} {:sym re-find, :meta {:doc "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups.", :arglists ([re s])}, :examples []} {:sym re-matches, :meta {:doc "Returns the result of (re-find re s) if re fully matches s.", :arglists ([re s])}, :examples []} {:sym re-pattern, :meta {:doc "Returns an instance of RegExp which has compiled the provided string.", :arglists ([s])}, :examples []} {:sym re-seq, :meta {:doc "Returns a lazy sequence of successive matches of re in s.", :arglists ([re s])}, :examples []} {:sym realized?, :meta {:doc "Returns true if a value has been produced for a delay or lazy sequence.", :arglists ([x])}, :examples []} {:sym record?, :meta {:doc "Return true if x satisfies IRecord", :arglists ([x])}, :examples []} {:sym reduce, :meta {:doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :arglists ([f coll] [f val coll])}, :examples []} {:sym reduce-kv, :meta {:doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", :arglists ([f init coll])}, :examples []} {:sym reduceable?, :meta {:doc "Returns true if coll satisfies IReduce", :arglists ([x])}, :examples []} {:sym reduced, :meta {:doc "Wraps x in a way such that a reduce will terminate with the value x", :arglists ([x])}, :examples []} {:sym reduced?, :meta {:doc "Returns true if x is the result of a call to reduced", :arglists ([r])}, :examples []} {:sym reductions, :meta {:doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", :arglists ([f coll] [f init coll])}, :examples []} {:sym refer-clojure, :meta {:doc "Refers to all the public vars of `cljs.core`, subject to\n  filters.\n  Filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  Filters can be used to select a subset, via exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent clashes.", :arglists ([& args])}, :examples []} {:sym regexp?, :meta {:doc "Returns true if x is a JavaScript RegExp instance.", :arglists ([x])}, :examples []} {:sym reify, :meta {:doc "reify is a macro with the following structure:\n\n (reify options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of the protocol name followed by zero\n  or more method bodies:\n\n  protocol\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for Object methods. Note that\n  the first parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls\n  to the method head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n\n  (str (let [f \"foo\"]\n       (reify Object\n         (toString [this] f))))\n  == \"foo\"\n\n  (seq (let [f \"foo\"]\n       (reify ISeqable\n         (-seq [this] (seq f)))))\n  == (\"f\" \"o\" \"o\"))\n\n  reify always implements IMeta and IWithMeta and transfers meta\n  data of the form to the created object.\n\n  (meta ^{:k :v} (reify Object (toString [this] \"foo\")))\n  == {:k :v}", :arglists ([& impls])}, :examples []} {:sym rem, :meta {:doc "remainder of dividing numerator by denominator.", :arglists ([n d])}, :examples []} {:sym remove, :meta {:doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :arglists ([pred] [pred coll])}, :examples []} {:sym remove-all-methods, :meta {:doc "Removes all of the methods of multimethod.", :arglists ([multifn])}, :examples []} {:sym remove-method, :meta {:doc "Removes the method of multimethod associated with dispatch-value.", :arglists ([multifn dispatch-val])}, :examples []} {:sym remove-watch, :meta {:doc "Removes a watch (set by add-watch) from a reference", :arglists ([iref key])}, :examples []} {:sym repeat, :meta {:doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :arglists ([x] [n x])}, :examples []} {:sym repeatedly, :meta {:doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :arglists ([f] [n f])}, :examples []} {:sym replace, :meta {:doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.", :arglists ([smap] [smap coll])}, :examples []} {:sym replicate, :meta {:doc "DEPRECATED: Use 'repeat' instead.\n  Returns a lazy seq of n xs.", :arglists ([n x])}, :examples []} {:sym require, :meta {:doc "Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib or a flag that modifies how all the identified\n  libs are loaded. Use :require in the ns macro in preference to calling this\n  directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of ClojureScript code. Lib names are symbols and each lib is associated\n  with a ClojureScript namespace. A lib's name also locates its root directory\n  within classpath using Java's package name to classpath-relative path mapping.\n  All resources in a lib should be contained in the directory structure under its\n  root directory. All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj. The root\n  resource should contain code to create the lib's namespace (usually by using\n  the ns macro) and load any additional lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :refer takes a list of symbols to refer from the namespace.\n  :refer-macros takes a list of macro symbols to refer from the namespace.\n  :include-macros true causes macros from the namespace to be required.\n  :rename specifies a map from referred var names to different\n    symbols (and can be used to prevent clashes)\n\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the library clojure.string :as string.\n\n  (require '[clojure.string :as string])", :arglists ([& args])}, :examples []} {:sym require-macros, :meta {:doc "Similar to require but only for macros.", :arglists ([& args])}, :examples []} {:sym reset!, :meta {:doc "Sets the value of atom to newval without regard for the\n  current value. Returns new-value.", :arglists ([a new-value])}, :examples []} {:sym reset-meta!, :meta {:doc "Atomically resets the metadata for an atom", :arglists ([iref m])}, :examples []} {:sym reset-vals!, :meta {:doc "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset.", :arglists ([a new-value])}, :examples []} {:sym resolve, :meta {:doc "Returns the var to which a symbol will be resolved in the namespace else nil.", :arglists ([quoted-sym])}, :examples []} {:sym rest, :meta {:doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", :arglists ([coll])}, :examples []} {:sym reverse, :meta {:doc "Returns a seq of the items in coll in reverse order. Not lazy.", :arglists ([coll])}, :examples []} {:sym reversible?, :meta {:doc "Returns true if coll satisfies? IReversible.", :arglists ([coll])}, :examples []} {:sym rseq, :meta {:doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil", :arglists ([rev])}, :examples []} {:sym rsubseq, :meta {:doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :arglists ([sc test key] [sc start-test start-key end-test end-key])}, :examples []} {:sym run!, :meta {:doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil", :arglists ([proc coll])}, :examples []} {:sym satisfies?, :meta {:doc "Returns true if x satisfies the protocol", :arglists ([psym x])}, :examples []} {:sym second, :meta {:doc "Same as (first (next x))", :arglists ([coll])}, :examples []} {:sym select-keys, :meta {:doc "Returns a map containing only those entries in map whose key is in keys", :arglists ([map keyseq])}, :examples []} {:sym seq, :meta {:doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings.", :arglists ([coll])}, :examples []} {:sym seq-iter, :meta {:doc nil, :arglists ([coll])}, :examples []} {:sym seq?, :meta {:doc "Return true if s satisfies ISeq", :arglists ([s])}, :examples []} {:sym seqable?, :meta {:doc "Return true if the seq function is supported for s", :arglists ([s])}, :examples []} {:sym sequence, :meta {:doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :arglists ([coll] [xform coll] [xform coll & colls])}, :examples []} {:sym sequential?, :meta {:doc "Returns true if coll satisfies ISequential", :arglists ([x])}, :examples []} {:sym set, :meta {:doc "Returns a set of the distinct elements of coll.", :arglists ([coll])}, :examples []} {:sym set-from-indexed-seq, :meta {:doc nil, :arglists ([iseq])}, :examples []} {:sym set-print-err-fn!, :meta {:doc "Set *print-err-fn* to f.", :arglists ([f])}, :examples []} {:sym set-print-fn!, :meta {:doc "Set *print-fn* to f.", :arglists ([f])}, :examples []} {:sym set-validator!, :meta {:doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed.", :arglists ([iref val])}, :examples []} {:sym set?, :meta {:doc "Returns true if x satisfies ISet", :arglists ([x])}, :examples []} {:sym short, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym shorts, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym shuffle, :meta {:doc "Return a random permutation of coll", :arglists ([coll])}, :examples []} {:sym simple-benchmark, :meta {:doc "Runs expr iterations times in the context of a let expression with\n  the given bindings, then prints out the bindings and the expr\n  followed by number of iterations and total time. The optional\n  argument print-fn, defaulting to println, sets function used to\n  print the result. expr's string representation will be produced\n  using pr-str in any case.", :arglists ([bindings expr iterations & {:keys [print-fn], :or {print-fn (quote println)}}])}, :examples []} {:sym simple-ident?, :meta {:doc "Return true if x is a symbol or keyword without a namespace", :arglists ([x])}, :examples []} {:sym simple-keyword?, :meta {:doc "Return true if x is a keyword without a namespace", :arglists ([x])}, :examples []} {:sym simple-symbol?, :meta {:doc "Return true if x is a symbol without a namespace", :arglists ([x])}, :examples []} {:sym some, :meta {:doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", :arglists ([pred coll])}, :examples []} {:sym some->, :meta {:doc "When expr is not nil, threads it into the first form (via ->),\n  and when that result is not nil, through the next etc", :arglists ([expr & forms])}, :examples []} {:sym some->>, :meta {:doc "When expr is not nil, threads it into the first form (via ->>),\n  and when that result is not nil, through the next etc", :arglists ([expr & forms])}, :examples []} {:sym some-fn, :meta {:doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])}, :examples []} {:sym some?, :meta {:doc "Returns true if x is not nil, false otherwise.", :arglists ([x])}, :examples []} {:sym sort, :meta {:doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :arglists ([coll] [comp coll])}, :examples []} {:sym sort-by, :meta {:doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :arglists ([keyfn coll] [keyfn comp coll])}, :examples []} {:sym sorted-map, :meta {:doc "keyval => key val\n  Returns a new sorted map with supplied mappings.", :arglists ([& keyvals])}, :examples []} {:sym sorted-map-by, :meta {:doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator.", :arglists ([comparator & keyvals])}, :examples []} {:sym sorted-set, :meta {:doc "Returns a new sorted set with supplied keys.", :arglists ([& keys])}, :examples []} {:sym sorted-set-by, :meta {:doc "Returns a new sorted set with supplied keys, using the supplied comparator.", :arglists ([comparator & keys])}, :examples []} {:sym sorted?, :meta {:doc "Returns true if coll satisfies ISorted", :arglists ([x])}, :examples []} {:sym special-symbol?, :meta {:doc "Returns true if x names a special form", :arglists ([x])}, :examples []} {:sym specify, :meta {:doc "Identical to specify! but does not mutate its first argument. The first\n  argument must be an ICloneable instance.", :arglists ([expr & impls])}, :examples []} {:sym specify!, :meta {:doc "Identical to reify but mutates its first argument.", :arglists ([expr & impls])}, :examples []} {:sym split-at, :meta {:doc "Returns a vector of [(take n coll) (drop n coll)]", :arglists ([n coll])}, :examples []} {:sym split-with, :meta {:doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]", :arglists ([pred coll])}, :examples []} {:sym spread, :meta {:doc nil, :arglists ([arglist])}, :examples []} {:sym str, :meta {:doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", :arglists ([] [x] [x & ys])}, :examples []} {:sym string-hash-cache, :meta {:doc nil, :arglists nil}, :examples []} {:sym string-hash-cache-count, :meta {:doc nil, :arglists nil}, :examples []} {:sym string-iter, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym string-print, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym string?, :meta {:doc "Returns true if x is a JavaScript string.", :arglists ([x])}, :examples []} {:sym subs, :meta {:doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :arglists ([s start] [s start end])}, :examples []} {:sym subseq, :meta {:doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :arglists ([sc test key] [sc start-test start-key end-test end-key])}, :examples []} {:sym subvec, :meta {:doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :arglists ([v start] [v start end])}, :examples []} {:sym swap!, :meta {:doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :arglists ([a f] [a f x] [a f x y] [a f x y & more])}, :examples []} {:sym swap-vals!, :meta {:doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap.", :arglists ([a f] [a f x] [a f x y] [a f x y & more])}, :examples []} {:sym symbol, :meta {:doc "Returns a Symbol with the given namespace and name.", :arglists ([name] [ns name])}, :examples []} {:sym symbol-identical?, :meta {:doc "Efficient test to determine that two symbols are identical.", :arglists ([x y])}, :examples []} {:sym symbol?, :meta {:doc "Return true if x is a Symbol", :arglists ([x])}, :examples []} {:sym system-time, :meta {:doc "Returns highest resolution time offered by host in milliseconds.", :arglists ([])}, :examples []} {:sym tagged-literal, :meta {:doc "Construct a data representation of a tagged literal from a\n  tag symbol and a form.", :arglists ([tag form])}, :examples []} {:sym tagged-literal?, :meta {:doc "Return true if the value is the data representation of a tagged literal", :arglists ([value])}, :examples []} {:sym take, :meta {:doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :arglists ([n] [n coll])}, :examples []} {:sym take-last, :meta {:doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", :arglists ([n coll])}, :examples []} {:sym take-nth, :meta {:doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.", :arglists ([n] [n coll])}, :examples []} {:sym take-while, :meta {:doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :arglists ([pred] [pred coll])}, :examples []} {:sym test, :meta {:doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception", :arglists ([v])}, :examples []} {:sym this-as, :meta {:doc "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided.", :arglists ([name & body])}, :examples []} {:sym time, :meta {:doc "Evaluates expr and prints the time it took. Returns the value of expr.", :arglists ([expr])}, :examples []} {:sym to-array, :meta {:doc "Naive impl of to-array as a start.", :arglists ([s])}, :examples []} {:sym to-array-2d, :meta {:doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll.", :arglists ([coll])}, :examples []} {:sym trampoline, :meta {:doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", :arglists ([f] [f & args])}, :examples []} {:sym transduce, :meta {:doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :arglists ([xform f coll] [xform f init coll])}, :examples []} {:sym transformer-iterator, :meta {:doc nil, :arglists ([xform sourceIter multi])}, :examples []} {:sym transient, :meta {:doc "Returns a new, transient version of the collection, in constant time.", :arglists ([coll])}, :examples []} {:sym tree-seq, :meta {:doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n  branch? must be a fn of one arg that returns true if passed a node\n  that can have children (but may not).  children must be a fn of one\n  arg that returns a sequence of the children. Will only be called on\n  nodes for which branch? returns true. Root is the root node of the\n  tree.", :arglists ([branch? children root])}, :examples []} {:sym true?, :meta {:doc "Returns true if x is the value true, false otherwise.", :arglists ([x])}, :examples []} {:sym truth_, :meta {:doc "Internal - do not use!", :arglists ([x])}, :examples []} {:sym type, :meta {:doc "Return x's constructor.", :arglists ([x])}, :examples []} {:sym type->str, :meta {:doc nil, :arglists ([ty])}, :examples []} {:sym unchecked-add, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists ([] [x] [x y] [x y & more])}, :examples []} {:sym unchecked-add-int, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists ([] [x] [x y] [x y & more])}, :examples []} {:sym unchecked-byte, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-char, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-dec, :meta {:doc "Returns a number one less than x, an int.", :arglists ([x])}, :examples []} {:sym unchecked-dec-int, :meta {:doc "Returns a number one less than x, an int.", :arglists ([x])}, :examples []} {:sym unchecked-divide-int, :meta {:doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :arglists ([x] [x y] [x y & more])}, :examples []} {:sym unchecked-double, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-float, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-get, :meta {:doc "INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis.", :arglists ([obj key])}, :examples []} {:sym unchecked-inc, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-inc-int, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-int, :meta {:doc "Coerce to int by stripping decimal places.", :arglists ([x])}, :examples []} {:sym unchecked-long, :meta {:doc "Coerce to long by stripping decimal places. Identical to `int'.", :arglists ([x])}, :examples []} {:sym unchecked-multiply, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists ([] [x] [x y] [x y & more])}, :examples []} {:sym unchecked-multiply-int, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists ([] [x] [x y] [x y & more])}, :examples []} {:sym unchecked-negate, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-negate-int, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-remainder-int, :meta {:doc nil, :arglists ([x n])}, :examples []} {:sym unchecked-set, :meta {:doc "INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis.", :arglists ([obj key val])}, :examples []} {:sym unchecked-short, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym unchecked-subtract, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists ([x] [x y] [x y & more])}, :examples []} {:sym unchecked-subtract-int, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists ([x] [x y] [x y & more])}, :examples []} {:sym undefined?, :meta {:doc "Returns true if x identical to the JavaScript undefined value.", :arglists ([x])}, :examples []} {:sym underive, :meta {:doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :arglists ([tag parent] [h tag parent])}, :examples []} {:sym unreduced, :meta {:doc "If x is reduced?, returns (deref x), else returns x", :arglists ([x])}, :examples []} {:sym unsafe-bit-and, :meta {:doc nil, :arglists ([x y] [x y & more])}, :examples []} {:sym unsafe-cast, :meta {:doc "EXPERIMENTAL: Subject to change. Unsafely cast a value to a different type.", :arglists ([t x])}, :examples []} {:sym unsigned-bit-shift-right, :meta {:doc "Bitwise shift right with zero fill", :arglists ([x n])}, :examples []} {:sym update, :meta {:doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :arglists ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more])}, :examples []} {:sym update-in, :meta {:doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :arglists ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args])}, :examples []} {:sym uri?, :meta {:doc "Returns true X is a goog.Uri instance.", :arglists ([x])}, :examples []} {:sym use, :meta {:doc "Like require, but referring vars specified by the mandatory\n  :only option.\n\n  Example:\n\n  The following would load the library clojure.set while referring\n  the intersection var.\n\n  (use '[clojure.set :only [intersection]])", :arglists ([& args])}, :examples []} {:sym use-macros, :meta {:doc "Similar to use but only for macros.", :arglists ([& args])}, :examples []} {:sym uuid, :meta {:doc nil, :arglists ([s])}, :examples []} {:sym uuid?, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym val, :meta {:doc "Returns the value in the map entry.", :arglists ([map-entry])}, :examples []} {:sym vals, :meta {:doc "Returns a sequence of the map's values.", :arglists ([hash-map])}, :examples []} {:sym var?, :meta {:doc "Returns true if v is of type cljs.core.Var", :arglists ([v])}, :examples []} {:sym vary-meta, :meta {:doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :arglists ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args])}, :examples []} {:sym vec, :meta {:doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified.", :arglists ([coll])}, :examples []} {:sym vector, :meta {:doc "Creates a new vector containing the args.", :arglists ([& args])}, :examples []} {:sym vector?, :meta {:doc "Return true if x satisfies IVector", :arglists ([x])}, :examples []} {:sym volatile!, :meta {:doc "Creates and returns a Volatile with an initial value of val.", :arglists ([val])}, :examples []} {:sym volatile?, :meta {:doc "Returns true if x is a volatile.", :arglists ([x])}, :examples []} {:sym vreset!, :meta {:doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", :arglists ([vol newval])}, :examples []} {:sym vswap!, :meta {:doc "Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in.", :arglists ([vol f & args])}, :examples []} {:sym when, :meta {:doc "Evaluates test. If logical true, evaluates body in an implicit do.", :arglists ([test & body])}, :examples []} {:sym when-first, :meta {:doc "bindings => x xs\n\n  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once", :arglists ([bindings & body])}, :examples []} {:sym when-let, :meta {:doc "bindings => binding-form test\n\n  When test is true, evaluates body with binding-form bound to the value of test", :arglists ([bindings & body])}, :examples []} {:sym when-not, :meta {:doc "Evaluates test. If logical false, evaluates body in an implicit do.", :arglists ([test & body])}, :examples []} {:sym when-some, :meta {:doc "bindings => binding-form test\n\n   When test is not nil, evaluates body with binding-form bound to the\n   value of test", :arglists ([bindings & body])}, :examples []} {:sym while, :meta {:doc "Repeatedly executes body while test expression is true. Presumes\n  some side-effect will cause test to become false/nil. Returns nil", :arglists ([test & body])}, :examples []} {:sym with-meta, :meta {:doc "Returns an object of the same type and value as obj, with\n  map m as its metadata.", :arglists ([o meta])}, :examples []} {:sym with-out-str, :meta {:doc "Evaluates exprs in a context in which *print-fn* is bound to .append\n  on a fresh StringBuffer.  Returns the string created by any nested\n  printing calls.", :arglists ([& body])}, :examples []} {:sym with-redefs, :meta {:doc "binding => var-symbol temp-value-expr\n\n  Temporarily redefines vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its var.  After the body is\n  executed, the root values of all the vars will be set back to their\n  old values. Useful for mocking out functions during testing.", :arglists ([bindings & body])}, :examples []} {:sym write-all, :meta {:doc nil, :arglists ([writer & ss])}, :examples []} {:sym zero?, :meta {:doc "Returns true if num is zero, else false", :arglists ([x])}, :examples []} {:sym zipmap, :meta {:doc "Returns a map with the keys mapped to the corresponding vals.", :arglists ([keys vals])}, :examples []}], adzerk.boot-reload.websocket [{:sym IWebSocket, :meta {:doc nil, :arglists nil}, :examples []} {:sym open?, :meta {:doc nil, :arglists ([this])}, :examples []} {:sym websocket-connection, :meta {:doc nil, :arglists ([] [auto-reconnect?] [auto-reconnect? next-reconnect-fn])}, :examples []}], cljs.tools.reader.reader-types [{:sym ->IndexingPushbackReader, :meta {:doc nil, :arglists ([rdr line column line-start? prev prev-column file-name])}, :examples []} {:sym ->NodeReadableReader, :meta {:doc nil, :arglists ([readable buf])}, :examples []} {:sym ->PushbackReader, :meta {:doc nil, :arglists ([rdr buf buf-len buf-pos])}, :examples []} {:sym ->SourceLoggingPushbackReader, :meta {:doc nil, :arglists ([rdr line column line-start? prev prev-column file-name frames])}, :examples []} {:sym ->StringReader, :meta {:doc nil, :arglists ([s s-len s-pos])}, :examples []} {:sym IPushbackReader, :meta {:doc nil, :arglists nil}, :examples []} {:sym IndexingPushbackReader, :meta {:doc nil, :arglists nil}, :examples []} {:sym IndexingReader, :meta {:doc nil, :arglists nil}, :examples []} {:sym NodeReadableReader, :meta {:doc nil, :arglists nil}, :examples []} {:sym PushbackReader, :meta {:doc nil, :arglists nil}, :examples []} {:sym Reader, :meta {:doc nil, :arglists nil}, :examples []} {:sym SourceLoggingPushbackReader, :meta {:doc nil, :arglists nil}, :examples []} {:sym StringReader, :meta {:doc nil, :arglists nil}, :examples []} {:sym get-column-number, :meta {:doc "Returns the column number of the next character to be read from the stream", :arglists ([reader])}, :examples []} {:sym get-file-name, :meta {:doc "Returns the file name the reader is reading from, or nil", :arglists ([reader])}, :examples []} {:sym get-line-number, :meta {:doc "Returns the line number of the next character to be read from the stream", :arglists ([reader])}, :examples []} {:sym indexing-push-back-reader, :meta {:doc "Creates an IndexingPushbackReader from a given string or PushbackReader", :arglists ([s-or-rdr] [s-or-rdr buf-len] [s-or-rdr buf-len file-name])}, :examples []} {:sym indexing-reader?, :meta {:doc "Returns true if the reader satisfies IndexingReader", :arglists ([rdr])}, :examples []} {:sym line-start?, :meta {:doc "Returns true if rdr is an IndexingReader and the current char starts a new line", :arglists ([rdr])}, :examples []} {:sym log-source, :meta {:doc "If reader is a SourceLoggingPushbackReader, execute body in a source\n  logging context. Otherwise, execute body, returning the result.", :arglists ([reader & body])}, :examples []} {:sym log-source*, :meta {:doc nil, :arglists ([reader f])}, :examples []} {:sym merge-meta, :meta {:doc "Returns an object of the same type and value as `obj`, with its\nmetadata merged over `m`.", :arglists ([obj m])}, :examples []} {:sym node-readable-push-back-reader, :meta {:doc nil, :arglists ([readable])}, :examples []} {:sym peek-char, :meta {:doc "Returns the next char from the Reader without removing it from the reader stream", :arglists ([reader])}, :examples []} {:sym read-char, :meta {:doc "Returns the next char from the Reader, nil if the end of stream has been reached", :arglists ([reader])}, :examples []} {:sym read-line, :meta {:doc "Reads a line from the reader or from *in* if no reader is specified", :arglists ([rdr])}, :examples []} {:sym source-logging-push-back-reader, :meta {:doc "Creates a SourceLoggingPushbackReader from a given string or PushbackReader", :arglists ([s-or-rdr] [s-or-rdr buf-len] [s-or-rdr buf-len file-name])}, :examples []} {:sym source-logging-reader?, :meta {:doc nil, :arglists ([rdr])}, :examples []} {:sym string-push-back-reader, :meta {:doc "Creates a PushbackReader from a given string", :arglists ([s] [s buf-len])}, :examples []} {:sym string-reader, :meta {:doc "Creates a StringReader from a given string", :arglists ([s])}, :examples []} {:sym unread, :meta {:doc "Pushes back a single character on to the stream", :arglists ([reader ch])}, :examples []}], cljs.env [{:sym *compiler*, :meta {:doc nil, :arglists nil}, :examples []} {:sym default-compiler-env, :meta {:doc nil, :arglists ([] [options])}, :examples []}], cljs.core.async [{:sym <!, :meta {:doc "takes a val from port. Must be called inside a (go ...) block. Will\n  return nil if closed. Will park if nothing is available.\n  Returns true unless port is already closed", :arglists ([port])}, :examples []} {:sym >!, :meta {:doc "puts a val into port. nil values are not allowed. Must be called\n  inside a (go ...) block. Will park if no buffer space is available.\n  Returns true unless port is already closed.", :arglists ([port val])}, :examples []} {:sym Mix, :meta {:doc nil, :arglists nil}, :examples []} {:sym Mult, :meta {:doc nil, :arglists nil}, :examples []} {:sym Mux, :meta {:doc nil, :arglists nil}, :examples []} {:sym Pub, :meta {:doc nil, :arglists nil}, :examples []} {:sym admix, :meta {:doc "Adds ch as an input to the mix", :arglists ([mix ch])}, :examples []} {:sym admix*, :meta {:doc nil, :arglists ([m ch])}, :examples []} {:sym alts!, :meta {:doc "Completes at most one of several channel operations. Must be called\n   inside a (go ...) block. ports is a vector of channel endpoints,\n   which can be either a channel to take from or a vector of\n  [channel-to-put-to val-to-put], in any combination. Takes will be\n  made as if by <!, and puts will be made as if by >!. Unless\n  the :priority option is true, if more than one port operation is\n  ready a non-deterministic choice will be made. If no operation is\n  ready and a :default value is supplied, [default-val :default] will\n  be returned, otherwise alts! will park until the first operation to\n  become ready completes. Returns [val port] of the completed\n  operation, where val is the value taken for takes, and a\n  boolean (true unless already closed, as per put!) for puts.\n\n  opts are passed as :key val ... Supported options:\n\n  :default val - the value to use if none of the operations are immediately ready\n  :priority true - (default nil) when true, the operations will be tried in order.\n\n  Note: there is no guarantee that the port exps or val exprs will be\n  used, nor in what order should they be, so they should not be\n  depended upon for side effects.", :arglists ([ports & {:as opts}])}, :examples []} {:sym buffer, :meta {:doc "Returns a fixed buffer of size n. When full, puts will block/park.", :arglists ([n])}, :examples []} {:sym chan, :meta {:doc "Creates a channel with an optional buffer, an optional transducer (like (map f),\n  (filter p) etc or a composition thereof), and an optional exception handler.\n  If buf-or-n is a number, will create and use a fixed buffer of that size. If a\n  transducer is supplied a buffer must be specified. ex-handler must be a\n  fn of one argument - if an exception occurs during transformation it will be called\n  with the thrown value as an argument, and any non-nil return value will be placed\n  in the channel.", :arglists ([] [buf-or-n] [buf-or-n xform] [buf-or-n xform ex-handler])}, :examples []} {:sym close!, :meta {:doc nil, :arglists ([port])}, :examples []} {:sym do-alts, :meta {:doc "returns derefable [val port] if immediate, nil if enqueued", :arglists ([fret ports opts])}, :examples []} {:sym dropping-buffer, :meta {:doc "Returns a buffer of size n. When full, puts will complete but\n  val will be dropped (no transfer).", :arglists ([n])}, :examples []} {:sym filter<, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([p ch] [p ch buf-or-n])}, :examples []} {:sym filter>, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([p ch])}, :examples []} {:sym into, :meta {:doc "Returns a channel containing the single (collection) result of the\n  items taken from the channel conjoined to the supplied\n  collection. ch must close before into produces a result.", :arglists ([coll ch])}, :examples []} {:sym ioc-alts!, :meta {:doc nil, :arglists ([state cont-block ports & {:as opts}])}, :examples []} {:sym map, :meta {:doc "Takes a function and a collection of source channels, and returns a\n  channel which contains the values produced by applying f to the set\n  of first items taken from each source channel, followed by applying\n  f to the set of second items from each channel, until any one of the\n  channels is closed, at which point the output channel will be\n  closed. The returned channel will be unbuffered by default, or a\n  buf-or-n can be supplied", :arglists ([f chs] [f chs buf-or-n])}, :examples []} {:sym map<, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([f ch])}, :examples []} {:sym map>, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([f ch])}, :examples []} {:sym mapcat<, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([f in] [f in buf-or-n])}, :examples []} {:sym mapcat>, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([f out] [f out buf-or-n])}, :examples []} {:sym merge, :meta {:doc "Takes a collection of source channels and returns a channel which\n  contains all values taken from them. The returned channel will be\n  unbuffered by default, or a buf-or-n can be supplied. The channel\n  will close after all the source channels have closed.", :arglists ([chs] [chs buf-or-n])}, :examples []} {:sym mix, :meta {:doc "Creates and returns a mix of one or more input channels which will\n  be put on the supplied out channel. Input sources can be added to\n  the mix with 'admix', and removed with 'unmix'. A mix supports\n  soloing, muting and pausing multiple inputs atomically using\n  'toggle', and can solo using either muting or pausing as determined\n  by 'solo-mode'.\n\n  Each channel can have zero or more boolean modes set via 'toggle':\n\n  :solo - when true, only this (ond other soloed) channel(s) will appear\n          in the mix output channel. :mute and :pause states of soloed\n          channels are ignored. If solo-mode is :mute, non-soloed\n          channels are muted, if :pause, non-soloed channels are\n          paused.\n\n  :mute - muted channels will have their contents consumed but not included in the mix\n  :pause - paused channels will not have their contents consumed (and thus also not included in the mix)\n", :arglists ([out])}, :examples []} {:sym mult, :meta {:doc "Creates and returns a mult(iple) of the supplied channel. Channels\n  containing copies of the channel can be created with 'tap', and\n  detached with 'untap'.\n\n  Each item is distributed to all taps in parallel and synchronously,\n  i.e. each tap must accept before the next item is distributed. Use\n  buffering/windowing to prevent slow taps from holding up the mult.\n\n  Items received when there are no taps get dropped.\n\n  If a tap puts to a closed channel, it will be removed from the mult.", :arglists ([ch])}, :examples []} {:sym muxch*, :meta {:doc nil, :arglists ([_])}, :examples []} {:sym offer!, :meta {:doc "Puts a val into port if it's possible to do so immediately.\n  nil values are not allowed. Never blocks. Returns true if offer succeeds.", :arglists ([port val])}, :examples []} {:sym onto-chan, :meta {:doc "Puts the contents of coll into the supplied channel.\n\n  By default the channel will be closed after the items are copied,\n  but can be determined by the close? parameter.\n\n  Returns a channel which will close after the items are copied.", :arglists ([ch coll] [ch coll close?])}, :examples []} {:sym partition, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([n ch] [n ch buf-or-n])}, :examples []} {:sym partition-by, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([f ch] [f ch buf-or-n])}, :examples []} {:sym pipe, :meta {:doc "Takes elements from the from channel and supplies them to the to\n   channel. By default, the to channel will be closed when the from\n   channel closes, but can be determined by the close?  parameter. Will\n   stop consuming the from channel if the to channel closes", :arglists ([from to] [from to close?])}, :examples []} {:sym pipeline, :meta {:doc "Takes elements from the from channel and supplies them to the to\n  channel, subject to the transducer xf, with parallelism n. Because\n  it is parallel, the transducer will be applied independently to each\n  element, not across elements, and may produce zero or more outputs\n  per input.  Outputs will be returned in order relative to the\n  inputs. By default, the to channel will be closed when the from\n  channel closes, but can be determined by the close?  parameter. Will\n  stop consuming the from channel if the to channel closes.\n\n  Note this is supplied for API compatibility with the Clojure version.\n  Values of N > 1 will not result in actual concurrency in a\n  single-threaded runtime.", :arglists ([n to xf from] [n to xf from close?] [n to xf from close? ex-handler])}, :examples []} {:sym pipeline-async, :meta {:doc "Takes elements from the from channel and supplies them to the to\n  channel, subject to the async function af, with parallelism n. af\n  must be a function of two arguments, the first an input value and\n  the second a channel on which to place the result(s). af must close!\n  the channel before returning.  The presumption is that af will\n  return immediately, having launched some asynchronous operation\n  whose completion/callback will manipulate the result channel. Outputs\n  will be returned in order relative to  the inputs. By default, the to\n  channel will be closed when the from channel closes, but can be\n  determined by the close?  parameter. Will stop consuming the from\n  channel if the to channel closes.", :arglists ([n to af from] [n to af from close?])}, :examples []} {:sym poll!, :meta {:doc "Takes a val from port if it's possible to do so immediately.\n  Never blocks. Returns value if successful, nil otherwise.", :arglists ([port])}, :examples []} {:sym promise-chan, :meta {:doc "Creates a promise channel with an optional transducer, and an optional\n  exception-handler. A promise channel can take exactly one value that consumers\n  will receive. Once full, puts complete but val is dropped (no transfer).\n  Consumers will block until either a value is placed in the channel or the\n  channel is closed. See chan for the semantics of xform and ex-handler.", :arglists ([] [xform] [xform ex-handler])}, :examples []} {:sym pub, :meta {:doc "Creates and returns a pub(lication) of the supplied channel,\n  partitioned into topics by the topic-fn. topic-fn will be applied to\n  each value on the channel and the result will determine the 'topic'\n  on which that value will be put. Channels can be subscribed to\n  receive copies of topics using 'sub', and unsubscribed using\n  'unsub'. Each topic will be handled by an internal mult on a\n  dedicated channel. By default these internal channels are\n  unbuffered, but a buf-fn can be supplied which, given a topic,\n  creates a buffer with desired properties.\n\n  Each item is distributed to all subs in parallel and synchronously,\n  i.e. each sub must accept before the next item is distributed. Use\n  buffering/windowing to prevent slow subs from holding up the pub.\n\n  Items received when there are no matching subs get dropped.\n\n  Note that if buf-fns are used then each topic is handled\n  asynchronously, i.e. if a channel is subscribed to more than one\n  topic it should not expect them to be interleaved identically with\n  the source.", :arglists ([ch topic-fn] [ch topic-fn buf-fn])}, :examples []} {:sym put!, :meta {:doc "Asynchronously puts a val into port, calling fn0 (if supplied) when\n   complete. nil values are not allowed. Will throw if closed. If\n   on-caller? (default true) is true, and the put is immediately\n   accepted, will call fn0 on calling thread.  Returns nil.", :arglists ([port val] [port val fn1] [port val fn1 on-caller?])}, :examples []} {:sym reduce, :meta {:doc "f should be a function of 2 arguments. Returns a channel containing\n  the single result of applying f to init and the first item from the\n  channel, then applying f to that result and the 2nd item, etc. If\n  the channel closes without yielding items, returns init and f is not\n  called. ch must close before reduce produces a result.", :arglists ([f init ch])}, :examples []} {:sym remove<, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([p ch] [p ch buf-or-n])}, :examples []} {:sym remove>, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([p ch])}, :examples []} {:sym sliding-buffer, :meta {:doc "Returns a buffer of size n. When full, puts will complete, and be\n  buffered, but oldest elements in buffer will be dropped (not\n  transferred).", :arglists ([n])}, :examples []} {:sym solo-mode, :meta {:doc "Sets the solo mode of the mix. mode must be one of :mute or :pause", :arglists ([mix mode])}, :examples []} {:sym solo-mode*, :meta {:doc nil, :arglists ([m mode])}, :examples []} {:sym split, :meta {:doc "Takes a predicate and a source channel and returns a vector of two\n  channels, the first of which will contain the values for which the\n  predicate returned true, the second those for which it returned\n  false.\n\n  The out channels will be unbuffered by default, or two buf-or-ns can\n  be supplied. The channels will close after the source channel has\n  closed.", :arglists ([p ch] [p ch t-buf-or-n f-buf-or-n])}, :examples []} {:sym sub, :meta {:doc "Subscribes a channel to a topic of a pub.\n\n  By default the channel will be closed when the source closes,\n  but can be determined by the close? parameter.", :arglists ([p topic ch] [p topic ch close?])}, :examples []} {:sym sub*, :meta {:doc nil, :arglists ([p v ch close?])}, :examples []} {:sym take, :meta {:doc "Returns a channel that will return, at most, n items from ch. After n items\n   have been returned, or ch has been closed, the return chanel will close.\n\n  The output channel is unbuffered by default, unless buf-or-n is given.", :arglists ([n ch] [n ch buf-or-n])}, :examples []} {:sym take!, :meta {:doc "Asynchronously takes a val from port, passing to fn1. Will pass nil\n   if closed. If on-caller? (default true) is true, and value is\n   immediately available, will call fn1 on calling thread.\n   Returns nil.", :arglists ([port fn1] [port fn1 on-caller?])}, :examples []} {:sym tap, :meta {:doc "Copies the mult source onto the supplied channel.\n\n  By default the channel will be closed when the source closes,\n  but can be determined by the close? parameter.", :arglists ([mult ch] [mult ch close?])}, :examples []} {:sym tap*, :meta {:doc nil, :arglists ([m ch close?])}, :examples []} {:sym timeout, :meta {:doc "Returns a channel that will close after msecs", :arglists ([msecs])}, :examples []} {:sym to-chan, :meta {:doc "Creates and returns a channel which contains the contents of coll,\n  closing when exhausted.", :arglists ([coll])}, :examples []} {:sym toggle, :meta {:doc "Atomically sets the state(s) of one or more channels in a mix. The\n  state map is a map of channels -> channel-state-map. A\n  channel-state-map is a map of attrs -> boolean, where attr is one or\n  more of :mute, :pause or :solo. Any states supplied are merged with\n  the current state.\n\n  Note that channels can be added to a mix via toggle, which can be\n  used to add channels in a particular (e.g. paused) state.", :arglists ([mix state-map])}, :examples []} {:sym toggle*, :meta {:doc nil, :arglists ([m state-map])}, :examples []} {:sym transduce, :meta {:doc "async/reduces a channel with a transformation (xform f).\n  Returns a channel containing the result.  ch must close before\n  transduce produces a result.", :arglists ([xform f init ch])}, :examples []} {:sym unblocking-buffer?, :meta {:doc "Returns true if a channel created with buff will never block. That is to say,\n   puts into this buffer will never cause the buffer to be full. ", :arglists ([buff])}, :examples []} {:sym unique, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([ch] [ch buf-or-n])}, :examples []} {:sym unmix, :meta {:doc "Removes ch as an input to the mix", :arglists ([mix ch])}, :examples []} {:sym unmix*, :meta {:doc nil, :arglists ([m ch])}, :examples []} {:sym unmix-all, :meta {:doc "removes all inputs from the mix", :arglists ([mix])}, :examples []} {:sym unmix-all*, :meta {:doc nil, :arglists ([m])}, :examples []} {:sym unsub, :meta {:doc "Unsubscribes a channel from a topic of a pub", :arglists ([p topic ch])}, :examples []} {:sym unsub*, :meta {:doc nil, :arglists ([p v ch])}, :examples []} {:sym unsub-all, :meta {:doc "Unsubscribes all channels from a pub, or a topic of a pub", :arglists ([p] [p topic])}, :examples []} {:sym unsub-all*, :meta {:doc nil, :arglists ([p] [p v])}, :examples []} {:sym untap, :meta {:doc "Disconnects a target channel from a mult", :arglists ([mult ch])}, :examples []} {:sym untap*, :meta {:doc nil, :arglists ([m ch])}, :examples []} {:sym untap-all, :meta {:doc "Disconnects all target channels from a mult", :arglists ([mult])}, :examples []} {:sym untap-all*, :meta {:doc nil, :arglists ([m])}, :examples []}], adzerk.boot-reload.client [{:sym connect, :meta {:doc nil, :arglists ([url] [url opts])}, :examples []} {:sym handle, :meta {:doc nil, :arglists nil}, :examples []} {:sym patch-goog-base!, :meta {:doc nil, :arglists ([])}, :examples []} {:sym resolve-url, :meta {:doc nil, :arglists ([url ws-host])}, :examples []}], cljs.core.async.impl.buffers [{:sym ->DroppingBuffer, :meta {:doc nil, :arglists ([buf n])}, :examples []} {:sym ->FixedBuffer, :meta {:doc nil, :arglists ([buf n])}, :examples []} {:sym ->PromiseBuffer, :meta {:doc nil, :arglists ([val])}, :examples []} {:sym ->RingBuffer, :meta {:doc nil, :arglists ([head tail length arr])}, :examples []} {:sym ->SlidingBuffer, :meta {:doc nil, :arglists ([buf n])}, :examples []} {:sym DroppingBuffer, :meta {:doc nil, :arglists nil}, :examples []} {:sym FixedBuffer, :meta {:doc nil, :arglists nil}, :examples []} {:sym PromiseBuffer, :meta {:doc nil, :arglists nil}, :examples []} {:sym RingBuffer, :meta {:doc nil, :arglists nil}, :examples []} {:sym SlidingBuffer, :meta {:doc nil, :arglists nil}, :examples []} {:sym acopy, :meta {:doc nil, :arglists ([src src-start dest dest-start len])}, :examples []} {:sym dropping-buffer, :meta {:doc nil, :arglists ([n])}, :examples []} {:sym fixed-buffer, :meta {:doc nil, :arglists ([n])}, :examples []} {:sym promise-buffer, :meta {:doc nil, :arglists ([])}, :examples []} {:sym ring-buffer, :meta {:doc nil, :arglists ([n])}, :examples []} {:sym sliding-buffer, :meta {:doc nil, :arglists ([n])}, :examples []}], cljs.support [{:sym assert-args, :meta {:doc "Internal - do not use!", :arglists ([fnname & pairs])}, :examples []}], cljs.core.async.impl.protocols [{:sym Buffer, :meta {:doc nil, :arglists nil}, :examples []} {:sym Channel, :meta {:doc nil, :arglists nil}, :examples []} {:sym Handler, :meta {:doc nil, :arglists nil}, :examples []} {:sym MAX-QUEUE-SIZE, :meta {:doc nil, :arglists nil}, :examples []} {:sym ReadPort, :meta {:doc nil, :arglists nil}, :examples []} {:sym UnblockingBuffer, :meta {:doc nil, :arglists nil}, :examples []} {:sym WritePort, :meta {:doc nil, :arglists nil}, :examples []} {:sym active?, :meta {:doc "returns true if has callback. Must work w/o lock", :arglists ([h])}, :examples []} {:sym add!, :meta {:doc nil, :arglists ([b] [b itm])}, :examples []} {:sym add!*, :meta {:doc "if room, add item to the buffer, returns b, called under chan mutex", :arglists ([b itm])}, :examples []} {:sym blockable?, :meta {:doc "returns true if this handler may be blocked, otherwise it must not block", :arglists ([h])}, :examples []} {:sym close!, :meta {:doc nil, :arglists ([chan])}, :examples []} {:sym close-buf!, :meta {:doc "called on chan closed under chan mutex, return ignored", :arglists ([b])}, :examples []} {:sym closed?, :meta {:doc nil, :arglists ([chan])}, :examples []} {:sym commit, :meta {:doc "commit to fulfilling its end of the transfer, returns cb. Must be called within lock", :arglists ([h])}, :examples []} {:sym full?, :meta {:doc "returns true if buffer cannot accept put", :arglists ([b])}, :examples []} {:sym put!, :meta {:doc "derefable boolean (false if already closed) if handled, nil if put was enqueued.\n                               Must throw on nil val.", :arglists ([port val fn1-handler])}, :examples []} {:sym remove!, :meta {:doc "remove and return next item from buffer, called under chan mutex", :arglists ([b])}, :examples []} {:sym take!, :meta {:doc "derefable val if taken, nil if take was enqueued", :arglists ([port fn1-handler])}, :examples []}], cljs.compiler.macros [{:sym emit-wrap, :meta {:doc nil, :arglists ([env & body])}, :examples []}], cljs.tools.reader.impl.inspect [{:sym inspect, :meta {:doc "Return a string description of the value supplied.\n   May be the a string version of the value itself (e.g. \"true\")\n   or it may be a description (e.g. \"an instance of Foo\").\n   If truncate is true then return a very terse version of\n   the inspection.", :arglists ([x] [truncate x])}, :examples []} {:sym inspect*, :meta {:doc nil, :arglists nil}, :examples []}], clojure.set [{:sym difference, :meta {:doc "Return a set that is the first set without elements of the remaining sets", :arglists ([s1] [s1 s2] [s1 s2 & sets])}, :examples []} {:sym index, :meta {:doc "Returns a map of the distinct values of ks in the xrel mapped to a\n  set of the maps in xrel with the corresponding values of ks.", :arglists ([xrel ks])}, :examples []} {:sym intersection, :meta {:doc "Return a set that is the intersection of the input sets", :arglists ([s1] [s1 s2] [s1 s2 & sets])}, :examples []} {:sym join, :meta {:doc "When passed 2 rels, returns the rel corresponding to the natural\n  join. When passed an additional keymap, joins on the corresponding\n  keys.", :arglists ([xrel yrel] [xrel yrel km])}, :examples []} {:sym map-invert, :meta {:doc "Returns the map with the vals mapped to the keys.", :arglists ([m])}, :examples []} {:sym project, :meta {:doc "Returns a rel of the elements of xrel with only the keys in ks", :arglists ([xrel ks])}, :examples []} {:sym rename, :meta {:doc "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap", :arglists ([xrel kmap])}, :examples []} {:sym rename-keys, :meta {:doc "Returns the map with the keys in kmap renamed to the vals in kmap", :arglists ([map kmap])}, :examples []} {:sym select, :meta {:doc "Returns a set of the elements for which pred is true", :arglists ([pred xset])}, :examples []} {:sym subset?, :meta {:doc "Is set1 a subset of set2?", :arglists ([set1 set2])}, :examples []} {:sym superset?, :meta {:doc "Is set1 a superset of set2?", :arglists ([set1 set2])}, :examples []} {:sym union, :meta {:doc "Return a set that is the union of the input sets", :arglists ([] [s1] [s1 s2] [s1 s2 & sets])}, :examples []}], process.env [{:sym NODE_ENV, :meta {:doc nil, :arglists nil}, :examples []}], cljs.tools.reader.impl.utils [{:sym ->ReaderConditional, :meta {:doc nil, :arglists ([splicing? form])}, :examples []} {:sym ReaderConditional, :meta {:doc nil, :arglists nil}, :examples []} {:sym char, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym desugar-meta, :meta {:doc "Resolves syntactical sugar in metadata", :arglists ([f])}, :examples []} {:sym ex-info?, :meta {:doc nil, :arglists ([ex])}, :examples []} {:sym last-id, :meta {:doc nil, :arglists nil}, :examples []} {:sym map->ReaderConditional, :meta {:doc nil, :arglists ([G__4804])}, :examples []} {:sym namespace-keys, :meta {:doc nil, :arglists ([ns keys])}, :examples []} {:sym newline?, :meta {:doc "Checks whether the character is a newline", :arglists ([c])}, :examples []} {:sym next-id, :meta {:doc nil, :arglists ([])}, :examples []} {:sym numeric?, :meta {:doc "Checks whether a given character is numeric", :arglists ([ch])}, :examples []} {:sym reader-conditional, :meta {:doc "Construct a data representation of a reader conditional.\n  If true, splicing? indicates read-cond-splicing.", :arglists ([form splicing?])}, :examples []} {:sym reader-conditional?, :meta {:doc "Return true if the value is the data representation of a reader conditional", :arglists ([value])}, :examples []} {:sym second', :meta {:doc nil, :arglists ([[a b]])}, :examples []} {:sym whitespace?, :meta {:doc "Checks whether a given character is whitespace", :arglists ([ch])}, :examples []} {:sym ws-rx, :meta {:doc nil, :arglists nil}, :examples []}], cljs.tagged-literals [{:sym *cljs-data-readers*, :meta {:doc nil, :arglists nil}, :examples []} {:sym ->JSValue, :meta {:doc nil, :arglists ([val])}, :examples []} {:sym JSValue, :meta {:doc nil, :arglists nil}, :examples []} {:sym read-inst, :meta {:doc nil, :arglists ([form])}, :examples []} {:sym read-js, :meta {:doc nil, :arglists ([form])}, :examples []} {:sym read-queue, :meta {:doc nil, :arglists ([form])}, :examples []} {:sym read-uuid, :meta {:doc nil, :arglists ([form])}, :examples []} {:sym valid-js-literal-key?, :meta {:doc nil, :arglists ([k])}, :examples []}], clojure.browser.net [{:sym *timeout*, :meta {:doc nil, :arglists nil}, :examples []} {:sym IConnection, :meta {:doc nil, :arglists nil}, :examples []} {:sym ICrossPageChannel, :meta {:doc nil, :arglists nil}, :examples []} {:sym IWebSocket, :meta {:doc nil, :arglists nil}, :examples []} {:sym close, :meta {:doc nil, :arglists ([this])}, :examples []} {:sym connect, :meta {:doc nil, :arglists ([this] [this opt1] [this opt1 opt2] [this opt1 opt2 opt3])}, :examples []} {:sym event-types, :meta {:doc nil, :arglists nil}, :examples []} {:sym open?, :meta {:doc nil, :arglists ([this])}, :examples []} {:sym register-service, :meta {:doc nil, :arglists ([this service-name fn] [this service-name fn encode-json?])}, :examples []} {:sym transmit, :meta {:doc nil, :arglists ([this opt] [this opt opt2] [this opt opt2 opt3] [this opt opt2 opt3 opt4] [this opt opt2 opt3 opt4 opt5])}, :examples []} {:sym websocket-connection, :meta {:doc nil, :arglists ([] [auto-reconnect?] [auto-reconnect? next-reconnect-fn])}, :examples []} {:sym xhr-connection, :meta {:doc "Returns an XhrIo connection", :arglists ([])}, :examples []} {:sym xpc-config-fields, :meta {:doc nil, :arglists nil}, :examples []} {:sym xpc-connection, :meta {:doc "When passed with a config hash-map, returns a parent\n  CrossPageChannel object. Keys in the config hash map are downcased\n  versions of the goog.net.xpc.CfgFields enum keys,\n  e.g. goog.net.xpc.CfgFields.PEER_URI becomes :peer_uri in the config\n  hash.\n\n  When passed with no args, creates a child CrossPageChannel object,\n  and the config is automatically taken from the URL param 'xpc', as\n  per the CrossPageChannel API.", :arglists ([] [config])}, :examples []}], cljs.analyzer [{:sym *allow-ns*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *allow-redef*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *analyze-deps*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *check-alias-dupes*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *checked-arrays*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *cljs-dep-set*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *cljs-file*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *cljs-macros-is-classpath*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *cljs-macros-path*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *cljs-ns*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *cljs-static-fns*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *cljs-warning-handlers*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *cljs-warnings*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *file-defs*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *fn-invoke-direct*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *load-macros*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *load-tests*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *loop-lets*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *macro-infer*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *passes*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *recur-frames*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *reload-macros*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *verbose*, :meta {:doc nil, :arglists nil}, :examples []} {:sym -cljs-macros-loaded, :meta {:doc nil, :arglists nil}, :examples []} {:sym ANY_SYM, :meta {:doc nil, :arglists nil}, :examples []} {:sym BOOLEAN_OR_SEQ, :meta {:doc nil, :arglists nil}, :examples []} {:sym BOOLEAN_SYM, :meta {:doc nil, :arglists nil}, :examples []} {:sym CLJS_CORE_MACROS_SYM, :meta {:doc nil, :arglists nil}, :examples []} {:sym CLJS_CORE_SYM, :meta {:doc nil, :arglists nil}, :examples []} {:sym CLJ_NIL_SYM, :meta {:doc nil, :arglists nil}, :examples []} {:sym DOT_SYM, :meta {:doc nil, :arglists nil}, :examples []} {:sym IGNORE_SYM, :meta {:doc nil, :arglists nil}, :examples []} {:sym JS_STAR_SYM, :meta {:doc nil, :arglists nil}, :examples []} {:sym NEW_SYM, :meta {:doc nil, :arglists nil}, :examples []} {:sym NOT_NATIVE, :meta {:doc nil, :arglists nil}, :examples []} {:sym NUMBER_SYM, :meta {:doc nil, :arglists nil}, :examples []} {:sym NUMERIC_SET, :meta {:doc nil, :arglists nil}, :examples []} {:sym SENTINEL, :meta {:doc nil, :arglists nil}, :examples []} {:sym STRING_SYM, :meta {:doc nil, :arglists nil}, :examples []} {:sym add-consts, :meta {:doc "Given a compiler state and a map from fully qualified symbols to constant\n  EDN values, update the compiler state marking these vars as const to support\n  direct substitution of these vars in source.", :arglists ([compiler-state constants-map])}, :examples []} {:sym alias->type, :meta {:doc nil, :arglists nil}, :examples []} {:sym analysis-error?, :meta {:doc nil, :arglists ([ex])}, :examples []} {:sym analyze, :meta {:doc "Given an environment, a map containing {:locals (mapping of names to bindings), :context\n  (one of :statement, :expr, :return), :ns (a symbol naming the\n  compilation ns)}, and form, returns an expression object (a map\n  containing at least :form, :op and :env keys). If expr has any (immediately)\n  nested exprs, must have :children [exprs...] entry. This will\n  facilitate code walking without knowing the details of the op set.", :arglists ([env form] [env form name] [env form name opts])}, :examples []} {:sym analyze*, :meta {:doc nil, :arglists ([env form name opts])}, :examples []} {:sym analyze-deps, :meta {:doc "Given a lib, a namespace, deps, its dependencies, env, an analysis environment\n   and opts, compiler options - analyze all of the dependencies. Required to\n   correctly analyze usage of other namespaces.", :arglists ([lib deps env] [lib deps env opts])}, :examples []} {:sym analyze-do-statements, :meta {:doc nil, :arglists ([env exprs])}, :examples []} {:sym analyze-do-statements*, :meta {:doc nil, :arglists ([env exprs])}, :examples []} {:sym analyze-dot, :meta {:doc nil, :arglists ([env target field member+ form])}, :examples []} {:sym analyze-fn-method-body, :meta {:doc nil, :arglists ([env form recur-frames])}, :examples []} {:sym analyze-fn-method-param, :meta {:doc nil, :arglists ([env])}, :examples []} {:sym analyze-fn-methods-pass2, :meta {:doc nil, :arglists ([menv locals type meths])}, :examples []} {:sym analyze-fn-methods-pass2*, :meta {:doc nil, :arglists ([menv locals type meths])}, :examples []} {:sym analyze-form, :meta {:doc nil, :arglists ([env form name opts])}, :examples []} {:sym analyze-form-seq, :meta {:doc nil, :arglists ([forms] [forms opts])}, :examples []} {:sym analyze-js-star, :meta {:doc nil, :arglists ([env jsform args form])}, :examples []} {:sym analyze-js-star*, :meta {:doc nil, :arglists ([env jsform args form])}, :examples []} {:sym analyze-js-value, :meta {:doc nil, :arglists ([env form])}, :examples []} {:sym analyze-keyword, :meta {:doc nil, :arglists ([env sym])}, :examples []} {:sym analyze-let, :meta {:doc nil, :arglists ([encl-env [_ bindings & exprs :as form] is-loop])}, :examples []} {:sym analyze-let-binding-init, :meta {:doc nil, :arglists ([env init loop-lets])}, :examples []} {:sym analyze-let-bindings, :meta {:doc nil, :arglists ([encl-env bindings])}, :examples []} {:sym analyze-let-bindings*, :meta {:doc nil, :arglists ([encl-env bindings])}, :examples []} {:sym analyze-let-body, :meta {:doc nil, :arglists ([env context exprs recur-frames loop-lets])}, :examples []} {:sym analyze-let-body*, :meta {:doc nil, :arglists ([env context exprs])}, :examples []} {:sym analyze-list, :meta {:doc nil, :arglists ([env form])}, :examples []} {:sym analyze-map, :meta {:doc nil, :arglists ([env form])}, :examples []} {:sym analyze-record, :meta {:doc nil, :arglists ([env x])}, :examples []} {:sym analyze-seq, :meta {:doc nil, :arglists ([env form name] [env form name opts])}, :examples []} {:sym analyze-seq*, :meta {:doc nil, :arglists ([op env form name opts])}, :examples []} {:sym analyze-seq*-wrap, :meta {:doc nil, :arglists ([op env form name opts])}, :examples []} {:sym analyze-set, :meta {:doc nil, :arglists ([env form])}, :examples []} {:sym analyze-symbol, :meta {:doc "Finds the var associated with sym", :arglists ([env sym])}, :examples []} {:sym analyze-vector, :meta {:doc nil, :arglists ([env form])}, :examples []} {:sym analyze-wrap-meta, :meta {:doc nil, :arglists ([expr])}, :examples []} {:sym analyzed, :meta {:doc "Mark a form as being analyzed. Assumes x satisfies IMeta. Useful to suppress\n  warnings that will have been caught by a first compiler pass.", :arglists ([x])}, :examples []} {:sym analyzed?, :meta {:doc "Returns boolean if the form has already been marked as analyzed.", :arglists ([x])}, :examples []} {:sym array-type?, :meta {:doc nil, :arglists ([t])}, :examples []} {:sym array-types, :meta {:doc nil, :arglists nil}, :examples []} {:sym ast?, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym basic-validate-ns-spec, :meta {:doc nil, :arglists ([env macros? spec])}, :examples []} {:sym build-dot-form, :meta {:doc nil, :arglists nil}, :examples []} {:sym canonicalize-import-specs, :meta {:doc nil, :arglists ([specs])}, :examples []} {:sym canonicalize-specs, :meta {:doc nil, :arglists ([specs])}, :examples []} {:sym check-invoke-arg-types, :meta {:doc nil, :arglists ([env {:keys [op], :as ast} opts])}, :examples []} {:sym check-rename-macros-inferring-missing, :meta {:doc nil, :arglists ([{:keys [name renames], :as ast} env])}, :examples []} {:sym check-use-macros, :meta {:doc nil, :arglists ([use-macros env] [use-macros missing-uses env])}, :examples []} {:sym check-use-macros-inferring-missing, :meta {:doc nil, :arglists ([{:keys [name uses use-macros], :as ast} env])}, :examples []} {:sym check-uses, :meta {:doc nil, :arglists ([uses env])}, :examples []} {:sym checked-arrays, :meta {:doc "Returns false-y, :warn, or :error based on configuration and the\n   current value of *unchecked-arrays*.", :arglists ([])}, :examples []} {:sym clj-ns->cljs-ns, :meta {:doc "Given a symbol that starts with clojure as the first segment return the\n   same symbol with the first segment replaced with cljs", :arglists ([sym])}, :examples []} {:sym cljs-map?, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym cljs-seq?, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym cljs-set?, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym cljs-vector?, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym confirm-bindings, :meta {:doc "Given env, an analysis environment env, and names, a list of symbols, confirm\n   that all correspond to declared dynamic vars.", :arglists ([env names])}, :examples []} {:sym confirm-ns, :meta {:doc "Given env, an analysis environment, and ns-sym, a symbol identifying a\n   namespace, confirm that the namespace exists. Warn if not found.", :arglists ([env ns-sym])}, :examples []} {:sym confirm-var-exist-warning, :meta {:doc nil, :arglists ([env prefix suffix])}, :examples []} {:sym confirm-var-exists, :meta {:doc nil, :arglists ([env prefix suffix] [env prefix suffix missing-fn])}, :examples []} {:sym confirm-var-exists-throw, :meta {:doc nil, :arglists ([])}, :examples []} {:sym constant-value?, :meta {:doc nil, :arglists ([{:keys [op], :as ast}])}, :examples []} {:sym constants-ns-sym, :meta {:doc "The namespace of the constants table as a symbol.", :arglists nil}, :examples []} {:sym core-name?, :meta {:doc "Is sym visible from core in the current compilation namespace?", :arglists ([env sym])}, :examples []} {:sym default-namespaces, :meta {:doc nil, :arglists nil}, :examples []} {:sym default-warning-handler, :meta {:doc nil, :arglists ([warning-type env extra])}, :examples []} {:sym dep-has-global-exports?, :meta {:doc nil, :arglists ([module])}, :examples []} {:sym desugar-ns-specs, :meta {:doc "Given an original set of ns specs desugar :include-macros and :refer-macros\n   usage into only primitive spec forms - :use, :require, :use-macros,\n   :require-macros. If a library includes a macro file of with the same name\n   as the namespace will also be desugared.", :arglists ([args])}, :examples []} {:sym dotted-symbol?, :meta {:doc nil, :arglists ([sym])}, :examples []} {:sym dump-specs, :meta {:doc "Dumps registered speced vars for a given namespace into the compiler\n  environment.", :arglists ([ns])}, :examples []} {:sym elide-analyzer-meta, :meta {:doc nil, :arglists ([m])}, :examples []} {:sym elide-env, :meta {:doc nil, :arglists ([env ast opts])}, :examples []} {:sym elide-reader-meta, :meta {:doc nil, :arglists ([m])}, :examples []} {:sym empty-env, :meta {:doc "Construct an empty analysis environment. Required to analyze forms.", :arglists ([])}, :examples []} {:sym error, :meta {:doc nil, :arglists ([env msg] [env msg cause])}, :examples []} {:sym error-message, :meta {:doc nil, :arglists nil}, :examples []} {:sym es5-allowed, :meta {:doc nil, :arglists nil}, :examples []} {:sym excluded?, :meta {:doc nil, :arglists ([env sym])}, :examples []} {:sym find-def-clash, :meta {:doc nil, :arglists ([env ns segments])}, :examples []} {:sym find-matching-method, :meta {:doc nil, :arglists ([f params])}, :examples []} {:sym fn-name-var, :meta {:doc nil, :arglists ([env locals name])}, :examples []} {:sym foreign-dep?, :meta {:doc nil, :arglists ([dep])}, :examples []} {:sym gen-constant-id, :meta {:doc nil, :arglists ([value])}, :examples []} {:sym get-col, :meta {:doc nil, :arglists ([x env])}, :examples []} {:sym get-expander, :meta {:doc "Given a sym, a symbol identifying a macro, and env, an analysis environment\n   return the corresponding Clojure macroexpander.", :arglists ([sym env])}, :examples []} {:sym get-expander*, :meta {:doc nil, :arglists ([sym env])}, :examples []} {:sym get-expander-ns, :meta {:doc nil, :arglists ([env nstr])}, :examples []} {:sym get-js-tag, :meta {:doc nil, :arglists ([form])}, :examples []} {:sym get-let-tag, :meta {:doc nil, :arglists ([name init-expr])}, :examples []} {:sym get-line, :meta {:doc nil, :arglists ([x env])}, :examples []} {:sym get-macroexpand-check-var, :meta {:doc nil, :arglists ([])}, :examples []} {:sym get-namespace, :meta {:doc nil, :arglists ([key] [cenv key])}, :examples []} {:sym get-tag, :meta {:doc nil, :arglists ([e])}, :examples []} {:sym gets, :meta {:doc nil, :arglists ([m k0 k1] [m k0 k1 k2] [m k0 k1 k2 k3])}, :examples []} {:sym has-extern?, :meta {:doc nil, :arglists ([pre] [pre externs])}, :examples []} {:sym has-extern?*, :meta {:doc nil, :arglists ([pre externs] [pre externs top])}, :examples []} {:sym implicit-import?, :meta {:doc nil, :arglists ([env prefix suffix])}, :examples []} {:sym implicit-nses, :meta {:doc nil, :arglists nil}, :examples []} {:sym infer-if, :meta {:doc nil, :arglists ([env e])}, :examples []} {:sym infer-invoke, :meta {:doc nil, :arglists ([env e])}, :examples []} {:sym infer-tag, :meta {:doc "Given env, an analysis environment, and e, an AST node, return the inferred\n   type of the node", :arglists ([env e])}, :examples []} {:sym infer-type, :meta {:doc nil, :arglists ([env ast _])}, :examples []} {:sym inferred-rename-macros, :meta {:doc nil, :arglists ([rename-macros env])}, :examples []} {:sym inferred-use-macros, :meta {:doc nil, :arglists ([use-macros env])}, :examples []} {:sym intern-macros, :meta {:doc "Given a Clojure namespace intern all macros into the ambient ClojureScript\n   analysis environment.", :arglists ([ns] [ns reload])}, :examples []} {:sym invoke-arg-type-validators, :meta {:doc nil, :arglists nil}, :examples []} {:sym invokeable-ns?, :meta {:doc "Returns true if ns is a required namespace and a JavaScript module that\n   might be invokeable as a function.", :arglists ([ns env])}, :examples []} {:sym js-module-exists?, :meta {:doc nil, :arglists ([module])}, :examples []} {:sym js-module-exists?*, :meta {:doc nil, :arglists nil}, :examples []} {:sym js-reserved, :meta {:doc nil, :arglists nil}, :examples []} {:sym js-star-interp, :meta {:doc nil, :arglists ([env s])}, :examples []} {:sym js-star-seg, :meta {:doc nil, :arglists ([s])}, :examples []} {:sym js-tag, :meta {:doc nil, :arglists ([pre] [pre tag-type] [pre tag-type externs] [pre tag-type externs top])}, :examples []} {:sym js-tag?, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym loaded-js-ns?, :meta {:doc "Check if a JavaScript namespace has been loaded. JavaScript vars are\n  not currently checked.", :arglists ([env prefix])}, :examples []} {:sym macro-autoload-ns?, :meta {:doc "Given a spec form check whether the spec namespace requires a macro file\n   of the same name. If so return true.", :arglists ([form])}, :examples []} {:sym macro-ns-name, :meta {:doc nil, :arglists ([name])}, :examples []} {:sym macroexpand-1, :meta {:doc "Given a env, an analysis environment, and form, a ClojureScript form,\n   macroexpand the form once.", :arglists ([env form])}, :examples []} {:sym macroexpand-1*, :meta {:doc nil, :arglists ([env form])}, :examples []} {:sym message, :meta {:doc nil, :arglists ([env s])}, :examples []} {:sym missing-rename-macro?, :meta {:doc nil, :arglists ([sym])}, :examples []} {:sym missing-rename?, :meta {:doc nil, :arglists ([sym cenv])}, :examples []} {:sym missing-renames, :meta {:doc nil, :arglists ([renames env])}, :examples []} {:sym missing-use-macro?, :meta {:doc nil, :arglists ([lib sym])}, :examples []} {:sym missing-use-macros, :meta {:doc nil, :arglists ([use-macros env])}, :examples []} {:sym missing-use?, :meta {:doc nil, :arglists ([lib sym cenv])}, :examples []} {:sym missing-uses, :meta {:doc nil, :arglists ([uses env])}, :examples []} {:sym munge-global-export, :meta {:doc nil, :arglists ([name])}, :examples []} {:sym munge-node-lib, :meta {:doc nil, :arglists ([name])}, :examples []} {:sym munge-path, :meta {:doc nil, :arglists ([ss])}, :examples []} {:sym namespaces, :meta {:doc nil, :arglists nil}, :examples []} {:sym node-module-dep?, :meta {:doc nil, :arglists ([module])}, :examples []} {:sym normalize-js-tag, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym ns->module-type, :meta {:doc nil, :arglists ([ns])}, :examples []} {:sym ns->relpath, :meta {:doc "Given a namespace as a symbol return the relative path. May optionally\n     provide the file extension, defaults to :cljs.", :arglists ([ns] [ns ext])}, :examples []} {:sym numeric-type?, :meta {:doc nil, :arglists ([t])}, :examples []} {:sym parse, :meta {:doc nil, :arglists nil}, :examples []} {:sym parse-import-spec, :meta {:doc nil, :arglists ([env deps spec])}, :examples []} {:sym parse-invoke, :meta {:doc nil, :arglists ([env form])}, :examples []} {:sym parse-invoke*, :meta {:doc nil, :arglists ([env [f & args :as form]])}, :examples []} {:sym parse-ns-error-msg, :meta {:doc nil, :arglists ([spec msg])}, :examples []} {:sym parse-ns-excludes, :meta {:doc nil, :arglists ([env args])}, :examples []} {:sym parse-require-spec, :meta {:doc nil, :arglists ([env macros? deps aliases spec])}, :examples []} {:sym parse-type, :meta {:doc nil, :arglists ([op env [_ tsym fields pmasks body :as form]])}, :examples []} {:sym public-name?, :meta {:doc "Is sym public?", :arglists ([ns sym])}, :examples []} {:sym register-specs, :meta {:doc "Registers speced vars found in a namespace analysis cache.", :arglists ([cached-ns])}, :examples []} {:sym replace-env-pass, :meta {:doc nil, :arglists ([new-env])}, :examples []} {:sym required?, :meta {:doc nil, :arglists ([ns env])}, :examples []} {:sym resolve*, :meta {:doc nil, :arglists nil}, :examples []} {:sym resolve-alias, :meta {:doc "Takes a namespace and an unqualified symbol and potentially returns a new\n  symbol to be used in lieu of the original.", :arglists ([ns sym])}, :examples []} {:sym resolve-existing-var, :meta {:doc "Given env, an analysis environment, and sym, a symbol, resolve an existing var.\n   Emits a warning if no such var exists.", :arglists ([env sym])}, :examples []} {:sym resolve-invokeable-ns, :meta {:doc nil, :arglists ([ns current-ns env])}, :examples []} {:sym resolve-macro-ns-alias, :meta {:doc nil, :arglists ([env name] [env name not-found])}, :examples []} {:sym resolve-macro-var, :meta {:doc "Given env, an analysis environment, and sym, a symbol, resolve a macro.", :arglists ([env sym])}, :examples []} {:sym resolve-ns-alias, :meta {:doc nil, :arglists ([env name] [env name not-found])}, :examples []} {:sym resolve-symbol, :meta {:doc nil, :arglists ([sym])}, :examples []} {:sym resolve-var, :meta {:doc "Resolve a var. Accepts a side-effecting confirm fn for producing\n   warnings about unresolved vars.", :arglists ([env sym] [env sym confirm])}, :examples []} {:sym source-info, :meta {:doc nil, :arglists ([env] [name env])}, :examples []} {:sym specials, :meta {:doc nil, :arglists nil}, :examples []} {:sym topo-sort, :meta {:doc nil, :arglists ([x get-deps] [x depth state memo-get-deps])}, :examples []} {:sym type?, :meta {:doc nil, :arglists ([env t])}, :examples []} {:sym unchecked-arrays?, :meta {:doc nil, :arglists ([])}, :examples []} {:sym use->require, :meta {:doc nil, :arglists ([env [lib & filters :as spec]])}, :examples []} {:sym used?, :meta {:doc nil, :arglists ([env sym])}, :examples []} {:sym valid-proto, :meta {:doc nil, :arglists ([x])}, :examples []} {:sym var-ast, :meta {:doc nil, :arglists ([env sym])}, :examples []} {:sym var-meta, :meta {:doc nil, :arglists ([var] [var expr-env])}, :examples []} {:sym warning, :meta {:doc nil, :arglists ([warning-type env extra])}, :examples []}], cljs.source-map [{:sym decode, :meta {:doc "Convert a v3 source map JSON object into a source map mapping\n  generated JavaScript source locations to the original\n  ClojureScript.", :arglists ([source-map] [mappings source-map])}, :examples []} {:sym decode-reverse, :meta {:doc "Convert a v3 source map JSON object into a reverse source map\n  mapping original ClojureScript source locations to the generated\n  JavaScript.", :arglists ([source-map] [mappings source-map])}, :examples []} {:sym encode, :meta {:doc "Take an internal source map representation represented as nested\n   sorted maps of file, line, column and return a source map v3 JSON\n   string.", :arglists ([m opts])}, :examples []} {:sym indexed-sources, :meta {:doc "Take a seq of source file names and return a map from\n   file number to integer index. For reverse source maps.", :arglists ([sources])}, :examples []} {:sym invert-reverse-map, :meta {:doc "Given a ClojureScript to JavaScript source map, invert it. Useful when\n   mapping JavaScript stack traces when environment support is unavailable.", :arglists ([reverse-map])}, :examples []} {:sym lines->segs, :meta {:doc "Take a nested sorted map encoding line and column information\n   for a file and return a vector of vectors of encoded segments.\n   Each vector represents a line, and the internal vectors are segments\n   representing the contents of the line.", :arglists ([lines])}, :examples []} {:sym merge-source-maps, :meta {:doc "Merge an internal source map representation of a single\n   ClojureScript file mapping original to generated with a\n   second source map mapping original JS to generated JS.\n   The is to support source maps that work through multiple\n   compilation steps like Google Closure optimization passes.", :arglists ([cljs-map js-map])}, :examples []} {:sym seg->map, :meta {:doc "Take a source map segment represented as a vector\n   and return a map.", :arglists ([seg source-map])}, :examples []} {:sym seg-combine, :meta {:doc "Combine a source map segment vector and a relative\n   source map segment vector and combine them to get\n   an absolute segment posititon information as a vector.", :arglists ([seg relseg])}, :examples []} {:sym source-compare, :meta {:doc "Take a seq of source file names and return a comparator\n   that can be used to construct a sorted map. For reverse\n   source maps.", :arglists ([sources])}, :examples []} {:sym update-result, :meta {:doc "Helper for decode. Take a source map and update it based on a\n  segment map.", :arglists ([result segmap gline])}, :examples []} {:sym update-reverse-result, :meta {:doc "Helper for decode-reverse. Take a reverse source map and\n  update it with a segment map.", :arglists ([result segmap gline])}, :examples []}], cljs.core.async.impl.ioc-helpers [{:sym ->ExceptionFrame, :meta {:doc nil, :arglists ([catch-block catch-exception finally-block continue-block prev])}, :examples []} {:sym BINDINGS-IDX, :meta {:doc nil, :arglists nil}, :examples []} {:sym CURRENT-EXCEPTION, :meta {:doc nil, :arglists nil}, :examples []} {:sym EXCEPTION-FRAMES, :meta {:doc nil, :arglists nil}, :examples []} {:sym ExceptionFrame, :meta {:doc nil, :arglists nil}, :examples []} {:sym FN-IDX, :meta {:doc nil, :arglists nil}, :examples []} {:sym STATE-IDX, :meta {:doc nil, :arglists nil}, :examples []} {:sym USER-START-IDX, :meta {:doc nil, :arglists nil}, :examples []} {:sym VALUE-IDX, :meta {:doc nil, :arglists nil}, :examples []} {:sym add-exception-frame, :meta {:doc nil, :arglists ([state catch-block catch-exception finally-block continue-block])}, :examples []} {:sym aget-object, :meta {:doc nil, :arglists ([arr idx])}, :examples []} {:sym aset-object, :meta {:doc nil, :arglists ([arr idx o])}, :examples []} {:sym finished?, :meta {:doc "Returns true if the machine is in a finished state", :arglists ([state-array])}, :examples []} {:sym map->ExceptionFrame, :meta {:doc nil, :arglists ([G__9274])}, :examples []} {:sym process-exception, :meta {:doc nil, :arglists ([state])}, :examples []} {:sym put!, :meta {:doc nil, :arglists ([state blk c val])}, :examples []} {:sym return-chan, :meta {:doc nil, :arglists ([state value])}, :examples []} {:sym run-state-machine, :meta {:doc nil, :arglists ([state])}, :examples []} {:sym run-state-machine-wrapped, :meta {:doc nil, :arglists ([state])}, :examples []} {:sym take!, :meta {:doc nil, :arglists ([state blk c])}, :examples []}], clojure.string [{:sym blank?, :meta {:doc "True is s is nil, empty, or contains only whitespace.", :arglists ([s])}, :examples []} {:sym capitalize, :meta {:doc "Converts first character of the string to upper-case, all other\n  characters to lower-case.", :arglists ([s])}, :examples []} {:sym ends-with?, :meta {:doc "True if s ends with substr.", :arglists ([s substr])}, :examples []} {:sym escape, :meta {:doc "Return a new string, using cmap to escape each character ch\n   from s as follows:\n\n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.", :arglists ([s cmap])}, :examples []} {:sym includes?, :meta {:doc "True if s includes substr.", :arglists ([s substr])}, :examples []} {:sym index-of, :meta {:doc "Return index of value (string or char) in s, optionally searching\n  forward from from-index or nil if not found.", :arglists ([s value] [s value from-index])}, :examples []} {:sym join, :meta {:doc "Returns a string of all elements in coll, as returned by (seq coll),\n  separated by an optional separator.", :arglists ([coll] [separator coll])}, :examples []} {:sym last-index-of, :meta {:doc "Return last index of value (string or char) in s, optionally\n  searching backward from from-index or nil if not found.", :arglists ([s value] [s value from-index])}, :examples []} {:sym lower-case, :meta {:doc "Converts string to all lower-case.", :arglists ([s])}, :examples []} {:sym replace, :meta {:doc "Replaces all instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).", :arglists ([s match replacement])}, :examples []} {:sym replace-first, :meta {:doc "Replaces the first instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).", :arglists ([s match replacement])}, :examples []} {:sym reverse, :meta {:doc "Returns s with its characters reversed.", :arglists ([s])}, :examples []} {:sym split, :meta {:doc "Splits string on a regular expression. Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits.", :arglists ([s re] [s re limit])}, :examples []} {:sym split-lines, :meta {:doc "Splits s on \n or \r\n.", :arglists ([s])}, :examples []} {:sym starts-with?, :meta {:doc "True if s starts with substr.", :arglists ([s substr])}, :examples []} {:sym trim, :meta {:doc "Removes whitespace from both ends of string.", :arglists ([s])}, :examples []} {:sym trim-newline, :meta {:doc "Removes all trailing newline \\n or return \\r characters from\n  string.  Similar to Perl's chomp.", :arglists ([s])}, :examples []} {:sym triml, :meta {:doc "Removes whitespace from the left side of string.", :arglists ([s])}, :examples []} {:sym trimr, :meta {:doc "Removes whitespace from the right side of string.", :arglists ([s])}, :examples []} {:sym upper-case, :meta {:doc "Converts string to all upper-case.", :arglists ([s])}, :examples []}], cljs.spec.alpha [{:sym &, :meta {:doc "takes a regex op re, and predicates. Returns a regex-op that consumes\n  input as per re but subjects the resulting value to the\n  conjunction of the predicates, and any conforming they might perform.", :arglists ([re & preds])}, :examples []} {:sym *, :meta {:doc "Returns a regex op that matches zero or more values matching\n  pred. Produces a vector of matches iff there is at least one match", :arglists ([pred-form])}, :examples []} {:sym *coll-check-limit*, :meta {:doc "The number of items validated in a collection spec'ed with 'every'", :arglists nil}, :examples []} {:sym *coll-error-limit*, :meta {:doc "The number of errors reported by explain in a collection spec'ed with 'every'", :arglists nil}, :examples []} {:sym *compile-asserts*, :meta {:doc "If true, compiler will enable spec asserts, which are then\nsubject to runtime control via check-asserts? If false, compiler\nwill eliminate all spec assert overhead. See 'assert'.\nInitially set to the negation of the ':elide-asserts' compiler option.\nDefaults to true.", :arglists nil}, :examples []} {:sym *explain-out*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *fspec-iterations*, :meta {:doc "The number of times an anonymous fn specified by fspec will be (generatively) tested during conform", :arglists nil}, :examples []} {:sym *recursion-limit*, :meta {:doc "A soft limit on how many times a branching spec (or/alt/*/opt-keys/multi-spec)\n  can be recursed through during generation. After this a\n  non-recursive branch will be chosen.", :arglists nil}, :examples []} {:sym +, :meta {:doc "Returns a regex op that matches one or more values matching\n  pred. Produces a vector of matches", :arglists ([pred-form])}, :examples []} {:sym ?, :meta {:doc "Returns a regex op that matches zero or one value matching\n  pred. Produces a single value (not a collection) if matched.", :arglists ([pred-form])}, :examples []} {:sym MAX_INT, :meta {:doc nil, :arglists nil}, :examples []} {:sym Spec, :meta {:doc nil, :arglists nil}, :examples []} {:sym Specize, :meta {:doc nil, :arglists nil}, :examples []} {:sym abbrev, :meta {:doc nil, :arglists ([form])}, :examples []} {:sym alt, :meta {:doc "Takes key+pred pairs, e.g.\n\n  (s/alt :even even? :small #(< % 42))\n\n  Returns a regex op that returns a map entry containing the key of the\n  first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return.", :arglists ([& key-pred-forms])}, :examples []} {:sym alt-impl, :meta {:doc "Do not call this directly, use 'alt'", :arglists ([ks ps forms])}, :examples []} {:sym amp-impl, :meta {:doc "Do not call this directly, use '&'", :arglists ([re preds pred-forms])}, :examples []} {:sym and, :meta {:doc "Takes predicate/spec-forms, e.g.\n\n  (s/and even? #(< % 42))\n\n  Returns a spec that returns the conformed value. Successive\n  conformed values propagate through rest of predicates.", :arglists ([& pred-forms])}, :examples []} {:sym and-spec-impl, :meta {:doc "Do not call this directly, use 'and'", :arglists ([forms preds gfn])}, :examples []} {:sym assert, :meta {:doc "spec-checking assert expression. Returns x if x is valid? according\nto spec, else throws an error with explain-data plus ::failure of\n:assertion-failed.\nCan be disabled at either compile time or runtime:\nIf *compile-asserts* is false at compile time, compiles to x. Defaults\nto the negation value of the ':elide-asserts' compiler option, or true if\nnot set.\nIf (check-asserts?) is false at runtime, always returns x. Defaults to\nvalue of 'cljs.spec.alpha/*runtime-asserts*', or false if not set. You can\ntoggle check-asserts? with (check-asserts bool).", :arglists ([spec x])}, :examples []} {:sym assert*, :meta {:doc "Do not call this directly, use 'assert'.", :arglists ([spec x])}, :examples []} {:sym cat, :meta {:doc "Takes key+pred pairs, e.g.\n\n  (s/cat :e even? :o odd?)\n\n  Returns a regex op that matches (all) values in sequence, returning a map\n  containing the keys of each pred and the corresponding value.", :arglists ([& key-pred-forms])}, :examples []} {:sym cat-impl, :meta {:doc "Do not call this directly, use 'cat'", :arglists ([ks ps forms])}, :examples []} {:sym check-asserts, :meta {:doc "Enable or disable spec asserts that have been compiled\nwith '*compile-asserts*' true.  See 'assert'.\nInitially set to boolean value of cljs.spec.alpha/*runtime-asserts*.\nDefaults to false.", :arglists ([flag])}, :examples []} {:sym check-asserts?, :meta {:doc "Returns the value set by check-asserts.", :arglists ([])}, :examples []} {:sym coll-of, :meta {:doc "Returns a spec for a collection of items satisfying pred. Unlike\n  generator will fill an empty init-coll.\n\n  Same options as 'every'. conform will produce a collection\n  corresponding to :into if supplied, else will match the input collection,\n  avoiding rebuilding when possible.\n\n  Same options as 'every'.\n\n  See also - every, map-of", :arglists ([pred & opts])}, :examples []} {:sym conform, :meta {:doc "Given a spec and a value, returns :cljs.spec.alpha/invalid if value does\n  not match spec, else the (possibly destructured) value.", :arglists ([spec x])}, :examples []} {:sym conform*, :meta {:doc nil, :arglists ([spec x])}, :examples []} {:sym conformer, :meta {:doc "takes a predicate function with the semantics of conform i.e. it should return either a\n  (possibly converted) value or :cljs.spec.alpha/invalid, and returns a\n  spec that uses it as a predicate/conformer. Optionally takes a\n  second fn that does unform of result of first", :arglists ([f] [f unf])}, :examples []} {:sym def, :meta {:doc "Given a namespace-qualified keyword or resolveable symbol k, and a spec,\n   spec-name, predicate or regex-op makes an entry in the registry mapping k to\n   the spec", :arglists ([k spec-form])}, :examples []} {:sym def-impl, :meta {:doc "Do not call this directly, use 'def'", :arglists ([k form spec])}, :examples []} {:sym describe, :meta {:doc "returns an abbreviated description of the spec as data", :arglists ([spec])}, :examples []} {:sym describe*, :meta {:doc nil, :arglists ([spec])}, :examples []} {:sym double-in, :meta {:doc "Specs a 64-bit floating point number. Options:\n\n    :infinite? - whether +/- infinity allowed (default true)\n    :NaN?      - whether NaN allowed (default true)\n    :min       - minimum value (inclusive, default none)\n    :max       - maximum value (inclusive, default none)", :arglists ([& {:keys [infinite? NaN? min max], :or {infinite? true, NaN? true}, :as m}])}, :examples []} {:sym every, :meta {:doc "takes a pred and validates collection elements against that pred.\n\n  Note that 'every' does not do exhaustive checking, rather it samples\n  *coll-check-limit* elements. Nor (as a result) does it do any\n  conforming of elements. 'explain' will report at most *coll-error-limit*\n  problems.  Thus 'every' should be suitable for potentially large\n  collections.\n\n  Takes several kwargs options that further constrain the collection:\n\n  :kind - a pred/spec that the collection type must satisfy, e.g. vector?\n          (default nil) Note that if :kind is specified and :into is\n          not, this pred must generate in order for every to generate.\n  :count - specifies coll has exactly this count (default nil)\n  :min-count, :max-count - coll has count (<= min-count count max-count) (defaults nil)\n  :distinct - all the elements are distinct (default nil)\n\n  And additional args that control gen\n\n  :gen-max - the maximum coll size to generate (default 20)\n  :into - one of [], (), {}, #{} - the default collection to generate into\n      (default same as :kind if supplied, else []\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator\n\n  See also - coll-of, every-kv\n", :arglists ([pred & {:keys [into kind count max-count min-count distinct gen-max gen-into gen], :as opts}])}, :examples []} {:sym every-impl, :meta {:doc "Do not call this directly, use 'every', 'every-kv', 'coll-of' or 'map-of'", :arglists ([form pred opts] [form pred {gen-into :into, describe-form :cljs.spec.alpha/describe, :keys [kind :cljs.spec.alpha/kind-form count max-count min-count distinct gen-max :cljs.spec.alpha/kfn :cljs.spec.alpha/cpred conform-keys :cljs.spec.alpha/conform-all], :or {gen-max 20}, :as opts} gfn])}, :examples []} {:sym every-kv, :meta {:doc "like 'every' but takes separate key and val preds and works on associative collections.\n\n  Same options as 'every', :into defaults to {}\n\n  See also - map-of", :arglists ([kpred vpred & opts])}, :examples []} {:sym exercise, :meta {:doc "generates a number (default 10) of values compatible with spec and maps conform over them,\n  returning a sequence of [val conformed-val] tuples. Optionally takes\n  a generator overrides map as per gen", :arglists ([spec] [spec n] [spec n overrides])}, :examples []} {:sym exercise-fn, :meta {:doc "exercises the fn named by sym (a symbol) by applying it to\n  n (default 10) generated samples of its args spec. When fspec is\n  supplied its arg spec is used, and sym-or-f can be a fn.  Returns a\n  sequence of tuples of [args ret]. ", :arglists ([sym] [sym n] [sym n fspec])}, :examples []} {:sym explain, :meta {:doc "Given a spec and a value that fails to conform, prints an explanation to *out*.", :arglists ([spec x])}, :examples []} {:sym explain*, :meta {:doc nil, :arglists ([spec path via in x])}, :examples []} {:sym explain-data, :meta {:doc "Given a spec and a value x which ought to conform, returns nil if x\n  conforms, else a map with at least the key ::problems whose value is\n  a collection of problem-maps, where problem-map has at least :path :pred and :val\n  keys describing the predicate and the value that failed at that\n  path.", :arglists ([spec x])}, :examples []} {:sym explain-data*, :meta {:doc nil, :arglists ([spec path via in x])}, :examples []} {:sym explain-out, :meta {:doc "Prints explanation data (per 'explain-data') to *out* using the printer in *explain-out*,\n    by default explain-printer.", :arglists ([ed])}, :examples []} {:sym explain-printer, :meta {:doc "Default printer for explain-data. nil indicates a successful validation.", :arglists ([ed])}, :examples []} {:sym explain-str, :meta {:doc "Given a spec and a value that fails to conform, returns an explanation as a string.", :arglists ([spec x])}, :examples []} {:sym fdef, :meta {:doc "Takes a symbol naming a function, and one or more of the following:\n\n  :args A regex spec for the function arguments as they were a list to be\n    passed to apply - in this way, a single spec can handle functions with\n    multiple arities\n  :ret A spec for the function's return value\n  :fn A spec of the relationship between args and ret - the\n    value passed is {:args conformed-args :ret conformed-ret} and is\n    expected to contain predicates that relate those values\n\n  Qualifies fn-sym with resolve, or using *ns* if no resolution found.\n  Registers an fspec in the global registry, where it can be retrieved\n  by calling get-spec with the var or full-qualified symbol.\n\n  Once registered, function specs are included in doc, checked by\n  instrument, tested by the runner cljs.spec.test.alpha/run-tests, and (if\n  a macro) used to explain errors during macroexpansion.\n\n  Note that :fn specs require the presence of :args and :ret specs to\n  conform values, and so :fn specs will be ignored if :args or :ret\n  are missing.\n\n  Returns the qualified fn-sym.\n\n  For example, to register function specs for the symbol function:\n\n  (s/fdef cljs.core/symbol\n    :args (s/alt :separate (s/cat :ns string? :n string?)\n                 :str string?\n                 :sym symbol?)\n    :ret symbol?)", :arglists ([fn-sym & specs])}, :examples []} {:sym form, :meta {:doc "returns the spec as data", :arglists ([spec])}, :examples []} {:sym fspec, :meta {:doc "takes :args :ret and (optional) :fn kwargs whose values are preds\n  and returns a spec whose conform/explain take a fn and validates it\n  using generative testing. The conformed value is always the fn itself.\n\n  See 'fdef' for a single operation that creates an fspec and\n  registers it, as well as a full description of :args, :ret and :fn\n\n  fspecs can generate functions that validate the arguments and\n  fabricate a return value compliant with the :ret spec, ignoring\n  the :fn spec if present.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args\n  that returns a test.check generator.", :arglists ([& {:keys [args ret fn gen], :or {ret (quote cljs.core/any?)}}])}, :examples []} {:sym fspec-impl, :meta {:doc "Do not call this directly, use 'fspec'", :arglists ([argspec aform retspec rform fnspec fform gfn])}, :examples []} {:sym gen, :meta {:doc "Given a spec, returns the generator for it, or throws if none can\n  be constructed. Optionally an overrides map can be provided which\n  should map spec names or paths (vectors of keywords) to no-arg\n  generator-creating fns. These will be used instead of the generators at those\n  names/paths. Note that parent generator (in the spec or overrides\n  map) will supersede those of any subtrees. A generator for a regex\n  op must always return a sequential collection (i.e. a generator for\n  s/? should return either an empty sequence/vector or a\n  sequence/vector with one item in it)", :arglists ([spec] [spec overrides])}, :examples []} {:sym gen*, :meta {:doc nil, :arglists ([spec overrides path rmap])}, :examples []} {:sym get-spec, :meta {:doc "Returns spec registered for keyword/symbol/var k, or nil.", :arglists ([k])}, :examples []} {:sym inst-in, :meta {:doc "Returns a spec that validates insts in the range from start\n  (inclusive) to end (exclusive).", :arglists ([start end])}, :examples []} {:sym inst-in-range?, :meta {:doc "Return true if inst at or after start and before end", :arglists ([start end inst])}, :examples []} {:sym int-in, :meta {:doc "Returns a spec that validates fixed precision integers in the\n  range from start (inclusive) to end (exclusive).", :arglists ([start end])}, :examples []} {:sym int-in-range?, :meta {:doc "Return true if start <= val, val < end and val is a fixed\n  precision integer.", :arglists ([start end val])}, :examples []} {:sym invalid?, :meta {:doc "tests the validity of a conform return value", :arglists ([ret])}, :examples []} {:sym keys, :meta {:doc "Creates and returns a map validating spec. :req and :opt are both\n  vectors of namespaced-qualified keywords. The validator will ensure\n  the :req keys are present. The :opt keys serve as documentation and\n  may be used by the generator.\n\n  The :req key vector supports 'and' and 'or' for key groups:\n\n  (s/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])\n\n  There are also -un versions of :req and :opt. These allow\n  you to connect unqualified keys to specs.  In each case, fully\n  qualfied keywords are passed, which name the specs, but unqualified\n  keys (with the same name component) are expected and checked at\n  conform-time, and generated during gen:\n\n  (s/keys :req-un [:my.ns/x :my.ns/y])\n\n  The above says keys :x and :y are required, and will be validated\n  and generated by specs (if they exist) named :my.ns/x :my.ns/y\n  respectively.\n\n  In addition, the values of *all* namespace-qualified keys will be validated\n  (and possibly destructured) by any registered specs. Note: there is\n  no support for inline value specification, by design.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.", :arglists ([& {:keys [req req-un opt opt-un gen]}])}, :examples []} {:sym keys*, :meta {:doc "takes the same arguments as spec/keys and returns a regex op that matches sequences of key/values,\n  converts them into a map, and conforms that map with a corresponding\n  spec/keys call:\n\n  user=> (s/conform (s/keys :req-un [::a ::c]) {:a 1 :c 2})\n  {:a 1, :c 2}\n  user=> (s/conform (s/keys* :req-un [::a ::c]) [:a 1 :c 2])\n  {:a 1, :c 2}\n\n  the resulting regex op can be composed into a larger regex:\n\n  user=> (s/conform (s/cat :i1 integer? :m (s/keys* :req-un [::a ::c]) :i2 integer?) [42 :a 1 :c 2 :d 4 99])\n  {:i1 42, :m {:a 1, :c 2, :d 4}, :i2 99}", :arglists ([& kspecs])}, :examples []} {:sym map-of, :meta {:doc "Returns a spec for a map whose keys satisfy kpred and vals satisfy\n  vpred. Unlike 'every-kv', map-of will exhaustively conform every\n  value.\n\n  Same options as 'every', :kind defaults to map?, with the addition of:\n\n  :conform-keys - conform keys as well as values (default false)\n\n  See also - every-kv", :arglists ([kpred vpred & opts])}, :examples []} {:sym map-spec, :meta {:doc nil, :arglists nil}, :examples []} {:sym map-spec-impl, :meta {:doc "Do not call this directly, use 'spec' with a map argument", :arglists ([{:keys [req-un opt-un keys-pred pred-exprs opt-keys req-specs req req-keys opt-specs pred-forms opt gfn], :as argm}])}, :examples []} {:sym maybe-impl, :meta {:doc "Do not call this directly, use '?'", :arglists ([p form])}, :examples []} {:sym merge, :meta {:doc "Takes map-validating specs (e.g. 'keys' specs) and\n  returns a spec that returns a conformed map satisfying all of the\n  specs.  Successive conformed values propagate through rest of\n  predicates. Unlike 'and', merge can generate maps satisfying the\n  union of the predicates.", :arglists ([& pred-forms])}, :examples []} {:sym merge-spec-impl, :meta {:doc "Do not call this directly, use 'merge'", :arglists ([forms preds gfn])}, :examples []} {:sym multi-spec, :meta {:doc "Takes the name of a spec/predicate-returning multimethod and a\n  tag-restoring keyword or fn (retag).  Returns a spec that when\n  conforming or explaining data will pass it to the multimethod to get\n  an appropriate spec. You can e.g. use multi-spec to dynamically and\n  extensibly associate specs with 'tagged' data (i.e. data where one\n  of the fields indicates the shape of the rest of the structure).\n\n  (defmulti mspec :tag)\n\n  The methods should ignore their argument and return a predicate/spec:\n  (defmethod mspec :int [_] (s/keys :req-un [::tag ::i]))\n\n  retag is used during generation to retag generated values with\n  matching tags. retag can either be a keyword, at which key the\n  dispatch-tag will be assoc'ed, or a fn of generated value and\n  dispatch-tag that should return an appropriately retagged value.\n\n  Note that because the tags themselves comprise an open set,\n  the tag key spec cannot enumerate the values, but can e.g.\n  test for keyword?.\n\n  Note also that the dispatch values of the multimethod will be\n  included in the path, i.e. in reporting and gen overrides, even\n  though those values are not evident in the spec.\n", :arglists ([mm retag])}, :examples []} {:sym multi-spec-impl, :meta {:doc "Do not call this directly, use 'multi-spec'", :arglists ([form mmvar retag] [form mmvar retag gfn])}, :examples []} {:sym nilable, :meta {:doc "returns a spec that accepts nil and values satisfiying pred", :arglists ([pred])}, :examples []} {:sym nilable-impl, :meta {:doc "Do not call this directly, use 'nilable'", :arglists ([form pred gfn])}, :examples []} {:sym nonconforming, :meta {:doc "takes a spec and returns a spec that has the same properties except\n  'conform' returns the original (not the conformed) value. Note, will specize regex ops.", :arglists ([spec])}, :examples []} {:sym or, :meta {:doc "Takes key+pred pairs, e.g.\n\n  (s/or :even even? :small #(< % 42))\n\n  Returns a destructuring spec that returns a map entry containing the\n  key of the first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return.", :arglists ([& key-pred-forms])}, :examples []} {:sym or-spec-impl, :meta {:doc "Do not call this directly, use 'or'", :arglists ([keys forms preds gfn])}, :examples []} {:sym regex-spec-impl, :meta {:doc "Do not call this directly, use 'spec' with a regex op argument", :arglists ([re gfn])}, :examples []} {:sym regex?, :meta {:doc "returns x if x is a (cljs.spec.alpha) regex op, else logical false", :arglists ([x])}, :examples []} {:sym registry, :meta {:doc "returns the registry map, prefer 'get-spec' to lookup a spec by name", :arglists ([])}, :examples []} {:sym rep+impl, :meta {:doc "Do not call this directly, use '+'", :arglists ([form p])}, :examples []} {:sym rep-impl, :meta {:doc "Do not call this directly, use '*'", :arglists ([form p])}, :examples []} {:sym spec, :meta {:doc "Takes a single predicate form, e.g. can be the name of a predicate,\n  like even?, or a fn literal like #(< % 42). Note that it is not\n  generally necessary to wrap predicates in spec when using the rest\n  of the spec macros, only to attach a unique generator\n\n  Can also be passed the result of one of the regex ops -\n  cat, alt, *, +, ?, in which case it will return a regex-conforming\n  spec, useful when nesting an independent regex.\n  ---\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.\n\n  Returns a spec.", :arglists ([form & {:keys [gen]}])}, :examples []} {:sym spec-impl, :meta {:doc "Do not call this directly, use 'spec'", :arglists ([form pred gfn cpred?] [form pred gfn cpred? unc])}, :examples []} {:sym spec?, :meta {:doc "returns x if x is a spec object, else logical false", :arglists ([x])}, :examples []} {:sym specize*, :meta {:doc nil, :arglists ([_] [_ form])}, :examples []} {:sym tuple, :meta {:doc "takes one or more preds and returns a spec for a tuple, a vector\n  where each element conforms to the corresponding pred. Each element\n  will be referred to in paths using its ordinal.", :arglists ([& preds])}, :examples []} {:sym tuple-impl, :meta {:doc "Do not call this directly, use 'tuple'", :arglists ([forms preds] [forms preds gfn])}, :examples []} {:sym unform, :meta {:doc "Given a spec and a value created by or compliant with a call to\n  'conform' with the same spec, returns a value with all conform\n   destructuring undone.", :arglists ([spec x])}, :examples []} {:sym unform*, :meta {:doc nil, :arglists ([spec y])}, :examples []} {:sym valid?, :meta {:doc "Helper function that returns true when x is valid for spec.", :arglists ([spec x] [spec x form])}, :examples []} {:sym with-gen, :meta {:doc "Takes a spec and a no-arg, generator-returning fn and returns a version of that spec that uses that generator", :arglists ([spec gen-fn])}, :examples []} {:sym with-gen*, :meta {:doc nil, :arglists ([spec gfn])}, :examples []}], cljs.reader [{:sym *default-data-reader-fn*, :meta {:doc nil, :arglists nil}, :examples []} {:sym *tag-table*, :meta {:doc nil, :arglists nil}, :examples []} {:sym add-data-readers, :meta {:doc nil, :arglists ([default-readers])}, :examples []} {:sym deregister-default-tag-parser!, :meta {:doc nil, :arglists ([])}, :examples []} {:sym deregister-tag-parser!, :meta {:doc nil, :arglists ([tag])}, :examples []} {:sym parse-and-validate-timestamp, :meta {:doc nil, :arglists ([s])}, :examples []} {:sym parse-timestamp, :meta {:doc nil, :arglists ([ts])}, :examples []} {:sym read, :meta {:doc "Reads the first object from an cljs.tools.reader.reader-types/IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\n   If no reader is provided, *in* will be used.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   cljs.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\n   is done by passing an opt map.\n\n   opts is a map that can include the following keys:\n   :eof - value to return on end-of-file. When not supplied, eof throws an exception.\n   :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\n              When not supplied, only the default-data-readers will be used.\n   :default - A function of two args, that will, if present and no reader is found for a tag,\n              be called with the tag and the value.", :arglists ([reader] [{:keys [eof], :as opts} reader] [reader eof-error? eof opts])}, :examples []} {:sym read-string, :meta {:doc "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   opts is a map as per cljs.tools.reader.edn/read", :arglists ([s] [opts s])}, :examples []} {:sym register-default-tag-parser!, :meta {:doc nil, :arglists ([f])}, :examples []} {:sym register-tag-parser!, :meta {:doc nil, :arglists ([tag f])}, :examples []}], clojure.walk [{:sym keywordize-keys, :meta {:doc "Recursively transforms all map keys from strings to keywords.", :arglists ([m])}, :examples []} {:sym postwalk, :meta {:doc "Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :arglists ([f form])}, :examples []} {:sym postwalk-replace, :meta {:doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first.", :arglists ([smap form])}, :examples []} {:sym prewalk, :meta {:doc "Like postwalk, but does pre-order traversal.", :arglists ([f form])}, :examples []} {:sym prewalk-replace, :meta {:doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first.", :arglists ([smap form])}, :examples []} {:sym stringify-keys, :meta {:doc "Recursively transforms all map keys from keywords to strings.", :arglists ([m])}, :examples []} {:sym walk, :meta {:doc "Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :arglists ([inner outer form])}, :examples []}], play-cljs.core [{:sym :animation, :examples [{:doc "Draws its children in a continuous loop.\n   \n   :duration  -  The number of milliseconds each child should be displayed (number)", :with-card card, :with-focus {:binding [:sym focus], :init-expr [:animation {:x 10, :y 10, :duration 200} [:image {:name "player_walk1.png", :width 80, :height 80}] [:image {:name "player_walk2.png", :width 80, :height 80}] [:image {:name "player_walk3.png", :width 80, :height 80}]]}, :body (do (defonce animation-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [state (atom {})] (doto animation-game (start-example-game card state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref state)] (try (render animation-game focus) (catch js/Error _)))))))) nil), :body-str "[:animation\n {:x 10, :y 10, :duration 200}\n [:image {:name \"player_walk1.png\", :width 80, :height 80}]\n [:image {:name \"player_walk2.png\", :width 80, :height 80}]\n [:image {:name \"player_walk3.png\", :width 80, :height 80}]]\n", :id "play-cljs.core/:animation/0"}]} {:sym :arc, :examples [{:doc "Draws an arc to the screen.\n   \n   :width  -  The width of the arc (number)\n   :height -  The height of the arc (number)\n   :start  -  Angle to start the arc, in radians (number)\n   :stop   -  Angle to stop the arc, in radians (number)", :with-card card, :with-focus {:binding [:sym focus], :init-expr [:arc {:x 200, :y 0, :width 200, :height 200, :start 0, :stop 3.14}]}, :body (do (defonce arc-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [state (atom {})] (doto arc-game (start-example-game card state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref state)] (try (render arc-game focus) (catch js/Error _)))))))) nil), :body-str "[:arc {:x 200, :y 0, :width 200, :height 200, :start 0, :stop 3.14}]\n", :id "play-cljs.core/:arc/0"}]} {:sym :bezier, :examples [{:doc "Draws a cubic Bezier curve on the screen.\n   \n   :x1  -  The x-coordinate of the first anchor point (number)\n   :y1  -  The y-coordinate of the first anchor point (number)\n   :x2  -  The x-coordinate of the first control point (number)\n   :y2  -  The y-coordinate of the first control point (number)\n   :x3  -  The x-coordinate of the second control point (number)\n   :y3  -  The y-coordinate of the second control point (number)\n   :x4  -  The x-coordinate of the second anchor point (number)\n   :y4  -  The y-coordinate of the second anchor point (number)\n   \n   :z1  -  The z-coordinate of the first anchor point (number)\n   :z2  -  The z-coordinate of the first control point (number)\n   :z3  -  The z-coordinate of the second anchor point (number)\n   :z4  -  The z-coordinate of the second control point (number)", :with-card card, :with-focus {:binding [:sym focus], :init-expr [:stroke {:colors [0 0 0]} [:bezier {:x1 85, :y1 20, :x2 10, :y2 10, :x3 90, :y3 90, :x4 15, :y4 80}]]}, :body (do (defonce bezier-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [state (atom {})] (doto bezier-game (start-example-game card state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref state)] (try (render bezier-game focus) (catch js/Error _)))))))) nil), :body-str "[:stroke\n {:colors [0 0 0]}\n [:bezier\n  {:x1 85, :y1 20, :x2 10, :y2 10, :x3 90, :y3 90, :x4 15, :y4 80}]]\n", :id "play-cljs.core/:bezier/0"}]} {:sym :contour, :examples [{:doc "Draws a negative shape.\n   \n   :points  -  The x and y vertexes to draw (vector of numbers)", :with-card card, :with-focus {:binding [:sym focus], :init-expr [:shape {:points [40 40 80 40 80 80 40 80]} [:contour {:points [20 20 20 40 40 40 40 20]}]]}, :body (do (defonce contour-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [state (atom {})] (doto contour-game (start-example-game card state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref state)] (try (render contour-game focus) (catch js/Error _)))))))) nil), :body-str "[:shape\n {:points [40 40 80 40 80 80 40 80]}\n [:contour {:points [20 20 20 40 40 40 40 20]}]]\n", :id "play-cljs.core/:contour/0"}]} {:sym :curve, :examples [{:doc "Draws a curved line on the screen between two points,\n   given as the middle four parameters.\n   \n   :x1  -  The x-coordinate of the beginning control point (number)\n   :y1  -  The y-coordinate of the beginning control point (number)\n   :x2  -  The x-coordinate of the first point (number)\n   :y2  -  The y-coordinate of the first point (number)\n   :x3  -  The x-coordinate of the second point (number)\n   :y3  -  The y-coordinate of the second point (number)\n   :x4  -  The x-coordinate of the ending control point (number)\n   :y4  -  The y-coordinate of the ending control point (number)\n   \n   :z1  -  The z-coordinate of the beginning control point (number)\n   :z2  -  The z-coordinate of the first point (number)\n   :z3  -  The z-coordinate of the second point (number)\n   :z4  -  The z-coordinate of the ending control point (number)", :with-card card, :with-focus {:binding [:sym focus], :init-expr [:stroke {:colors [255 102 0]} [:curve {:x1 5, :y1 26, :x2 5, :y2 26, :x3 73, :y3 24, :x4 73, :y4 180}]]}, :body (do (defonce curve-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [state (atom {})] (doto curve-game (start-example-game card state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref state)] (try (render curve-game focus) (catch js/Error _)))))))) nil), :body-str "[:stroke\n {:colors [255 102 0]}\n [:curve\n  {:x1 5, :y1 26, :x2 5, :y2 26, :x3 73, :y3 24, :x4 73, :y4 180}]]\n", :id "play-cljs.core/:curve/0"}]} {:sym :div, :examples [{:doc "Acts as a generic container of options that it passes\ndown to its children. The `x` and `y` are special in this example,\nserving as the pointer's position. Notice that the :rect is\nhard-coded at (0,0) but the :div is passing its own position down.", :with-card card, :with-focus {:binding [:sym focus], :init-expr [:div {:x x, :y y} [:fill {:color "lightblue"} [:rect {:x 0, :y 0, :width 100, :height 100}]]]}, :body (do (defonce div-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [state (atom {})] (doto div-game (start-example-game card state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 50, y 50}} (clojure.core/deref state)] (try (render div-game focus) (catch js/Error _)))))))) nil), :body-str "[:div\n {:x x, :y y}\n [:fill\n  {:color \"lightblue\"}\n  [:rect {:x 0, :y 0, :width 100, :height 100}]]]\n", :id "play-cljs.core/:div/0"}]} {:sym :ellipse, :examples [{:doc "Draws an ellipse (oval) to the screen.\n   \n   :width  -  The width of the ellipse (number)\n   :height -  The height of the ellipse (number)", :with-card card, :with-focus {:binding [:sym focus], :init-expr [:ellipse {:x 100, :y 100, :width 50, :height 70}]}, :body (do (defonce ellipse-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [state (atom {})] (doto ellipse-game (start-example-game card state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref state)] (try (render ellipse-game focus) (catch js/Error _)))))))) nil), :body-str "[:ellipse {:x 100, :y 100, :width 50, :height 70}]\n", :id "play-cljs.core/:ellipse/0"}]} {:sym :fill, :examples [{:doc "Sets the color of the children.\n   \n   :color  -  The name of the color (string)\n   :colors -  The RGB or HSB color values (vector of numbers)", :with-card card, :with-focus {:binding [:sym focus], :init-expr [:fill {:color "purple"} [:rect {:x 40, :y 40, :width 150, :height 150}]]}, :body (do (defonce fill-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [state (atom {})] (doto fill-game (start-example-game card state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref state)] (try (render fill-game focus) (catch js/Error _)))))))) nil), :body-str "[:fill\n {:color \"purple\"}\n [:rect {:x 40, :y 40, :width 150, :height 150}]]\n", :id "play-cljs.core/:fill/0"}]} {:sym :hsb, :examples [{:doc "Causes the color values in all children to be interpreted as HSB colors.\n   \n   :max-h  -  Range for hue (number)\n   :max-s  -  Range for saturation (number)\n   :max-b  -  Range for brightness (number)", :with-card card, :with-focus {:binding [:sym focus], :init-expr [:hsb {:max-h 100, :max-s 100, :max-b 100} [:fill {:colors [20 50 70]} [:rect {:x 10, :y 10, :width 70, :height 70}]]]}, :body (do (defonce hsb-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [state (atom {})] (doto hsb-game (start-example-game card state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref state)] (try (render hsb-game focus) (catch js/Error _)))))))) nil), :body-str "[:hsb\n {:max-h 100, :max-s 100, :max-b 100}\n [:fill\n  {:colors [20 50 70]}\n  [:rect {:x 10, :y 10, :width 70, :height 70}]]]\n", :id "play-cljs.core/:hsb/0"}]} {:sym :image, :examples [{:doc "Displays an image.\n   \n   :name   -  The file name of the image (string)\n   :width  -  The width of the image (number)\n   :height -  The height of the image (number)", :with-card card, :with-focus {:binding [:sym focus], :init-expr [:image {:name "player_stand.png", :x 0, :y 0, :width 80, :height 80}]}, :body (do (defonce image-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [state (atom {})] (doto image-game (start-example-game card state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref state)] (try (render image-game focus) (catch js/Error _)))))))) nil), :body-str "[:image {:name \"player_stand.png\", :x 0, :y 0, :width 80, :height 80}]\n", :id "play-cljs.core/:image/0"}]} {:sym :line, :examples [{:doc "Draws a line (a direct path between two points) to the screen.\n   \n   :x1  -  The x-coordinate of the first point (number)\n   :y1  -  The y-coordinate of the first point (number)\n   :x2  -  The x-coordinate of the second point (number)\n   :y2  -  The y-coordinate of the second point (number)", :with-card card, :with-focus {:binding [:sym focus], :init-expr [:line {:x1 0, :y1 0, :x2 50, :y2 50}]}, :body (do (defonce line-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [state (atom {})] (doto line-game (start-example-game card state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref state)] (try (render line-game focus) (catch js/Error _)))))))) nil), :body-str "[:line {:x1 0, :y1 0, :x2 50, :y2 50}]\n", :id "play-cljs.core/:line/0"}]} {:sym :point, :examples [{:doc "Draws a point, a coordinate in space at the dimension of one pixel.", :with-card card, :with-focus {:binding [:sym focus], :init-expr [[:point {:x 5, :y 5}] [:point {:x 10, :y 5}] [:point {:x 15, :y 5}] [:point {:x 20, :y 5}] [:point {:x 25, :y 5}] [:point {:x 30, :y 5}] [:point {:x 35, :y 5}]]}, :body (do (defonce point-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [state (atom {})] (doto point-game (start-example-game card state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref state)] (try (render point-game focus) (catch js/Error _)))))))) nil), :body-str "[[:point {:x 5, :y 5}]\n [:point {:x 10, :y 5}]\n [:point {:x 15, :y 5}]\n [:point {:x 20, :y 5}]\n [:point {:x 25, :y 5}]\n [:point {:x 30, :y 5}]\n [:point {:x 35, :y 5}]]\n", :id "play-cljs.core/:point/0"}]} {:sym :quad, :examples [{:doc "Draw a quad. A quad is a quadrilateral, a four sided polygon.\n   \n   :x1  -  The x-coordinate of the first point (number)\n   :y1  -  The y-coordinate of the first point (number)\n   :x2  -  The x-coordinate of the second point (number)\n   :y2  -  The y-coordinate of the second point (number)\n   :x3  -  The x-coordinate of the third point (number)\n   :y3  -  The y-coordinate of the third point (number)\n   :x4  -  The x-coordinate of the fourth point (number)\n   :y4  -  The y-coordinate of the fourth point (number)", :with-card card, :with-focus {:binding [:sym focus], :init-expr [:quad {:x1 50, :y1 55, :x2 70, :y2 15, :x3 10, :y3 15, :x4 20, :y4 55}]}, :body (do (defonce quad-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [state (atom {})] (doto quad-game (start-example-game card state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref state)] (try (render quad-game focus) (catch js/Error _)))))))) nil), :body-str "[:quad {:x1 50, :y1 55, :x2 70, :y2 15, :x3 10, :y3 15, :x4 20, :y4 55}]\n", :id "play-cljs.core/:quad/0"}]} {:sym :rect, :examples [{:doc "Draws a rectangle to the screen.\n   A rectangle is a four-sided shape with every angle at ninety degrees.\n   \n   :width  -  The width of the rectangle (number)\n   :height -  The height of the rectangle (number)", :with-card card, :with-focus {:binding [:sym focus], :init-expr [:rect {:x 10, :y 15, :width 20, :height 30}]}, :body (do (defonce rect-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [state (atom {})] (doto rect-game (start-example-game card state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref state)] (try (render rect-game focus) (catch js/Error _)))))))) nil), :body-str "[:rect {:x 10, :y 15, :width 20, :height 30}]\n", :id "play-cljs.core/:rect/0"}]} {:sym :rgb, :examples [{:doc "Causes the color values in all children to be interpreted as RGB colors.\n   \n   :max-r  -  Range for red (number)\n   :max-g  -  Range for green (number)\n   :max-b  -  Range for blue (number)", :with-card card, :with-focus {:binding [:sym focus], :init-expr [:rgb {:max-r 100, :max-g 100, :max-b 100} [:fill {:colors [20 50 70]} [:rect {:x 10, :y 10, :width 70, :height 70}]]]}, :body (do (defonce rgb-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [state (atom {})] (doto rgb-game (start-example-game card state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref state)] (try (render rgb-game focus) (catch js/Error _)))))))) nil), :body-str "[:rgb\n {:max-r 100, :max-g 100, :max-b 100}\n [:fill\n  {:colors [20 50 70]}\n  [:rect {:x 10, :y 10, :width 70, :height 70}]]]\n", :id "play-cljs.core/:rgb/0"}]} {:sym :shape, :examples [{:doc "Draws a complex shape.\n   \n   :points  -  The x and y vertexes to draw (vector of numbers)", :with-card card, :with-focus {:binding [:sym focus], :init-expr [:shape {:points [30 20 85 20 85 75 30 75]}]}, :body (do (defonce shape-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [state (atom {})] (doto shape-game (start-example-game card state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref state)] (try (render shape-game focus) (catch js/Error _)))))))) nil), :body-str "[:shape {:points [30 20 85 20 85 75 30 75]}]\n", :id "play-cljs.core/:shape/0"}]} {:sym :stroke, :examples [{:doc "Sets the color used to draw lines and borders around the children.\n   \n   :color  -  The name of the color (string)\n   :colors -  The RGB or HSB color values (vector of numbers)", :with-card card, :with-focus {:binding [:sym focus], :init-expr [:stroke {:color "green"} [:rect {:x 50, :y 50, :width 70, :height 70}]]}, :body (do (defonce stroke-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [state (atom {})] (doto stroke-game (start-example-game card state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref state)] (try (render stroke-game focus) (catch js/Error _)))))))) nil), :body-str "[:stroke {:color \"green\"} [:rect {:x 50, :y 50, :width 70, :height 70}]]\n", :id "play-cljs.core/:stroke/0"}]} {:sym :text, :examples [{:doc "Draws text to the screen.\n   \n   :value  -  The text to display (string)\n   :size   -  The font size (number)\n   :font   -  The name of the font (string)\n   :style  -  The font style (:normal, :italic, :bold)", :with-card card, :with-focus {:binding [:sym focus], :init-expr [:text {:value "Hello, world!", :x 0, :y 50, :size 16, :font "Georgia", :style :italic}]}, :body (do (defonce text-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [state (atom {})] (doto text-game (start-example-game card state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref state)] (try (render text-game focus) (catch js/Error _)))))))) nil), :body-str "[:text\n {:value \"Hello, world!\",\n  :x 0,\n  :y 50,\n  :size 16,\n  :font \"Georgia\",\n  :style :italic}]\n", :id "play-cljs.core/:text/0"}]} {:sym :triangle, :examples [{:doc "A triangle is a plane created by connecting three points.\n   \n   :x1  -  The x-coordinate of the first point (number)\n   :y1  -  The y-coordinate of the first point (number)\n   :x2  -  The x-coordinate of the second point (number)\n   :y2  -  The y-coordinate of the second point (number)\n   :x3  -  The x-coordinate of the third point (number)\n   :y3  -  The y-coordinate of the third point (number)", :with-card card, :with-focus {:binding [:sym focus], :init-expr [:triangle {:x1 10, :y1 10, :x2 50, :y2 25, :x3 10, :y3 35}]}, :body (do (defonce triangle-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [state (atom {})] (doto triangle-game (start-example-game card state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref state)] (try (render triangle-game focus) (catch js/Error _)))))))) nil), :body-str "[:triangle {:x1 10, :y1 10, :x2 50, :y2 25, :x3 10, :y3 35}]\n", :id "play-cljs.core/:triangle/0"}]} {:sym Game, :meta {:doc "A game object contains the internal renderer object and various bits of state\nthat are important to the overall execution of the game. Every play-cljs game\nshould create just one such object by calling `create-game`.", :arglists nil}, :examples []} {:sym Screen, :meta {:doc "A screen object provides the basic lifecycle for a game.\nSimple games may only need to have one screen. They are a useful way to\nisolate different aspects of your game. For example, you could make one\nscreen display the title and menu, and another screen contain the game\nitself.\n\nYou can create a screen by using `reify` like this:\n\n```\n(def main-screen\n  (reify p/Screen\n    (on-show [this])\n    (on-hide [this])\n    (on-render [this])))\n```", :arglists nil}, :examples []} {:sym create-game, :meta {:doc "Returns a game object.", :arglists ([width height] [width height {:keys [parent]}])}, :examples []} {:sym get-asset, :meta {:doc "Gets the asset with the given name.", :arglists ([game name])}, :examples []} {:sym get-canvas, :meta {:doc "Returns the internal canvas object.", :arglists ([game])}, :examples []} {:sym get-delta-time, :meta {:doc "Returns the time since the last frame was rendered, in milliseconds.", :arglists ([game])}, :examples []} {:sym get-height, :meta {:doc "Returns the virtual height of the game.", :arglists ([game])}, :examples []} {:sym get-pressed-keys, :meta {:doc "Returns a set containing the key codes for the keys currently being pressed.", :arglists ([game])}, :examples []} {:sym get-renderer, :meta {:doc "Returns the internal renderer object.", :arglists ([game])}, :examples []} {:sym get-screen, :meta {:doc "Returns the `Screen` object currently being displayed.", :arglists ([game])}, :examples []} {:sym get-total-time, :meta {:doc "Returns the total time transpired since the game started, in milliseconds.", :arglists ([game])}, :examples []} {:sym get-width, :meta {:doc "Returns the virtual width of the game.", :arglists ([game])}, :examples []} {:sym listen, :meta {:doc "Adds an event listener.", :arglists ([game listen-type listener])}, :examples []} {:sym load-image, :meta {:doc "Loads an image. Returns an `Image` object.", :arglists ([game path])}, :examples []} {:sym load-tiled-map, :meta {:doc "Loads a tiled map. Returns a `TiledMap` object.\nA tiled map with the provided name must already be loaded\n(see the TiledMap docs for details).", :arglists ([game map-name])}, :examples []} {:sym on-hide, :meta {:doc "Runs once, when the screen is no longer displayed.", :arglists ([this])}, :examples []} {:sym on-render, :meta {:doc "Runs each time the game is ready to render another frame.", :arglists ([this])}, :examples []} {:sym on-show, :meta {:doc "Runs once, when the screen first appears.", :arglists ([this])}, :examples []} {:sym pre-render, :meta {:doc "Renders the provided data structure off-screen and associates it with the given name. Returns an `Image` object.", :arglists ([game image-name width height content])}, :examples []} {:sym render, :meta {:doc "Renders the provided data structure.", :arglists ([game content])}, :examples []} {:sym set-screen, :meta {:doc "Sets the `Screen` object to be displayed.", :arglists ([game screen])}, :examples []} {:sym set-size, :meta {:doc "Sets the virtual width and height of the game.", :arglists ([game width height])}, :examples []} {:sym start, :meta {:doc "Creates the canvas element.", :arglists ([game])}, :examples []}], cljs.core.async.impl.timers [{:sym ->SkipList, :meta {:doc nil, :arglists ([header level])}, :examples []} {:sym ->SkipListNode, :meta {:doc nil, :arglists ([key val forward])}, :examples []} {:sym MAX_LEVEL, :meta {:doc nil, :arglists nil}, :examples []} {:sym P, :meta {:doc nil, :arglists nil}, :examples []} {:sym SkipList, :meta {:doc nil, :arglists nil}, :examples []} {:sym SkipListNode, :meta {:doc nil, :arglists nil}, :examples []} {:sym TIMEOUT_RESOLUTION_MS, :meta {:doc nil, :arglists nil}, :examples []} {:sym least-greater-node, :meta {:doc nil, :arglists ([x k level] [x k level update])}, :examples []} {:sym random-level, :meta {:doc nil, :arglists ([] [level])}, :examples []} {:sym skip-list, :meta {:doc nil, :arglists ([])}, :examples []} {:sym skip-list-node, :meta {:doc nil, :arglists ([level] [k v level])}, :examples []} {:sym timeout, :meta {:doc "returns a channel that will close after msecs", :arglists ([msecs])}, :examples []} {:sym timeouts-map, :meta {:doc nil, :arglists nil}, :examples []}], clojure.browser.event [{:sym IEventType, :meta {:doc nil, :arglists nil}, :examples []} {:sym all-listeners, :meta {:doc nil, :arglists ([obj type capture])}, :examples []} {:sym dispatch-event, :meta {:doc nil, :arglists ([src event])}, :examples []} {:sym event-types, :meta {:doc nil, :arglists ([this])}, :examples []} {:sym expose, :meta {:doc nil, :arglists ([e])}, :examples []} {:sym fire-listeners, :meta {:doc nil, :arglists ([obj type capture event])}, :examples []} {:sym get-listener, :meta {:doc nil, :arglists ([src type listener opt_capt opt_handler])}, :examples []} {:sym has-listener, :meta {:doc nil, :arglists ([obj opt_type opt_capture])}, :examples []} {:sym listen, :meta {:doc nil, :arglists ([src type fn] [src type fn capture?])}, :examples []} {:sym listen-once, :meta {:doc nil, :arglists ([src type fn] [src type fn capture?])}, :examples []} {:sym remove-all, :meta {:doc nil, :arglists ([opt_obj opt_type opt_capt])}, :examples []} {:sym total-listener-count, :meta {:doc nil, :arglists ([])}, :examples []} {:sym unique-event-id, :meta {:doc nil, :arglists ([event-type])}, :examples []} {:sym unlisten, :meta {:doc nil, :arglists ([src type fn] [src type fn capture?])}, :examples []} {:sym unlisten-by-key, :meta {:doc nil, :arglists ([key])}, :examples []}], cljs.spec.gen.alpha [{:sym ->LazyVar, :meta {:doc nil, :arglists ([f cached])}, :examples []} {:sym LazyVar, :meta {:doc nil, :arglists nil}, :examples []} {:sym any, :meta {:doc "Fn returning clojure.test.check.generators/any", :arglists ([& args])}, :examples []} {:sym any-printable, :meta {:doc "Fn returning clojure.test.check.generators/any-printable", :arglists ([& args])}, :examples []} {:sym bind, :meta {:doc "Lazy loaded version of clojure.test.check.generators/bind", :arglists ([& args])}, :examples []} {:sym boolean, :meta {:doc "Fn returning clojure.test.check.generators/boolean", :arglists ([& args])}, :examples []} {:sym cat, :meta {:doc "Returns a generator of a sequence catenated from results of\ngens, each of which should generate something sequential.", :arglists ([& gens])}, :examples []} {:sym char, :meta {:doc "Fn returning clojure.test.check.generators/char", :arglists ([& args])}, :examples []} {:sym char-alpha, :meta {:doc "Fn returning clojure.test.check.generators/char-alpha", :arglists ([& args])}, :examples []} {:sym char-alphanumeric, :meta {:doc "Fn returning clojure.test.check.generators/char-alphanumeric", :arglists ([& args])}, :examples []} {:sym char-ascii, :meta {:doc "Fn returning clojure.test.check.generators/char-ascii", :arglists ([& args])}, :examples []} {:sym choose, :meta {:doc "Lazy loaded version of clojure.test.check.generators/choose", :arglists ([& args])}, :examples []} {:sym delay, :meta {:doc "given body that returns a generator, returns a\n  generator that delegates to that, but delays\n  creation until used.", :arglists ([& body])}, :examples []} {:sym delay-impl, :meta {:doc nil, :arglists ([gfnd])}, :examples []} {:sym double, :meta {:doc "Fn returning clojure.test.check.generators/double", :arglists ([& args])}, :examples []} {:sym double*, :meta {:doc "Lazy loaded version of clojure.test.check.generators/double*", :arglists ([& args])}, :examples []} {:sym dynaload, :meta {:doc nil, :arglists ([[quote s]])}, :examples []} {:sym elements, :meta {:doc "Lazy loaded version of clojure.test.check.generators/elements", :arglists ([& args])}, :examples []} {:sym fmap, :meta {:doc "Lazy loaded version of clojure.test.check.generators/fmap", :arglists ([& args])}, :examples []} {:sym for-all*, :meta {:doc "Dynamically loaded clojure.test.check.properties/for-all*.", :arglists ([& args])}, :examples []} {:sym frequency, :meta {:doc "Lazy loaded version of clojure.test.check.generators/frequency", :arglists ([& args])}, :examples []} {:sym gen-for-pred, :meta {:doc "Given a predicate, returns a built-in generator if one exists.", :arglists ([pred])}, :examples []} {:sym generate, :meta {:doc "Generate a single value using generator.", :arglists ([generator])}, :examples []} {:sym hash-map, :meta {:doc "Lazy loaded version of clojure.test.check.generators/hash-map", :arglists ([& args])}, :examples []} {:sym int, :meta {:doc "Fn returning clojure.test.check.generators/int", :arglists ([& args])}, :examples []} {:sym keyword, :meta {:doc "Fn returning clojure.test.check.generators/keyword", :arglists ([& args])}, :examples []} {:sym keyword-ns, :meta {:doc "Fn returning clojure.test.check.generators/keyword-ns", :arglists ([& args])}, :examples []} {:sym large-integer, :meta {:doc "Fn returning clojure.test.check.generators/large-integer", :arglists ([& args])}, :examples []} {:sym large-integer*, :meta {:doc "Lazy loaded version of clojure.test.check.generators/large-integer*", :arglists ([& args])}, :examples []} {:sym lazy-combinator, :meta {:doc "Implementation macro, do not call directly.", :arglists ([s])}, :examples []} {:sym lazy-combinators, :meta {:doc "Implementation macro, do not call directly.", :arglists ([& syms])}, :examples []} {:sym lazy-prim, :meta {:doc "Implementation macro, do not call directly.", :arglists ([s])}, :examples []} {:sym lazy-prims, :meta {:doc "Implementation macro, do not call directly.", :arglists ([& syms])}, :examples []} {:sym list, :meta {:doc "Lazy loaded version of clojure.test.check.generators/list", :arglists ([& args])}, :examples []} {:sym map, :meta {:doc "Lazy loaded version of clojure.test.check.generators/map", :arglists ([& args])}, :examples []} {:sym not-empty, :meta {:doc "Lazy loaded version of clojure.test.check.generators/not-empty", :arglists ([& args])}, :examples []} {:sym one-of, :meta {:doc "Lazy loaded version of clojure.test.check.generators/one-of", :arglists ([& args])}, :examples []} {:sym quick-check, :meta {:doc nil, :arglists ([& args])}, :examples []} {:sym ratio, :meta {:doc "Fn returning clojure.test.check.generators/ratio", :arglists ([& args])}, :examples []} {:sym return, :meta {:doc "Lazy loaded version of clojure.test.check.generators/return", :arglists ([& args])}, :examples []} {:sym sample, :meta {:doc "Lazy loaded version of clojure.test.check.generators/sample", :arglists ([& args])}, :examples []} {:sym set, :meta {:doc "Lazy loaded version of clojure.test.check.generators/set", :arglists ([& args])}, :examples []} {:sym simple-type, :meta {:doc "Fn returning clojure.test.check.generators/simple-type", :arglists ([& args])}, :examples []} {:sym simple-type-printable, :meta {:doc "Fn returning clojure.test.check.generators/simple-type-printable", :arglists ([& args])}, :examples []} {:sym string, :meta {:doc "Fn returning clojure.test.check.generators/string", :arglists ([& args])}, :examples []} {:sym string-alphanumeric, :meta {:doc "Fn returning clojure.test.check.generators/string-alphanumeric", :arglists ([& args])}, :examples []} {:sym string-ascii, :meta {:doc "Fn returning clojure.test.check.generators/string-ascii", :arglists ([& args])}, :examples []} {:sym such-that, :meta {:doc "Lazy loaded version of clojure.test.check.generators/such-that", :arglists ([& args])}, :examples []} {:sym symbol, :meta {:doc "Fn returning clojure.test.check.generators/symbol", :arglists ([& args])}, :examples []} {:sym symbol-ns, :meta {:doc "Fn returning clojure.test.check.generators/symbol-ns", :arglists ([& args])}, :examples []} {:sym tuple, :meta {:doc "Lazy loaded version of clojure.test.check.generators/tuple", :arglists ([& args])}, :examples []} {:sym uuid, :meta {:doc "Fn returning clojure.test.check.generators/uuid", :arglists ([& args])}, :examples []} {:sym vector, :meta {:doc "Lazy loaded version of clojure.test.check.generators/vector", :arglists ([& args])}, :examples []} {:sym vector-distinct, :meta {:doc "Lazy loaded version of clojure.test.check.generators/vector-distinct", :arglists ([& args])}, :examples []}], cljs.user []}, :rel-path "../../", :hide-sidebar? true, :static? true, :ns-sym play-cljs.core, :vars [{:sym get-delta-time, :meta {:doc "Returns the time since the last frame was rendered, in milliseconds.", :arglists ([game])}, :examples []}]}</script>
        <script type="text/javascript" src="../../main.js"></script>
    </body>
</html>
